Hash,Original_Message,Filename,Source_Code_Before,Source_Code_Current,Diff,LLM_Rectified_Message,MI_Change,CC_Change,LOC_Change
1311782bedaa31c28edf36bf1dfb0decd971b6e3,Apprise and AppriseAsset unittesting + bugfixes,Apprise.py,"# -*- coding: utf-8 -*-
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import re
import logging

from .common import NotifyType
from .common import NOTIFY_TYPES
from .utils import parse_list

from .AppriseAsset import AppriseAsset

from . import plugins

logger = logging.getLogger(__name__)

# Build a list of supported plugins
SCHEMA_MAP = {}

# Used for attempting to acquire the schema if the URL can't be parsed.
GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]+)://.*$', re.I)


# Load our Lookup Matrix
def __load_matrix():
    """"""
    Dynamically load our schema map; this allows us to gracefully
    skip over plugins we simply don't have the dependecies for.

    """"""
    # to add it's mapping to our hash table
    for entry in dir(plugins):

        # Get our plugin
        plugin = getattr(plugins, entry)

        # Load protocol(s) if defined
        proto = getattr(plugin, 'protocol', None)
        if isinstance(proto, basestring):
            if proto not in SCHEMA_MAP:
                SCHEMA_MAP[proto] = plugin

        elif isinstance(proto, (set, list, tuple)):
            # Support iterables list types
            for p in proto:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin

        # Load secure protocol(s) if defined
        protos = getattr(plugin, 'secure_protocol', None)
        if isinstance(protos, basestring):
            if protos not in SCHEMA_MAP:
                SCHEMA_MAP[protos] = plugin

        if isinstance(protos, (set, list, tuple)):
            # Support iterables list types
            for p in protos:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin


# Dynamically build our module
__load_matrix()


class Apprise(object):
    """"""
    Our Notification Manager

    """"""
    def __init__(self, servers=None, asset=None):
        """"""
        Loads a set of server urls while applying the Asset() module to each
        if specified.

        If no asset is provided, then the default asset is used.

        """"""

        # Initialize a server list of URLs
        self.servers = list()

        # Assigns an central asset object that will be later passed into each
        # notification plugin.  Assets contain information such as the local
        # directory images can be found in. It can also identify remote
        # URL paths that contain the images you want to present to the end
        # user. If no asset is specified, then the default one is used.
        self.asset = asset
        if asset is None:
            # Load our default configuration
            self.asset = AppriseAsset()

        if servers:
            self.add(servers)

    def add(self, servers, asset=None):
        """"""
        Adds one or more server URLs into our list.

        """"""

        # Initialize our return status
        return_status = True

        servers = parse_list(servers)
        for _server in servers:

            # swap hash (#) tag values with their html version
            # This is useful for accepting channels (as arguments to
            # pushbullet)
            _server = _server.replace('/#', '/%23')

            # Attempt to acquire the schema at the very least to allow
            # our plugins to determine if they can make a better
            # interpretation of a URL geared for them anyway.
            schema = GET_SCHEMA_RE.match(_server)
            if schema is None:
                logger.error(
                    '%s is an unparseable server url.' % _server,
                )
                return_status = False
                continue

            # Update the schema
            schema = schema.group('schema').lower()

            # Some basic validation
            if schema not in SCHEMA_MAP:
                logger.error(
                    '%s is not a supported server type.' % schema,
                )
                return_status = False
                continue

            # Parse our url details
            # the server object is a dictionary containing all of the
            # information parsed from our URL
            results = SCHEMA_MAP[schema].parse_url(_server)

            if not results:
                # Failed to parse the server URL
                logger.error('Could not parse URL: %s' % _server)
                return_status = False
                continue

            try:
                # Attempt to create an instance of our plugin using the parsed
                # URL information
                plugin = SCHEMA_MAP[results['schema']](**results)

            except:
                # the arguments are invalid or can not be used.
                return_status = False
                continue

            # Save our asset
            if asset:
                plugin.asset = asset

            else:
                plugin.asset = self.asset

            # Add our initialized plugin to our server listings
            self.servers.append(plugin)

            # Return our status
            return return_status

    def clear(self, urls):
        """"""
        Empties our server list

        """"""
        self.servers.clear()

    def notify(self, title, body, notify_type=NotifyType.SUCCESS, **kwargs):
        """"""
        This should be over-rided by the class that inherits this one.
        """"""

        # Initialize our return result
        status = len(self.servers) > 0

        if notify_type and notify_type not in NOTIFY_TYPES:
            logger.warning(
                'An invalid notification type (%s) was specified.' % (
                    notify_type))

        if not isinstance(body, basestring):
            body = ''

        if not isinstance(title, basestring):
            title = ''

        # Iterate over our loaded plugins
        for server in self.servers:
            try:
                # Send notification
                if not server.notify(title=title, body=body):

                    # Toggle our return status flag
                    status = False

            except:
                # A catch all so we don't have to abort early
                # just because one of our plugins has a bug in it.
                # TODO: print backtrace
                status = False

        return status
","# -*- coding: utf-8 -*-
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import re
import logging

from .common import NotifyType
from .common import NOTIFY_TYPES
from .utils import parse_list

from .AppriseAsset import AppriseAsset

from . import plugins

logger = logging.getLogger(__name__)

# Build a list of supported plugins
SCHEMA_MAP = {}

# Used for attempting to acquire the schema if the URL can't be parsed.
GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]{3,9})://.*$', re.I)


# Load our Lookup Matrix
def __load_matrix():
    """"""
    Dynamically load our schema map; this allows us to gracefully
    skip over plugins we simply don't have the dependecies for.

    """"""
    # to add it's mapping to our hash table
    for entry in dir(plugins):

        # Get our plugin
        plugin = getattr(plugins, entry)

        # Load protocol(s) if defined
        proto = getattr(plugin, 'protocol', None)
        if isinstance(proto, basestring):
            if proto not in SCHEMA_MAP:
                SCHEMA_MAP[proto] = plugin

        elif isinstance(proto, (set, list, tuple)):
            # Support iterables list types
            for p in proto:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin

        # Load secure protocol(s) if defined
        protos = getattr(plugin, 'secure_protocol', None)
        if isinstance(protos, basestring):
            if protos not in SCHEMA_MAP:
                SCHEMA_MAP[protos] = plugin

        if isinstance(protos, (set, list, tuple)):
            # Support iterables list types
            for p in protos:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin


# Dynamically build our module
__load_matrix()


class Apprise(object):
    """"""
    Our Notification Manager

    """"""
    def __init__(self, servers=None, asset=None):
        """"""
        Loads a set of server urls while applying the Asset() module to each
        if specified.

        If no asset is provided, then the default asset is used.

        """"""

        # Initialize a server list of URLs
        self.servers = list()

        # Assigns an central asset object that will be later passed into each
        # notification plugin.  Assets contain information such as the local
        # directory images can be found in. It can also identify remote
        # URL paths that contain the images you want to present to the end
        # user. If no asset is specified, then the default one is used.
        self.asset = asset
        if asset is None:
            # Load our default configuration
            self.asset = AppriseAsset()

        if servers:
            self.add(servers)

    def add(self, servers, asset=None):
        """"""
        Adds one or more server URLs into our list.

        """"""

        # Initialize our return status
        return_status = True

        servers = parse_list(servers)
        for _server in servers:

            # swap hash (#) tag values with their html version
            # This is useful for accepting channels (as arguments to
            # pushbullet)
            _server = _server.replace('/#', '/%23')

            # Attempt to acquire the schema at the very least to allow
            # our plugins to determine if they can make a better
            # interpretation of a URL geared for them anyway.
            schema = GET_SCHEMA_RE.match(_server)
            if schema is None:
                logger.error(
                    '%s is an unparseable server url.' % _server,
                )
                return_status = False
                continue

            # Update the schema
            schema = schema.group('schema').lower()

            # Some basic validation
            if schema not in SCHEMA_MAP:
                logger.error(
                    '%s is not a supported server type.' % schema,
                )
                return_status = False
                continue

            # Parse our url details
            # the server object is a dictionary containing all of the
            # information parsed from our URL
            results = SCHEMA_MAP[schema].parse_url(_server)

            if not results:
                # Failed to parse the server URL
                logger.error('Could not parse URL: %s' % _server)
                return_status = False
                continue

            try:
                # Attempt to create an instance of our plugin using the parsed
                # URL information
                plugin = SCHEMA_MAP[results['schema']](**results)

            except:
                # the arguments are invalid or can not be used.
                return_status = False
                continue

            # Save our asset
            if asset:
                plugin.asset = asset

            else:
                plugin.asset = self.asset

            # Add our initialized plugin to our server listings
            self.servers.append(plugin)

        # Return our status
        return return_status

    def clear(self):
        """"""
        Empties our server list

        """"""
        self.servers[:] = []

    def notify(self, title, body, notify_type=NotifyType.SUCCESS, **kwargs):
        """"""
        This should be over-rided by the class that inherits this one.
        """"""

        # Initialize our return result
        status = len(self.servers) > 0

        if not (title or body):
            return False

        # Iterate over our loaded plugins
        for server in self.servers:
            try:
                # Send notification
                if not server.notify(title=title, body=body):

                    # Toggle our return status flag
                    status = False

            except:
                # A catch all so we don't have to abort early
                # just because one of our plugins has a bug in it.
                # TODO: print backtrace
                status = False

        return status

    def __len__(self):
        """"""
        Returns the number of servers loaded
        """"""
        return len(self.servers)
","@@ -36,7 +36,7 @@ logger = logging.getLogger(__name__)
 SCHEMA_MAP = {}
 
 # Used for attempting to acquire the schema if the URL can't be parsed.
-GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]+)://.*$', re.I)
+GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]{3,9})://.*$', re.I)
 
 
 # Load our Lookup Matrix
@@ -181,15 +181,15 @@ class Apprise(object):
             # Add our initialized plugin to our server listings
             self.servers.append(plugin)
 
-            # Return our status
-            return return_status
+        # Return our status
+        return return_status
 
-    def clear(self, urls):
+    def clear(self):
         """"""
         Empties our server list
 
         """"""
-        self.servers.clear()
+        self.servers[:] = []
 
     def notify(self, title, body, notify_type=NotifyType.SUCCESS, **kwargs):
         """"""
@@ -199,16 +199,8 @@ class Apprise(object):
         # Initialize our return result
         status = len(self.servers) > 0
 
-        if notify_type and notify_type not in NOTIFY_TYPES:
-            logger.warning(
-                'An invalid notification type (%s) was specified.' % (
-                    notify_type))
-
-        if not isinstance(body, basestring):
-            body = ''
-
-        if not isinstance(title, basestring):
-            title = ''
+        if not (title or body):
+            return False
 
         # Iterate over our loaded plugins
         for server in self.servers:
@@ -226,3 +218,9 @@ class Apprise(object):
                 status = False
 
         return status
+
+    def __len__(self):
+        """"""
+        Returns the number of servers loaded
+        """"""
+        return len(self.servers)
",add missing docstrings,-0.26,-3,-2
1311782bedaa31c28edf36bf1dfb0decd971b6e3,Apprise and AppriseAsset unittesting + bugfixes,AppriseAsset.py,"# -*- coding: utf-8 -*-
#
# Apprise Asset
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import join
from os.path import dirname
from os.path import isfile
from os.path import abspath
from .common import NotifyType


class AppriseAsset(object):
    """"""
    Provides a supplimentary class that can be used to provide extra
    information and details that can be used by Apprise such as providing
    an alternate location to where images/icons can be found and the
    URL masks.

    """"""
    # A Simple Mapping of Colors; For every NOTIFY_TYPE identified,
    # there should be a mapping to it's color here:
    html_notify_map = {
        NotifyType.INFO: '#3AA3E3',
        NotifyType.SUCCESS: '#3AA337',
        NotifyType.FAILURE: '#A32037',
        NotifyType.WARNING: '#CACF29',
    }

    # The default theme
    theme = 'default'

    # Image URL Mask
    image_url_mask = \
        'http://nuxref.com/apprise/themes/{THEME}/apprise-{TYPE}-{XY}.png'

    # Image Path Mask
    image_path_mask = abspath(join(
        dirname(__file__),
        'assets',
        'themes',
        '{THEME}',
        'apprise-{TYPE}-{XY}.png',
    ))

    def __init__(self, theme='default', image_path_mask=None,
                 image_url_mask=None):
        """"""
        Asset Initialization

        """"""
        if theme:
            self.theme = theme

        if image_path_mask:
            self.image_path_mask = image_path_mask

        if image_url_mask:
            self.image_url_mask = image_url_mask

    def html_color(self, notify_type):
        """"""
        Returns an HTML mapped color based on passed in notify type
        """"""
        # Attempt to get the type, otherwise return a default grey
        # if we couldn't look up the entry
        return self.html_notify_map.get(notify_type, '#888888')

    def image_url(self, notify_type, image_size):
        """"""
        Apply our mask to our image URL

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        return re_table.sub(lambda x: re_map[x.group()], self.image_url_mask)

    def image_path(self, notify_type, image_size, must_exist=True):
        """"""
        Apply our mask to our image file path

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        # Acquire our path
        path = re_table.sub(lambda x: re_map[x.group()], self.image_path_mask)
        if must_exist and not isfile(path):
            return None

        # Return what we parsed
        return path

    def image_raw(self, notify_type, image_size):
        """"""
        Returns the raw image if it can (otherwise the function returns None)

        """"""

        path = self.image_path(notify_type=notify_type, image_size=image_size)
        if path:
            try:
                with open(path, 'rb') as fd:
                    return fd.read()

            except (OSError, IOError):
                # We can't access the file
                pass

        return None
","# -*- coding: utf-8 -*-
#
# Apprise Asset
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import join
from os.path import dirname
from os.path import isfile
from os.path import abspath
from .common import NotifyType


class AppriseAsset(object):
    """"""
    Provides a supplimentary class that can be used to provide extra
    information and details that can be used by Apprise such as providing
    an alternate location to where images/icons can be found and the
    URL masks.

    """"""
    # A Simple Mapping of Colors; For every NOTIFY_TYPE identified,
    # there should be a mapping to it's color here:
    html_notify_map = {
        NotifyType.INFO: '#3AA3E3',
        NotifyType.SUCCESS: '#3AA337',
        NotifyType.FAILURE: '#A32037',
        NotifyType.WARNING: '#CACF29',
    }

    # The default color to return if a mapping isn't found in our table above
    default_html_color = '#888888'

    # The default theme
    theme = 'default'

    # Image URL Mask
    image_url_mask = \
        'http://nuxref.com/apprise/themes/{THEME}/apprise-{TYPE}-{XY}.png'

    # Image Path Mask
    image_path_mask = abspath(join(
        dirname(__file__),
        'assets',
        'themes',
        '{THEME}',
        'apprise-{TYPE}-{XY}.png',
    ))

    def __init__(self, theme='default', image_path_mask=None,
                 image_url_mask=None):
        """"""
        Asset Initialization

        """"""
        if theme:
            self.theme = theme

        if image_path_mask:
            self.image_path_mask = image_path_mask

        if image_url_mask:
            self.image_url_mask = image_url_mask

    def html_color(self, notify_type):
        """"""
        Returns an HTML mapped color based on passed in notify type
        """"""
        # Attempt to get the type, otherwise return a default grey
        # if we couldn't look up the entry
        return self.html_notify_map.get(notify_type, self.default_html_color)

    def image_url(self, notify_type, image_size):
        """"""
        Apply our mask to our image URL

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        return re_table.sub(lambda x: re_map[x.group()], self.image_url_mask)

    def image_path(self, notify_type, image_size, must_exist=True):
        """"""
        Apply our mask to our image file path

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        # Acquire our path
        path = re_table.sub(lambda x: re_map[x.group()], self.image_path_mask)
        if must_exist and not isfile(path):
            return None

        # Return what we parsed
        return path

    def image_raw(self, notify_type, image_size):
        """"""
        Returns the raw image if it can (otherwise the function returns None)

        """"""

        path = self.image_path(notify_type=notify_type, image_size=image_size)
        if path:
            try:
                with open(path, 'rb') as fd:
                    return fd.read()

            except (OSError, IOError):
                # We can't access the file
                pass

        return None
","@@ -42,6 +42,9 @@ class AppriseAsset(object):
         NotifyType.WARNING: '#CACF29',
     }
 
+    # The default color to return if a mapping isn't found in our table above
+    default_html_color = '#888888'
+
     # The default theme
     theme = 'default'
 
@@ -79,7 +82,7 @@ class AppriseAsset(object):
         """"""
         # Attempt to get the type, otherwise return a default grey
         # if we couldn't look up the entry
-        return self.html_notify_map.get(notify_type, '#888888')
+        return self.html_notify_map.get(notify_type, self.default_html_color)
 
     def image_url(self, notify_type, image_size):
         """"""
",add missing comments,-0.21,0,3
1311782bedaa31c28edf36bf1dfb0decd971b6e3,Apprise and AppriseAsset unittesting + bugfixes,test_api.py,"""""""API properties.

""""""

from __future__ import print_function
from __future__ import unicode_literals
from apprise import Apprise


def test_initialization():
    ""API: apprise() test initialization""""""
    a = Apprise()
","""""""API properties.

""""""

from __future__ import print_function
from __future__ import unicode_literals
from apprise import Apprise
from apprise import AppriseAsset
from apprise.Apprise import SCHEMA_MAP
from apprise.plugins.NotifyBase import NotifyBase
from apprise import NotifyType
from apprise import NotifyImageSize


def test_apprise():
    """"""
    API: Apprise() object

    """"""
    a = Apprise()

    # no items
    assert(len(a) == 0)

    # Create an Asset object
    asset = AppriseAsset(theme='default')

    # We can load the device using our asset
    a = Apprise(asset=asset)

    # We can load our servers up front as well
    servers = [
        'faast://abcdefghijklmnop-abcdefg',
        'kodi://kodi.server.local',
        'palot://1f418df7577e32b89ac6511f2eb9aa68',
    ]

    a = Apprise(servers=servers)

    # 3 servers loaded
    assert(len(a) == 3)

    # We can add another server
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4') is True)
    assert(len(a) == 4)

    # We can empty our set
    a.clear()
    assert(len(a) == 0)

    # An invalid schema
    assert(
        a.add('this is not a parseable url at all') is False)
    assert(len(a) == 0)

    # An unsupported schema
    assert(
        a.add('invalid://we.just.do.not.support.this.plugin.type') is False)
    assert(len(a) == 0)

    # A poorly formatted URL
    assert(
        a.add('json://user:@@@:bad?no.good') is False)
    assert(len(a) == 0)

    # Add a server with our asset we created earlier
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4', asset=asset) is True)

    # Clear our server listings again
    a.clear()

    # No servers to notify
    assert(a.notify(title=""my title"", body=""my body"") is False)

    class BadNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(BadNotification, self).__init__()

            # We fail whenever we're initialized
            raise TypeError()

    class GoodNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(GoodNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return True

    # Store our bad notification in our schema map
    SCHEMA_MAP['bad'] = BadNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['good'] = GoodNotification

    # Just to explain what is happening here, we would have parsed the
    # url properly but failed when we went to go and create an instance
    # of it.
    assert(a.add('bad://localhost') is False)
    assert(len(a) == 0)

    assert(a.add('good://localhost') is True)
    assert(len(a) == 1)

    # Bad Notification Type is still allowed as it is presumed the user
    # know's what their doing
    assert(a.notify(
        title=""my title"", body=""my body"", notify_type='bad') is True)

    # No Title/Body combo's
    assert(a.notify(title=None, body=None) is False)
    assert(a.notify(title='', body=None) is False)
    assert(a.notify(title=None, body='') is False)

    # As long as one is present, we're good
    assert(a.notify(title=None, body='present') is True)
    assert(a.notify(title='present', body=None) is True)
    assert(a.notify(title=""present"", body=""present"") is True)

    # Clear our server listings again
    a.clear()

    class ThrowNotification(NotifyBase):
        def notify(self, **kwargs):
            # Pretend everything is okay
            raise TypeError()

    class FailNotification(NotifyBase):

        def notify(self, **kwargs):
            # Pretend everything is okay
            return False

    # Store our bad notification in our schema map
    SCHEMA_MAP['throw'] = ThrowNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['fail'] = FailNotification

    assert(a.add('throw://localhost') is True)
    assert(a.add('fail://localhost') is True)
    assert(len(a) == 2)

    # Test when our notify both throws an exception and or just
    # simply returns False
    assert(a.notify(title=""present"", body=""present"") is False)


def test_apprise_asset():
    """"""
    API: AppriseAsset() object

    """"""
    a = AppriseAsset(
        theme='dark',
        image_path_mask='/{THEME}/{TYPE}-{XY}.png',
        image_url_mask='http://localhost/{THEME}/{TYPE}-{XY}.png',
    )

    a.default_html_color = '#abcabc'
    a.html_notify_map[NotifyType.INFO] = '#aaaaaa'

    assert(a.html_color('invalid') == '#abcabc')
    assert(a.html_color(NotifyType.INFO) == '#aaaaaa')

    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) ==
           'http://localhost/dark/info-256x256.png')

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=False) == '/dark/info-256x256.png')

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is None)

    # Create a new object (with our default settings)
    a = AppriseAsset()

    # Our default configuration can access our file
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)
","@@ -5,8 +5,188 @@
 from __future__ import print_function
 from __future__ import unicode_literals
 from apprise import Apprise
+from apprise import AppriseAsset
+from apprise.Apprise import SCHEMA_MAP
+from apprise.plugins.NotifyBase import NotifyBase
+from apprise import NotifyType
+from apprise import NotifyImageSize
 
 
-def test_initialization():
-    ""API: apprise() test initialization""""""
+def test_apprise():
+    """"""
+    API: Apprise() object
+
+    """"""
     a = Apprise()
+
+    # no items
+    assert(len(a) == 0)
+
+    # Create an Asset object
+    asset = AppriseAsset(theme='default')
+
+    # We can load the device using our asset
+    a = Apprise(asset=asset)
+
+    # We can load our servers up front as well
+    servers = [
+        'faast://abcdefghijklmnop-abcdefg',
+        'kodi://kodi.server.local',
+        'palot://1f418df7577e32b89ac6511f2eb9aa68',
+    ]
+
+    a = Apprise(servers=servers)
+
+    # 3 servers loaded
+    assert(len(a) == 3)
+
+    # We can add another server
+    assert(
+        a.add('mmosts://mattermost.server.local/'
+              '3ccdd113474722377935511fc85d3dd4') is True)
+    assert(len(a) == 4)
+
+    # We can empty our set
+    a.clear()
+    assert(len(a) == 0)
+
+    # An invalid schema
+    assert(
+        a.add('this is not a parseable url at all') is False)
+    assert(len(a) == 0)
+
+    # An unsupported schema
+    assert(
+        a.add('invalid://we.just.do.not.support.this.plugin.type') is False)
+    assert(len(a) == 0)
+
+    # A poorly formatted URL
+    assert(
+        a.add('json://user:@@@:bad?no.good') is False)
+    assert(len(a) == 0)
+
+    # Add a server with our asset we created earlier
+    assert(
+        a.add('mmosts://mattermost.server.local/'
+              '3ccdd113474722377935511fc85d3dd4', asset=asset) is True)
+
+    # Clear our server listings again
+    a.clear()
+
+    # No servers to notify
+    assert(a.notify(title=""my title"", body=""my body"") is False)
+
+    class BadNotification(NotifyBase):
+        def __init__(self, **kwargs):
+            super(BadNotification, self).__init__()
+
+            # We fail whenever we're initialized
+            raise TypeError()
+
+    class GoodNotification(NotifyBase):
+        def __init__(self, **kwargs):
+            super(GoodNotification, self).__init__()
+
+        def notify(self, **kwargs):
+            # Pretend everything is okay
+            return True
+
+    # Store our bad notification in our schema map
+    SCHEMA_MAP['bad'] = BadNotification
+
+    # Store our good notification in our schema map
+    SCHEMA_MAP['good'] = GoodNotification
+
+    # Just to explain what is happening here, we would have parsed the
+    # url properly but failed when we went to go and create an instance
+    # of it.
+    assert(a.add('bad://localhost') is False)
+    assert(len(a) == 0)
+
+    assert(a.add('good://localhost') is True)
+    assert(len(a) == 1)
+
+    # Bad Notification Type is still allowed as it is presumed the user
+    # know's what their doing
+    assert(a.notify(
+        title=""my title"", body=""my body"", notify_type='bad') is True)
+
+    # No Title/Body combo's
+    assert(a.notify(title=None, body=None) is False)
+    assert(a.notify(title='', body=None) is False)
+    assert(a.notify(title=None, body='') is False)
+
+    # As long as one is present, we're good
+    assert(a.notify(title=None, body='present') is True)
+    assert(a.notify(title='present', body=None) is True)
+    assert(a.notify(title=""present"", body=""present"") is True)
+
+    # Clear our server listings again
+    a.clear()
+
+    class ThrowNotification(NotifyBase):
+        def notify(self, **kwargs):
+            # Pretend everything is okay
+            raise TypeError()
+
+    class FailNotification(NotifyBase):
+
+        def notify(self, **kwargs):
+            # Pretend everything is okay
+            return False
+
+    # Store our bad notification in our schema map
+    SCHEMA_MAP['throw'] = ThrowNotification
+
+    # Store our good notification in our schema map
+    SCHEMA_MAP['fail'] = FailNotification
+
+    assert(a.add('throw://localhost') is True)
+    assert(a.add('fail://localhost') is True)
+    assert(len(a) == 2)
+
+    # Test when our notify both throws an exception and or just
+    # simply returns False
+    assert(a.notify(title=""present"", body=""present"") is False)
+
+
+def test_apprise_asset():
+    """"""
+    API: AppriseAsset() object
+
+    """"""
+    a = AppriseAsset(
+        theme='dark',
+        image_path_mask='/{THEME}/{TYPE}-{XY}.png',
+        image_url_mask='http://localhost/{THEME}/{TYPE}-{XY}.png',
+    )
+
+    a.default_html_color = '#abcabc'
+    a.html_notify_map[NotifyType.INFO] = '#aaaaaa'
+
+    assert(a.html_color('invalid') == '#abcabc')
+    assert(a.html_color(NotifyType.INFO) == '#aaaaaa')
+
+    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) ==
+           'http://localhost/dark/info-256x256.png')
+
+    assert(a.image_path(
+        NotifyType.INFO,
+        NotifyImageSize.XY_256,
+        must_exist=False) == '/dark/info-256x256.png')
+
+    assert(a.image_path(
+        NotifyType.INFO,
+        NotifyImageSize.XY_256,
+        must_exist=True) is None)
+
+    # Create a new object (with our default settings)
+    a = AppriseAsset()
+
+    # Our default configuration can access our file
+    assert(a.image_path(
+        NotifyType.INFO,
+        NotifyImageSize.XY_256,
+        must_exist=True) is not None)
+
+    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)
",add test for apprise.apprise,-37.34,36,180
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,Apprise.py,"# -*- coding: utf-8 -*-
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import re
import logging

from .common import NotifyType
from .utils import parse_list
from .utils import compat_is_basestring

from .AppriseAsset import AppriseAsset

from . import NotifyBase
from . import plugins

logger = logging.getLogger(__name__)

# Build a list of supported plugins
SCHEMA_MAP = {}

# Used for attempting to acquire the schema if the URL can't be parsed.
GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]{3,9})://.*$', re.I)


# Load our Lookup Matrix
def __load_matrix():
    """"""
    Dynamically load our schema map; this allows us to gracefully
    skip over plugins we simply don't have the dependecies for.

    """"""
    # to add it's mapping to our hash table
    for entry in dir(plugins):

        # Get our plugin
        plugin = getattr(plugins, entry)

        # Load protocol(s) if defined
        proto = getattr(plugin, 'protocol', None)
        if compat_is_basestring(proto):
            if proto not in SCHEMA_MAP:
                SCHEMA_MAP[proto] = plugin

        elif isinstance(proto, (set, list, tuple)):
            # Support iterables list types
            for p in proto:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin

        # Load secure protocol(s) if defined
        protos = getattr(plugin, 'secure_protocol', None)
        if compat_is_basestring(protos):
            if protos not in SCHEMA_MAP:
                SCHEMA_MAP[protos] = plugin

        if isinstance(protos, (set, list, tuple)):
            # Support iterables list types
            for p in protos:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin


# Dynamically build our module
__load_matrix()


class Apprise(object):
    """"""
    Our Notification Manager

    """"""
    def __init__(self, servers=None, asset=None):
        """"""
        Loads a set of server urls while applying the Asset() module to each
        if specified.

        If no asset is provided, then the default asset is used.

        """"""

        # Initialize a server list of URLs
        self.servers = list()

        # Assigns an central asset object that will be later passed into each
        # notification plugin.  Assets contain information such as the local
        # directory images can be found in. It can also identify remote
        # URL paths that contain the images you want to present to the end
        # user. If no asset is specified, then the default one is used.
        self.asset = asset
        if asset is None:
            # Load our default configuration
            self.asset = AppriseAsset()

        if servers:
            self.add(servers)

    @staticmethod
    def instantiate(url, asset=None, suppress_exceptions=True):
        """"""
        Returns the instance of a instantiated plugin based on the provided
        Server URL.  If the url fails to be parsed, then None is returned.

        """"""
        # swap hash (#) tag values with their html version
        # This is useful for accepting channels (as arguments to pushbullet)
        _url = url.replace('/#', '/%23')

        # Attempt to acquire the schema at the very least to allow our plugins
        # to determine if they can make a better interpretation of a URL
        # geared for them anyway.
        schema = GET_SCHEMA_RE.match(_url)
        if schema is None:
            logger.error('%s is an unparseable server url.' % url)
            return None

        # Update the schema
        schema = schema.group('schema').lower()

        # Some basic validation
        if schema not in SCHEMA_MAP:
            logger.error(
                '{0} is not a supported server type (url={1}).'.format(
                    schema,
                    _url,
                )
            )
            return None

        # Parse our url details
        # the server object is a dictionary containing all of the information
        # parsed from our URL
        results = SCHEMA_MAP[schema].parse_url(_url)

        if not results:
            # Failed to parse the server URL
            logger.error('Could not parse URL: %s' % url)
            return None

        if suppress_exceptions:
            try:
                # Attempt to create an instance of our plugin using the parsed
                # URL information
                plugin = SCHEMA_MAP[results['schema']](**results)

            except:
                # the arguments are invalid or can not be used.
                logger.error('Could not load URL: %s' % url)
                return None

        else:
            # Attempt to create an instance of our plugin using the parsed
            # URL information but don't wrap it in a try catch
            plugin = SCHEMA_MAP[results['schema']](**results)

        # Save our asset
        if asset:
            plugin.asset = asset

        return plugin

    def add(self, servers, asset=None):
        """"""
        Adds one or more server URLs into our list.

        """"""

        # Initialize our return status
        return_status = True

        if asset is None:
            # prepare default asset
            asset = self.asset

        if isinstance(servers, NotifyBase):
            # Go ahead and just add our plugin into our list
            self.servers.append(servers)
            return True

        servers = parse_list(servers)
        for _server in servers:

            # Instantiate ourselves an object, this function throws or
            # returns None if it fails
            instance = Apprise.instantiate(_server, asset=asset)
            if not instance:
                return_status = False
                continue

            # Add our initialized plugin to our server listings
            self.servers.append(instance)

        # Return our status
        return return_status

    def clear(self):
        """"""
        Empties our server list

        """"""
        self.servers[:] = []

    def notify(self, title, body, notify_type=NotifyType.INFO):
        """"""
        Send a notification to all of the plugins previously loaded
        """"""

        # Initialize our return result
        status = len(self.servers) > 0

        if not (title or body):
            return False

        # Iterate over our loaded plugins
        for server in self.servers:
            try:
                # Send notification
                if not server.notify(
                        title=title, body=body, notify_type=notify_type):

                    # Toggle our return status flag
                    status = False

            except:
                # A catch all so we don't have to abort early
                # just because one of our plugins has a bug in it.
                # TODO: print backtrace
                status = False

        return status

    def __len__(self):
        """"""
        Returns the number of servers loaded
        """"""
        return len(self.servers)
","# -*- coding: utf-8 -*-
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import re
import logging

from .common import NotifyType
from .utils import parse_list
from .utils import compat_is_basestring

from .AppriseAsset import AppriseAsset

from . import NotifyBase
from . import plugins

logger = logging.getLogger(__name__)

# Build a list of supported plugins
SCHEMA_MAP = {}

# Used for attempting to acquire the schema if the URL can't be parsed.
GET_SCHEMA_RE = re.compile('\s*(?P<schema>[a-z0-9]{3,9})://.*$', re.I)


# Load our Lookup Matrix
def __load_matrix():
    """"""
    Dynamically load our schema map; this allows us to gracefully
    skip over plugins we simply don't have the dependecies for.

    """"""
    # to add it's mapping to our hash table
    for entry in dir(plugins):

        # Get our plugin
        plugin = getattr(plugins, entry)

        # Load protocol(s) if defined
        proto = getattr(plugin, 'protocol', None)
        if compat_is_basestring(proto):
            if proto not in SCHEMA_MAP:
                SCHEMA_MAP[proto] = plugin

        elif isinstance(proto, (set, list, tuple)):
            # Support iterables list types
            for p in proto:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin

        # Load secure protocol(s) if defined
        protos = getattr(plugin, 'secure_protocol', None)
        if compat_is_basestring(protos):
            if protos not in SCHEMA_MAP:
                SCHEMA_MAP[protos] = plugin

        if isinstance(protos, (set, list, tuple)):
            # Support iterables list types
            for p in protos:
                if p not in SCHEMA_MAP:
                    SCHEMA_MAP[p] = plugin


# Dynamically build our module
__load_matrix()


class Apprise(object):
    """"""
    Our Notification Manager

    """"""
    def __init__(self, servers=None, asset=None):
        """"""
        Loads a set of server urls while applying the Asset() module to each
        if specified.

        If no asset is provided, then the default asset is used.

        """"""

        # Initialize a server list of URLs
        self.servers = list()

        # Assigns an central asset object that will be later passed into each
        # notification plugin.  Assets contain information such as the local
        # directory images can be found in. It can also identify remote
        # URL paths that contain the images you want to present to the end
        # user. If no asset is specified, then the default one is used.
        self.asset = asset
        if asset is None:
            # Load our default configuration
            self.asset = AppriseAsset()

        if servers:
            self.add(servers)

    @staticmethod
    def instantiate(url, asset=None, suppress_exceptions=True):
        """"""
        Returns the instance of a instantiated plugin based on the provided
        Server URL.  If the url fails to be parsed, then None is returned.

        """"""
        # swap hash (#) tag values with their html version
        # This is useful for accepting channels (as arguments to pushbullet)
        _url = url.replace('/#', '/%23')

        # Attempt to acquire the schema at the very least to allow our plugins
        # to determine if they can make a better interpretation of a URL
        # geared for them anyway.
        schema = GET_SCHEMA_RE.match(_url)
        if schema is None:
            logger.error('%s is an unparseable server url.' % url)
            return None

        # Update the schema
        schema = schema.group('schema').lower()

        # Some basic validation
        if schema not in SCHEMA_MAP:
            logger.error(
                '{0} is not a supported server type (url={1}).'.format(
                    schema,
                    _url,
                )
            )
            return None

        # Parse our url details
        # the server object is a dictionary containing all of the information
        # parsed from our URL
        results = SCHEMA_MAP[schema].parse_url(_url)

        if not results:
            # Failed to parse the server URL
            logger.error('Could not parse URL: %s' % url)
            return None

        if suppress_exceptions:
            try:
                # Attempt to create an instance of our plugin using the parsed
                # URL information
                plugin = SCHEMA_MAP[results['schema']](**results)

            except:
                # the arguments are invalid or can not be used.
                logger.error('Could not load URL: %s' % url)
                return None

        else:
            # Attempt to create an instance of our plugin using the parsed
            # URL information but don't wrap it in a try catch
            plugin = SCHEMA_MAP[results['schema']](**results)

        # Save our asset
        if asset:
            plugin.asset = asset

        return plugin

    def add(self, servers, asset=None):
        """"""
        Adds one or more server URLs into our list.

        """"""

        # Initialize our return status
        return_status = True

        if asset is None:
            # prepare default asset
            asset = self.asset

        if isinstance(servers, NotifyBase):
            # Go ahead and just add our plugin into our list
            self.servers.append(servers)
            return True

        servers = parse_list(servers)
        for _server in servers:

            # Instantiate ourselves an object, this function throws or
            # returns None if it fails
            instance = Apprise.instantiate(_server, asset=asset)
            if not instance:
                return_status = False
                continue

            # Add our initialized plugin to our server listings
            self.servers.append(instance)

        # Return our status
        return return_status

    def clear(self):
        """"""
        Empties our server list

        """"""
        self.servers[:] = []

    def notify(self, title, body, notify_type=NotifyType.INFO):
        """"""
        Send a notification to all of the plugins previously loaded
        """"""

        # Initialize our return result
        status = len(self.servers) > 0

        if not (title or body):
            return False

        # Iterate over our loaded plugins
        for server in self.servers:
            try:
                # Send notification
                if not server.notify(
                        title=title, body=body, notify_type=notify_type):

                    # Toggle our return status flag
                    status = False

            except Exception:
                # A catch all so we don't have to abort early
                # just because one of our plugins has a bug in it.
                logging.exception(""notification exception"")
                status = False

        return status

    def __len__(self):
        """"""
        Returns the number of servers loaded
        """"""
        return len(self.servers)
","@@ -238,10 +238,10 @@ class Apprise(object):
                     # Toggle our return status flag
                     status = False
 
-            except:
+            except Exception:
                 # A catch all so we don't have to abort early
                 # just because one of our plugins has a bug in it.
-                # TODO: print backtrace
+                logging.exception(""notification exception"")
                 status = False
 
         return status
",fix notification exception,0.16,0,0
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,AppriseAsset.py,"# -*- coding: utf-8 -*-
#
# Apprise Asset
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import join
from os.path import dirname
from os.path import isfile
from os.path import abspath
from .common import NotifyType


class AppriseAsset(object):
    """"""
    Provides a supplimentary class that can be used to provide extra
    information and details that can be used by Apprise such as providing
    an alternate location to where images/icons can be found and the
    URL masks.

    """"""
    # A Simple Mapping of Colors; For every NOTIFY_TYPE identified,
    # there should be a mapping to it's color here:
    html_notify_map = {
        NotifyType.INFO: '#3AA3E3',
        NotifyType.SUCCESS: '#3AA337',
        NotifyType.FAILURE: '#A32037',
        NotifyType.WARNING: '#CACF29',
    }

    # The default color to return if a mapping isn't found in our table above
    default_html_color = '#888888'

    # The default theme
    theme = 'default'

    # Image URL Mask
    image_url_mask = \
        'http://nuxref.com/apprise/themes/{THEME}/apprise-{TYPE}-{XY}.png'

    # Image Path Mask
    image_path_mask = abspath(join(
        dirname(__file__),
        'assets',
        'themes',
        '{THEME}',
        'apprise-{TYPE}-{XY}.png',
    ))

    def __init__(self, theme='default', image_path_mask=None,
                 image_url_mask=None):
        """"""
        Asset Initialization

        """"""
        if theme:
            self.theme = theme

        if image_path_mask:
            self.image_path_mask = image_path_mask

        if image_url_mask:
            self.image_url_mask = image_url_mask

    def html_color(self, notify_type):
        """"""
        Returns an HTML mapped color based on passed in notify type
        """"""
        # Attempt to get the type, otherwise return a default grey
        # if we couldn't look up the entry
        return self.html_notify_map.get(notify_type, self.default_html_color)

    def image_url(self, notify_type, image_size):
        """"""
        Apply our mask to our image URL

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        return re_table.sub(lambda x: re_map[x.group()], self.image_url_mask)

    def image_path(self, notify_type, image_size, must_exist=True):
        """"""
        Apply our mask to our image file path

        """"""
        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        # Acquire our path
        path = re_table.sub(lambda x: re_map[x.group()], self.image_path_mask)
        if must_exist and not isfile(path):
            return None

        # Return what we parsed
        return path

    def image_raw(self, notify_type, image_size):
        """"""
        Returns the raw image if it can (otherwise the function returns None)

        """"""

        path = self.image_path(notify_type=notify_type, image_size=image_size)
        if path:
            try:
                with open(path, 'rb') as fd:
                    return fd.read()

            except (OSError, IOError):
                # We can't access the file
                return None

        return None
","# -*- coding: utf-8 -*-
#
# Apprise Asset
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import join
from os.path import dirname
from os.path import isfile
from os.path import abspath
from .common import NotifyType


class AppriseAsset(object):
    """"""
    Provides a supplimentary class that can be used to provide extra
    information and details that can be used by Apprise such as providing
    an alternate location to where images/icons can be found and the
    URL masks.

    """"""
    # A Simple Mapping of Colors; For every NOTIFY_TYPE identified,
    # there should be a mapping to it's color here:
    html_notify_map = {
        NotifyType.INFO: '#3AA3E3',
        NotifyType.SUCCESS: '#3AA337',
        NotifyType.FAILURE: '#A32037',
        NotifyType.WARNING: '#CACF29',
    }

    # The default color to return if a mapping isn't found in our table above
    default_html_color = '#888888'

    # The default theme
    theme = 'default'

    # Image URL Mask
    image_url_mask = \
        'http://nuxref.com/apprise/themes/{THEME}/apprise-{TYPE}-{XY}.png'

    # Image Path Mask
    image_path_mask = abspath(join(
        dirname(__file__),
        'assets',
        'themes',
        '{THEME}',
        'apprise-{TYPE}-{XY}.png',
    ))

    def __init__(self, theme='default', image_path_mask=None,
                 image_url_mask=None):
        """"""
        Asset Initialization

        """"""
        if theme:
            self.theme = theme

        if image_path_mask is not None:
            self.image_path_mask = image_path_mask

        if image_url_mask is not None:
            self.image_url_mask = image_url_mask

    def html_color(self, notify_type):
        """"""
        Returns an HTML mapped color based on passed in notify type
        """"""
        # Attempt to get the type, otherwise return a default grey
        # if we couldn't look up the entry
        return self.html_notify_map.get(notify_type, self.default_html_color)

    def image_url(self, notify_type, image_size):
        """"""
        Apply our mask to our image URL

        """"""
        if not self.image_url_mask:
            # No image to return
            return None

        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        return re_table.sub(lambda x: re_map[x.group()], self.image_url_mask)

    def image_path(self, notify_type, image_size, must_exist=True):
        """"""
        Apply our mask to our image file path

        """"""

        if not self.image_path_mask:
            # No image to return
            return None

        re_map = {
            '{THEME}': self.theme if self.theme else '',
            '{TYPE}': notify_type,
            '{XY}': image_size,
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        # Acquire our path
        path = re_table.sub(lambda x: re_map[x.group()], self.image_path_mask)
        if must_exist and not isfile(path):
            return None

        # Return what we parsed
        return path

    def image_raw(self, notify_type, image_size):
        """"""
        Returns the raw image if it can (otherwise the function returns None)

        """"""

        path = self.image_path(notify_type=notify_type, image_size=image_size)
        if path:
            try:
                with open(path, 'rb') as fd:
                    return fd.read()

            except (OSError, IOError):
                # We can't access the file
                return None

        return None
","@@ -70,10 +70,10 @@ class AppriseAsset(object):
         if theme:
             self.theme = theme
 
-        if image_path_mask:
+        if image_path_mask is not None:
             self.image_path_mask = image_path_mask
 
-        if image_url_mask:
+        if image_url_mask is not None:
             self.image_url_mask = image_url_mask
 
     def html_color(self, notify_type):
@@ -89,6 +89,10 @@ class AppriseAsset(object):
         Apply our mask to our image URL
 
         """"""
+        if not self.image_url_mask:
+            # No image to return
+            return None
+
         re_map = {
             '{THEME}': self.theme if self.theme else '',
             '{TYPE}': notify_type,
@@ -108,6 +112,11 @@ class AppriseAsset(object):
         Apply our mask to our image file path
 
         """"""
+
+        if not self.image_path_mask:
+            # No image to return
+            return None
+
         re_map = {
             '{THEME}': self.theme if self.theme else '',
             '{TYPE}': notify_type,
",add missing comments,-2.66,2,9
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyBase.py,"# -*- coding: utf-8 -*-
#
# Base Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import logging
from time import sleep
try:
    # Python 2.7
    from urllib import unquote as _unquote
    from urllib import quote as _quote
    from urllib import urlencode as _urlencode

except ImportError:
    # Python 3.x
    from urllib.parse import unquote as _unquote
    from urllib.parse import quote as _quote
    from urllib.parse import urlencode as _urlencode

from ..utils import parse_url
from ..utils import parse_bool
from ..utils import is_hostname
from ..common import NOTIFY_IMAGE_SIZES
from ..common import NOTIFY_TYPES

from ..AppriseAsset import AppriseAsset

# use sax first because it's faster
from xml.sax.saxutils import escape as sax_escape


def _escape(text):
    """"""
    saxutil escape tool
    """"""
    return sax_escape(text, {""'"": ""&apos;"", ""\"""": ""&quot;""})


HTTP_ERROR_MAP = {
    400: 'Bad Request - Unsupported Parameters.',
    401: 'Verification Failed.',
    404: 'Page not found.',
    405: 'Method not allowed.',
    500: 'Internal server error.',
    503: 'Servers are overloaded.',
}

# HTML New Line Delimiter
NOTIFY_NEWLINE = '\n'

# Used to break a path list into parts
PATHSPLIT_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyFormat(object):
    TEXT = 'text'
    HTML = 'html'
    MARKDOWN = 'markdown'


NOTIFY_FORMATS = (
    NotifyFormat.TEXT,
    NotifyFormat.HTML,
    NotifyFormat.MARKDOWN,
)

# Regular expression retrieved from:
# http://www.regular-expressions.info/email.html
IS_EMAIL_RE = re.compile(
    r""(?P<userid>[a-z0-9$%+=_~-]+""
    r""(?:\.[a-z0-9$%+=_~-]+)""
    r""*)@(?P<domain>(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+""
    r""[a-z0-9](?:[a-z0-9-]*""
    r""[a-z0-9]))?"",
    re.IGNORECASE,
)


class NotifyBase(object):
    """"""
    This is the base class for all notification services
    """"""

    # The default simple (insecure) protocol
    # all inheriting entries must provide their protocol lookup
    # protocol:// (in this example they would specify 'protocol')
    protocol = ''

    # The default secure protocol
    # all inheriting entries must provide their protocol lookup
    # protocols:// (in this example they would specify 'protocols')
    # This value can be the same as the defined protocol.
    secure_protocol = ''

    # our Application identifier
    app_id = 'Apprise'

    # our Application description
    app_desc = 'Apprise Notifications'

    # Most Servers do not like more then 1 request per 5 seconds, so 5.5 gives
    # us a safe play range...
    throttle_attempt = 5.5

    # Logging
    logger = logging.getLogger(__name__)

    def __init__(self, title_maxlen=100, body_maxlen=512,
                 notify_format=NotifyFormat.TEXT, image_size=None,
                 include_image=False, secure=False, throttle=None, **kwargs):
        """"""
        Initialize some general logging and common server arguments that will
        keep things consistent when working with the notifiers that will
        inherit this class.

        """"""

        if notify_format.lower() not in NOTIFY_FORMATS:
            self.logger.error(
                'Invalid notification format %s' % notify_format,
            )
            raise TypeError(
                'Invalid notification format %s' % notify_format,
            )

        if image_size and image_size not in NOTIFY_IMAGE_SIZES:
            self.logger.error(
                'Invalid image size %s' % image_size,
            )
            raise TypeError(
                'Invalid image size %s' % image_size,
            )

        # Prepare our Assets
        self.asset = AppriseAsset()

        self.notify_format = notify_format.lower()
        self.title_maxlen = title_maxlen
        self.body_maxlen = body_maxlen
        self.image_size = image_size
        self.include_image = include_image
        self.secure = secure

        if isinstance(throttle, (float, int)):
            # Custom throttle override
            self.throttle_attempt = throttle

        # Certificate Verification (for SSL calls); default to being enabled
        self.verify_certificate = kwargs.get('verify', True)

        self.host = kwargs.get('host', '')
        self.port = kwargs.get('port')
        if self.port:
            try:
                self.port = int(self.port)

            except (TypeError, ValueError):
                self.port = None

        self.user = kwargs.get('user')
        self.password = kwargs.get('password')

    def throttle(self, throttle_time=None):
        """"""
        A common throttle control
        """"""
        self.logger.debug('Throttling...')

        throttle_time = throttle_time \
            if throttle_time is not None else self.throttle_attempt

        # Perform throttle
        if throttle_time > 0:
            sleep(throttle_time)

        return

    def image_url(self, notify_type):
        """"""
        Returns Image URL if possible
        """"""

        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_url(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    def image_path(self, notify_type):
        """"""
        Returns the path of the image if it can
        """"""
        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_path(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    def image_raw(self, notify_type):
        """"""
        Returns the raw image if it can
        """"""
        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_raw(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    @staticmethod
    def escape_html(html, convert_new_lines=False):
        """"""
        Takes html text as input and escapes it so that it won't
        conflict with any xml/html wrapping characters.
        """"""
        escaped = _escape(html).\
            replace(u'\t', u'&emsp;').\
            replace(u' ', u'&nbsp;')

        if convert_new_lines:
            return escaped.replace(u'\n', u'&lt;br/&gt;')

        return escaped

    @staticmethod
    def unquote(content, encoding='utf-8', errors='replace'):
        """"""
        common unquote function

        """"""
        try:
            # Python v3.x
            return _unquote(content, encoding=encoding, errors=errors)

        except TypeError:
            # Python v2.7
            return _unquote(content)

    @staticmethod
    def quote(content, safe='/', encoding=None, errors=None):
        """"""
        common quote function

        """"""
        try:
            # Python v3.x
            return _quote(content, safe=safe, encoding=encoding, errors=errors)

        except TypeError:
            # Python v2.7
            return _quote(content, safe=safe)

    @staticmethod
    def urlencode(query, doseq=False, safe='', encoding=None, errors=None):
        """"""
        common urlencode function

        """"""
        try:
            # Python v3.x
            return _urlencode(
                query, doseq=doseq, safe=safe, encoding=encoding,
                errors=errors)

        except TypeError:
            # Python v2.7
            return _urlencode(query, oseq=doseq)

    @staticmethod
    def split_path(path, unquote=True):
        """"""
        Splits a URL up into a list object.

        """"""
        if unquote:
            return PATHSPLIT_LIST_DELIM.split(
                NotifyBase.unquote(path).lstrip('/'))
        return PATHSPLIT_LIST_DELIM.split(path.lstrip('/'))

    @staticmethod
    def is_email(address):
        """"""
        Returns True if specified entry is an email address

        """"""
        return IS_EMAIL_RE.match(address) is not None

    @staticmethod
    def is_hostname(hostname):
        """"""
        Returns True if specified entry is a hostname

        """"""
        return is_hostname(hostname)

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = parse_url(url, default_schema='unknown')

        if not results:
            # We're done; we failed to parse our url
            return results

        # if our URL ends with an 's', then assueme our secure flag is set.
        results['secure'] = (results['schema'][-1] == 's')

        # Our default notification format
        results['notify_format'] = NotifyFormat.TEXT

        # Support SSL Certificate 'verify' keyword. Default to being enabled
        results['verify'] = True

        if 'verify' in results['qsd']:
            results['verify'] = parse_bool(
                results['qsd'].get('verify', True))

        # Password overrides
        if 'pass' in results['qsd']:
            results['password'] = results['qsd']['pass']

        # User overrides
        if 'user' in results['qsd']:
            results['user'] = results['qsd']['user']

        return results
","# -*- coding: utf-8 -*-
#
# Base Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import logging
from time import sleep
try:
    # Python 2.7
    from urllib import unquote as _unquote
    from urllib import quote as _quote
    from urllib import urlencode as _urlencode

except ImportError:
    # Python 3.x
    from urllib.parse import unquote as _unquote
    from urllib.parse import quote as _quote
    from urllib.parse import urlencode as _urlencode

from ..utils import parse_url
from ..utils import parse_bool
from ..utils import is_hostname
from ..common import NOTIFY_IMAGE_SIZES
from ..common import NOTIFY_TYPES

from ..AppriseAsset import AppriseAsset

# use sax first because it's faster
from xml.sax.saxutils import escape as sax_escape


def _escape(text):
    """"""
    saxutil escape tool
    """"""
    return sax_escape(text, {""'"": ""&apos;"", ""\"""": ""&quot;""})


HTTP_ERROR_MAP = {
    400: 'Bad Request - Unsupported Parameters.',
    401: 'Verification Failed.',
    404: 'Page not found.',
    405: 'Method not allowed.',
    500: 'Internal server error.',
    503: 'Servers are overloaded.',
}

# HTML New Line Delimiter
NOTIFY_NEWLINE = '\n'

# Used to break a path list into parts
PATHSPLIT_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyFormat(object):
    TEXT = 'text'
    HTML = 'html'
    MARKDOWN = 'markdown'


NOTIFY_FORMATS = (
    NotifyFormat.TEXT,
    NotifyFormat.HTML,
    NotifyFormat.MARKDOWN,
)

# Regular expression retrieved from:
# http://www.regular-expressions.info/email.html
IS_EMAIL_RE = re.compile(
    r""(?P<userid>[a-z0-9$%+=_~-]+""
    r""(?:\.[a-z0-9$%+=_~-]+)""
    r""*)@(?P<domain>(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+""
    r""[a-z0-9](?:[a-z0-9-]*""
    r""[a-z0-9]))?"",
    re.IGNORECASE,
)


class NotifyBase(object):
    """"""
    This is the base class for all notification services
    """"""

    # The default simple (insecure) protocol
    # all inheriting entries must provide their protocol lookup
    # protocol:// (in this example they would specify 'protocol')
    protocol = ''

    # The default secure protocol
    # all inheriting entries must provide their protocol lookup
    # protocols:// (in this example they would specify 'protocols')
    # This value can be the same as the defined protocol.
    secure_protocol = ''

    # our Application identifier
    app_id = 'Apprise'

    # our Application description
    app_desc = 'Apprise Notifications'

    # Most Servers do not like more then 1 request per 5 seconds, so 5.5 gives
    # us a safe play range...
    throttle_attempt = 5.5

    # Logging
    logger = logging.getLogger(__name__)

    def __init__(self, title_maxlen=100, body_maxlen=512,
                 notify_format=NotifyFormat.TEXT, image_size=None,
                 secure=False, throttle=None, **kwargs):
        """"""
        Initialize some general logging and common server arguments that will
        keep things consistent when working with the notifiers that will
        inherit this class.

        """"""

        if notify_format.lower() not in NOTIFY_FORMATS:
            self.logger.error(
                'Invalid notification format %s' % notify_format,
            )
            raise TypeError(
                'Invalid notification format %s' % notify_format,
            )

        if image_size and image_size not in NOTIFY_IMAGE_SIZES:
            self.logger.error(
                'Invalid image size %s' % image_size,
            )
            raise TypeError(
                'Invalid image size %s' % image_size,
            )

        # Prepare our Assets
        self.asset = AppriseAsset()

        self.notify_format = notify_format.lower()
        self.title_maxlen = title_maxlen
        self.body_maxlen = body_maxlen
        self.image_size = image_size
        self.secure = secure

        if isinstance(throttle, (float, int)):
            # Custom throttle override
            self.throttle_attempt = throttle

        # Certificate Verification (for SSL calls); default to being enabled
        self.verify_certificate = kwargs.get('verify', True)

        self.host = kwargs.get('host', '')
        self.port = kwargs.get('port')
        if self.port:
            try:
                self.port = int(self.port)

            except (TypeError, ValueError):
                self.port = None

        self.user = kwargs.get('user')
        self.password = kwargs.get('password')

    def throttle(self, throttle_time=None):
        """"""
        A common throttle control
        """"""
        self.logger.debug('Throttling...')

        throttle_time = throttle_time \
            if throttle_time is not None else self.throttle_attempt

        # Perform throttle
        if throttle_time > 0:
            sleep(throttle_time)

        return

    def image_url(self, notify_type):
        """"""
        Returns Image URL if possible
        """"""

        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_url(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    def image_path(self, notify_type):
        """"""
        Returns the path of the image if it can
        """"""
        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_path(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    def image_raw(self, notify_type):
        """"""
        Returns the raw image if it can
        """"""
        if not self.image_size:
            return None

        if notify_type not in NOTIFY_TYPES:
            return None

        return self.asset.image_raw(
            notify_type=notify_type,
            image_size=self.image_size,
        )

    @staticmethod
    def escape_html(html, convert_new_lines=False):
        """"""
        Takes html text as input and escapes it so that it won't
        conflict with any xml/html wrapping characters.
        """"""
        escaped = _escape(html).\
            replace(u'\t', u'&emsp;').\
            replace(u' ', u'&nbsp;')

        if convert_new_lines:
            return escaped.replace(u'\n', u'&lt;br/&gt;')

        return escaped

    @staticmethod
    def unquote(content, encoding='utf-8', errors='replace'):
        """"""
        common unquote function

        """"""
        if not content:
            return ''

        try:
            # Python v3.x
            return _unquote(content, encoding=encoding, errors=errors)

        except TypeError:
            # Python v2.7
            return _unquote(content)

    @staticmethod
    def quote(content, safe='/', encoding=None, errors=None):
        """"""
        common quote function

        """"""
        if not content:
            return ''

        try:
            # Python v3.x
            return _quote(content, safe=safe, encoding=encoding, errors=errors)

        except TypeError:
            # Python v2.7
            return _quote(content, safe=safe)

    @staticmethod
    def urlencode(query, doseq=False, safe='', encoding=None, errors=None):
        """"""
        common urlencode function

        """"""
        try:
            # Python v3.x
            return _urlencode(
                query, doseq=doseq, safe=safe, encoding=encoding,
                errors=errors)

        except TypeError:
            # Python v2.7
            return _urlencode(query)

    @staticmethod
    def split_path(path, unquote=True):
        """"""
        Splits a URL up into a list object.

        """"""
        if unquote:
            return PATHSPLIT_LIST_DELIM.split(
                NotifyBase.unquote(path).lstrip('/'))
        return PATHSPLIT_LIST_DELIM.split(path.lstrip('/'))

    @staticmethod
    def is_email(address):
        """"""
        Returns True if specified entry is an email address

        """"""
        return IS_EMAIL_RE.match(address) is not None

    @staticmethod
    def is_hostname(hostname):
        """"""
        Returns True if specified entry is a hostname

        """"""
        return is_hostname(hostname)

    @staticmethod
    def parse_url(url, verify_host=True):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = parse_url(
            url, default_schema='unknown', verify_host=verify_host)

        if not results:
            # We're done; we failed to parse our url
            return results

        # if our URL ends with an 's', then assueme our secure flag is set.
        results['secure'] = (results['schema'][-1] == 's')

        # Our default notification format
        results['notify_format'] = NotifyFormat.TEXT

        # Support SSL Certificate 'verify' keyword. Default to being enabled
        results['verify'] = True

        if 'verify' in results['qsd']:
            results['verify'] = parse_bool(
                results['qsd'].get('verify', True))

        # Password overrides
        if 'pass' in results['qsd']:
            results['password'] = results['qsd']['pass']

        # User overrides
        if 'user' in results['qsd']:
            results['user'] = results['qsd']['user']

        return results
","@@ -121,7 +121,7 @@ class NotifyBase(object):
 
     def __init__(self, title_maxlen=100, body_maxlen=512,
                  notify_format=NotifyFormat.TEXT, image_size=None,
-                 include_image=False, secure=False, throttle=None, **kwargs):
+                 secure=False, throttle=None, **kwargs):
         """"""
         Initialize some general logging and common server arguments that will
         keep things consistent when working with the notifiers that will
@@ -152,7 +152,6 @@ class NotifyBase(object):
         self.title_maxlen = title_maxlen
         self.body_maxlen = body_maxlen
         self.image_size = image_size
-        self.include_image = include_image
         self.secure = secure
 
         if isinstance(throttle, (float, int)):
@@ -256,6 +255,9 @@ class NotifyBase(object):
         common unquote function
 
         """"""
+        if not content:
+            return ''
+
         try:
             # Python v3.x
             return _unquote(content, encoding=encoding, errors=errors)
@@ -270,6 +272,9 @@ class NotifyBase(object):
         common quote function
 
         """"""
+        if not content:
+            return ''
+
         try:
             # Python v3.x
             return _quote(content, safe=safe, encoding=encoding, errors=errors)
@@ -292,7 +297,7 @@ class NotifyBase(object):
 
         except TypeError:
             # Python v2.7
-            return _urlencode(query, oseq=doseq)
+            return _urlencode(query)
 
     @staticmethod
     def split_path(path, unquote=True):
@@ -322,12 +327,13 @@ class NotifyBase(object):
         return is_hostname(hostname)
 
     @staticmethod
-    def parse_url(url):
+    def parse_url(url, verify_host=True):
         """"""
         Parses the URL and returns it broken apart into a dictionary.
 
         """"""
-        results = parse_url(url, default_schema='unknown')
+        results = parse_url(
+            url, default_schema='unknown', verify_host=verify_host)
 
         if not results:
             # We're done; we failed to parse our url
",add more comments to the notify class,-0.71,3,6
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyBoxcar.py,"# -*- coding: utf-8 -*-
#
# Boxcar Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from json import dumps
import requests
import re

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP

from ..utils import compat_is_basestring

# Used to validate Tags, Aliases and Devices
IS_TAG = re.compile(r'^[A-Za-z0-9]{1,63}$')
IS_ALIAS = re.compile(r'^[@]?[A-Za-z0-9]+$')
IS_DEVICETOKEN = re.compile(r'^[A-Za-z0-9]{64}$')

# Used to break apart list of potential tags by their delimiter
# into a usable list.
TAGS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyBoxcar(NotifyBase):
    """"""
    A wrapper for Boxcar Notifications
    """"""

    # The default simple (insecure) protocol
    protocol = 'boxcar'

    # The default secure protocol
    secure_protocol = 'boxcars'

    def __init__(self, recipients=None, **kwargs):
        """"""
        Initialize Boxcar Object
        """"""
        super(NotifyBoxcar, self).__init__(
            title_maxlen=250, body_maxlen=10000, **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Initialize tag list
        self.tags = list()

        # Initialize alias list
        self.aliases = list()

        # Initialize device_token list
        self.device_tokens = list()

        if recipients is None:
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = filter(bool, TAGS_LIST_DELIM.split(
                recipients,
            ))

        elif not isinstance(recipients, (set, tuple, list)):
            recipients = []

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            if IS_DEVICETOKEN.match(recipient):
                # store valid device
                self.device_tokens.append(recipient)

            elif IS_TAG.match(recipient):
                # store valid tag
                self.tags.append(recipient)

            elif IS_ALIAS.match(recipient):
                # store valid tag/alias
                self.aliases.append(recipient)

            else:
                self.logger.warning(
                    'Dropped invalid tag/alias/device_token '
                    '(%s) specified.' % recipient,
                )
                continue

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Boxcar Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare Boxcar Object
        payload = {
            'badge': 'auto',
            'alert': '%s:\r\n%s' % (title, body),
        }

        if self.tags:
            payload['tags'] = self.tags

        if self.aliases:
            payload['aliases'] = self.aliases

        if self.device_tokens:
            payload['device_tokens'] = self.device_tokens

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += '/api/push'

        self.logger.debug('Boxcar POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('Boxcar Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=dumps(payload),
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                try:
                    self.logger.warning(
                        'Failed to send Boxcar notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))
                except KeyError:
                    self.logger.warning(
                        'Failed to send Boxcar notification '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending Boxcar '
                'notification to %s.' % (
                    self.host))

            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early
            return None

        # Acquire our recipients and include them in the response
        try:
            recipients = NotifyBase.unquote(results['fullpath'])

        except (AttributeError, KeyError):
            # no recipients detected
            recipients = ''

        # Store our recipients
        results['recipients'] = recipients

        return results
","# -*- coding: utf-8 -*-
#
# Boxcar Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from json import dumps
import requests
import re
from time import time
import hmac
from hashlib import sha1
try:
    from urlparse import urlparse

except ImportError:
    from urllib.parse import urlparse

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP

from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Default to sending to all devices if nothing is specified
DEFAULT_TAG = '@all'

# The tags value is an structure containing an array of strings defining the
# list of tagged devices that the notification need to be send to, and a
# boolean operator (and / or) that defines the criteria to match devices
# against those tags.
IS_TAG = re.compile(r'^[@](?P<name>[A-Z0-9]{1,63})$', re.I)

# Device tokens are only referenced when developing.
# it's not likely you'll send a message directly to a device, but
# if you do; this plugin supports it.
IS_DEVICETOKEN = re.compile(r'^[A-Z0-9]{64}$', re.I)

# Both an access key and seret key are created and assigned to each project
# you create on the boxcar website
VALIDATE_ACCESS = re.compile(r'[A-Z0-9_-]{64}', re.I)
VALIDATE_SECRET = re.compile(r'[A-Z0-9_-]{64}', re.I)

# Used to break apart list of potential tags by their delimiter
# into a usable list.
TAGS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Image Support (72x72)
BOXCAR_IMAGE_XY = NotifyImageSize.XY_72


class NotifyBoxcar(NotifyBase):
    """"""
    A wrapper for Boxcar Notifications
    """"""

    # All boxcar notifications are secure
    secure_protocol = 'boxcar'

    # Boxcar URL
    notify_url = 'https://boxcar-api.io/api/push/'

    def __init__(self, access, secret, recipients=None, **kwargs):
        """"""
        Initialize Boxcar Object
        """"""
        super(NotifyBoxcar, self).__init__(
            title_maxlen=250, body_maxlen=10000,
            image_size=BOXCAR_IMAGE_XY, **kwargs)

        # Initialize tag list
        self.tags = list()

        # Initialize device_token list
        self.device_tokens = list()

        try:
            # Access Key (associated with project)
            self.access = access.strip()

        except AttributeError:
            self.logger.warning(
                'The specified access key specified is invalid.',
            )
            raise TypeError(
                'The specified access key specified is invalid.',
            )

        try:
            # Secret Key (associated with project)
            self.secret = secret.strip()

        except AttributeError:
            self.logger.warning(
                'The specified secret key specified is invalid.',
            )
            raise TypeError(
                'The specified secret key specified is invalid.',
            )

        if not VALIDATE_ACCESS.match(self.access):
            self.logger.warning(
                'The access key specified (%s) is invalid.' % self.access,
            )
            raise TypeError(
                'The access key specified (%s) is invalid.' % self.access,
            )

        if not VALIDATE_SECRET.match(self.secret):
            self.logger.warning(
                'The secret key specified (%s) is invalid.' % self.secret,
            )
            raise TypeError(
                'The secret key specified (%s) is invalid.' % self.secret,
            )

        if not recipients:
            self.tags.append(DEFAULT_TAG)
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = [x for x in filter(bool, TAGS_LIST_DELIM.split(
                recipients,
            ))]

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            if IS_TAG.match(recipient):
                # store valid tag/alias
                self.tags.append(IS_TAG.match(recipient).group('name'))

            elif IS_DEVICETOKEN.match(recipient):
                # store valid device
                self.device_tokens.append(recipient)

            else:
                self.logger.warning(
                    'Dropped invalid tag/alias/device_token '
                    '(%s) specified.' % recipient,
                )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Boxcar Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare Boxcar Object
        payload = {
            'aps': {
                'badge': 'auto',
                'alert': '',
            },
            'expires': str(int(time() + 30)),
        }

        if title:
            payload['aps']['@title'] = title

        if body:
            payload['aps']['alert'] = body

        if self.tags:
            payload['tags'] = {'or': self.tags}

        if self.device_tokens:
            payload['device_tokens'] = self.device_tokens

        # Source picture should be <= 450 DP wide, ~2:1 aspect.
        image_url = self.image_url(notify_type)
        if image_url:
            # Set our image
            payload['@img'] = image_url

        # Acquire our hostname
        host = urlparse(self.notify_url).hostname

        # Calculate signature.
        str_to_sign = ""%s\n%s\n%s\n%s"" % (
            ""POST"", host, ""/api/push"", dumps(payload))

        h = hmac.new(
            bytearray(self.secret, 'utf-8'),
            bytearray(str_to_sign, 'utf-8'),
            sha1,
        )

        params = self.urlencode({
            ""publishkey"": self.access,
            ""signature"": h.hexdigest(),
        })

        notify_url = '%s?%s' % (self.notify_url, params)
        self.logger.debug('Boxcar POST URL: %s (cert_verify=%r)' % (
            notify_url, self.verify_certificate,
        ))
        self.logger.debug('Boxcar Payload: %s' % str(payload))

        try:
            r = requests.post(
                notify_url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )

            # Boxcar returns 201 (Created) when successful
            if r.status_code != requests.codes.created:
                try:
                    self.logger.warning(
                        'Failed to send Boxcar notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send Boxcar notification '
                        '(error=%s).' % (
                            r.status_code))

                # self.logger.debug('Response Details: %s' % r.raw.read())

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending Boxcar '
                'notification to %s.' % (host))

            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = NotifyBase.parse_url(url, verify_host=False)

        if not results:
            # We're done early
            return None

        # The first token is stored in the hostnamee
        access = results['host']

        # Now fetch the remaining tokens
        try:
            secret = NotifyBase.split_path(results['fullpath'])[0]

        except (AttributeError, IndexError):
            # Force a bad value that will get caught in parsing later
            secret = None

        try:
            recipients = ','.join(
                NotifyBase.split_path(results['fullpath'])[1:])

        except (AttributeError, IndexError):
            # Default to not having any recipients
            recipients = None

        if not (access and secret):
            # If we did not recive an access and/or secret code
            # then we're done
            return None

        # Store our required content
        results['recipients'] = recipients if recipients else None
        results['access'] = access
        results['secret'] = secret

        return results
","@@ -19,86 +19,137 @@
 from json import dumps
 import requests
 import re
+from time import time
+import hmac
+from hashlib import sha1
+try:
+    from urlparse import urlparse
+
+except ImportError:
+    from urllib.parse import urlparse
 
 from .NotifyBase import NotifyBase
 from .NotifyBase import HTTP_ERROR_MAP
 
+from ..common import NotifyImageSize
 from ..utils import compat_is_basestring
 
-# Used to validate Tags, Aliases and Devices
-IS_TAG = re.compile(r'^[A-Za-z0-9]{1,63}$')
-IS_ALIAS = re.compile(r'^[@]?[A-Za-z0-9]+$')
-IS_DEVICETOKEN = re.compile(r'^[A-Za-z0-9]{64}$')
+# Default to sending to all devices if nothing is specified
+DEFAULT_TAG = '@all'
+
+# The tags value is an structure containing an array of strings defining the
+# list of tagged devices that the notification need to be send to, and a
+# boolean operator (and / or) that defines the criteria to match devices
+# against those tags.
+IS_TAG = re.compile(r'^[@](?P<name>[A-Z0-9]{1,63})$', re.I)
+
+# Device tokens are only referenced when developing.
+# it's not likely you'll send a message directly to a device, but
+# if you do; this plugin supports it.
+IS_DEVICETOKEN = re.compile(r'^[A-Z0-9]{64}$', re.I)
+
+# Both an access key and seret key are created and assigned to each project
+# you create on the boxcar website
+VALIDATE_ACCESS = re.compile(r'[A-Z0-9_-]{64}', re.I)
+VALIDATE_SECRET = re.compile(r'[A-Z0-9_-]{64}', re.I)
 
 # Used to break apart list of potential tags by their delimiter
 # into a usable list.
 TAGS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')
 
+# Image Support (72x72)
+BOXCAR_IMAGE_XY = NotifyImageSize.XY_72
+
 
 class NotifyBoxcar(NotifyBase):
     """"""
     A wrapper for Boxcar Notifications
     """"""
 
-    # The default simple (insecure) protocol
-    protocol = 'boxcar'
+    # All boxcar notifications are secure
+    secure_protocol = 'boxcar'
 
-    # The default secure protocol
-    secure_protocol = 'boxcars'
+    # Boxcar URL
+    notify_url = 'https://boxcar-api.io/api/push/'
 
-    def __init__(self, recipients=None, **kwargs):
+    def __init__(self, access, secret, recipients=None, **kwargs):
         """"""
         Initialize Boxcar Object
         """"""
         super(NotifyBoxcar, self).__init__(
-            title_maxlen=250, body_maxlen=10000, **kwargs)
-
-        if self.secure:
-            self.schema = 'https'
-
-        else:
-            self.schema = 'http'
+            title_maxlen=250, body_maxlen=10000,
+            image_size=BOXCAR_IMAGE_XY, **kwargs)
 
         # Initialize tag list
         self.tags = list()
 
-        # Initialize alias list
-        self.aliases = list()
-
         # Initialize device_token list
         self.device_tokens = list()
 
-        if recipients is None:
+        try:
+            # Access Key (associated with project)
+            self.access = access.strip()
+
+        except AttributeError:
+            self.logger.warning(
+                'The specified access key specified is invalid.',
+            )
+            raise TypeError(
+                'The specified access key specified is invalid.',
+            )
+
+        try:
+            # Secret Key (associated with project)
+            self.secret = secret.strip()
+
+        except AttributeError:
+            self.logger.warning(
+                'The specified secret key specified is invalid.',
+            )
+            raise TypeError(
+                'The specified secret key specified is invalid.',
+            )
+
+        if not VALIDATE_ACCESS.match(self.access):
+            self.logger.warning(
+                'The access key specified (%s) is invalid.' % self.access,
+            )
+            raise TypeError(
+                'The access key specified (%s) is invalid.' % self.access,
+            )
+
+        if not VALIDATE_SECRET.match(self.secret):
+            self.logger.warning(
+                'The secret key specified (%s) is invalid.' % self.secret,
+            )
+            raise TypeError(
+                'The secret key specified (%s) is invalid.' % self.secret,
+            )
+
+        if not recipients:
+            self.tags.append(DEFAULT_TAG)
             recipients = []
 
         elif compat_is_basestring(recipients):
-            recipients = filter(bool, TAGS_LIST_DELIM.split(
+            recipients = [x for x in filter(bool, TAGS_LIST_DELIM.split(
                 recipients,
-            ))
-
-        elif not isinstance(recipients, (set, tuple, list)):
-            recipients = []
+            ))]
 
         # Validate recipients and drop bad ones:
         for recipient in recipients:
-            if IS_DEVICETOKEN.match(recipient):
+            if IS_TAG.match(recipient):
+                # store valid tag/alias
+                self.tags.append(IS_TAG.match(recipient).group('name'))
+
+            elif IS_DEVICETOKEN.match(recipient):
                 # store valid device
                 self.device_tokens.append(recipient)
 
-            elif IS_TAG.match(recipient):
-                # store valid tag
-                self.tags.append(recipient)
-
-            elif IS_ALIAS.match(recipient):
-                # store valid tag/alias
-                self.aliases.append(recipient)
-
             else:
                 self.logger.warning(
                     'Dropped invalid tag/alias/device_token '
                     '(%s) specified.' % recipient,
                 )
-                continue
 
     def notify(self, title, body, notify_type, **kwargs):
         """"""
@@ -112,62 +163,87 @@ class NotifyBoxcar(NotifyBase):
 
         # prepare Boxcar Object
         payload = {
-            'badge': 'auto',
-            'alert': '%s:\r\n%s' % (title, body),
+            'aps': {
+                'badge': 'auto',
+                'alert': '',
+            },
+            'expires': str(int(time() + 30)),
         }
 
-        if self.tags:
-            payload['tags'] = self.tags
+        if title:
+            payload['aps']['@title'] = title
+
+        if body:
+            payload['aps']['alert'] = body
 
-        if self.aliases:
-            payload['aliases'] = self.aliases
+        if self.tags:
+            payload['tags'] = {'or': self.tags}
 
         if self.device_tokens:
             payload['device_tokens'] = self.device_tokens
 
-        auth = None
-        if self.user:
-            auth = (self.user, self.password)
+        # Source picture should be <= 450 DP wide, ~2:1 aspect.
+        image_url = self.image_url(notify_type)
+        if image_url:
+            # Set our image
+            payload['@img'] = image_url
 
-        url = '%s://%s' % (self.schema, self.host)
-        if isinstance(self.port, int):
-            url += ':%d' % self.port
+        # Acquire our hostname
+        host = urlparse(self.notify_url).hostname
 
-        url += '/api/push'
+        # Calculate signature.
+        str_to_sign = ""%s\n%s\n%s\n%s"" % (
+            ""POST"", host, ""/api/push"", dumps(payload))
 
+        h = hmac.new(
+            bytearray(self.secret, 'utf-8'),
+            bytearray(str_to_sign, 'utf-8'),
+            sha1,
+        )
+
+        params = self.urlencode({
+            ""publishkey"": self.access,
+            ""signature"": h.hexdigest(),
+        })
+
+        notify_url = '%s?%s' % (self.notify_url, params)
         self.logger.debug('Boxcar POST URL: %s (cert_verify=%r)' % (
-            url, self.verify_certificate,
+            notify_url, self.verify_certificate,
         ))
         self.logger.debug('Boxcar Payload: %s' % str(payload))
+
         try:
             r = requests.post(
-                url,
+                notify_url,
                 data=dumps(payload),
                 headers=headers,
-                auth=auth,
                 verify=self.verify_certificate,
             )
-            if r.status_code != requests.codes.ok:
+
+            # Boxcar returns 201 (Created) when successful
+            if r.status_code != requests.codes.created:
                 try:
                     self.logger.warning(
                         'Failed to send Boxcar notification: '
                         '%s (error=%s).' % (
                             HTTP_ERROR_MAP[r.status_code],
                             r.status_code))
+
                 except KeyError:
                     self.logger.warning(
                         'Failed to send Boxcar notification '
                         '(error=%s).' % (
                             r.status_code))
 
+                # self.logger.debug('Response Details: %s' % r.raw.read())
+
                 # Return; we're done
                 return False
 
-        except requests.ConnectionError as e:
+        except requests.RequestException as e:
             self.logger.warning(
                 'A Connection error occured sending Boxcar '
-                'notification to %s.' % (
-                    self.host))
+                'notification to %s.' % (host))
 
             self.logger.debug('Socket Exception: %s' % str(e))
 
@@ -182,21 +258,39 @@ class NotifyBoxcar(NotifyBase):
         Parses the URL and returns it broken apart into a dictionary.
 
         """"""
-        results = NotifyBase.parse_url(url)
+        results = NotifyBase.parse_url(url, verify_host=False)
 
         if not results:
             # We're done early
             return None
 
-        # Acquire our recipients and include them in the response
+        # The first token is stored in the hostnamee
+        access = results['host']
+
+        # Now fetch the remaining tokens
+        try:
+            secret = NotifyBase.split_path(results['fullpath'])[0]
+
+        except (AttributeError, IndexError):
+            # Force a bad value that will get caught in parsing later
+            secret = None
+
         try:
-            recipients = NotifyBase.unquote(results['fullpath'])
+            recipients = ','.join(
+                NotifyBase.split_path(results['fullpath'])[1:])
+
+        except (AttributeError, IndexError):
+            # Default to not having any recipients
+            recipients = None
 
-        except (AttributeError, KeyError):
-            # no recipients detected
-            recipients = ''
+        if not (access and secret):
+            # If we did not recive an access and/or secret code
+            # then we're done
+            return None
 
-        # Store our recipients
-        results['recipients'] = recipients
+        # Store our required content
+        results['recipients'] = recipients if recipients else None
+        results['access'] = access
+        results['secret'] = secret
 
         return results
",add devices to notify,-5.12,8,94
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyEmail.py,"# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from .NotifyBase import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, to, notify_format, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            notify_format=notify_format,
            **kwargs)

        # Store To Addr
        self.to_addr = to

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', NotifyBase.app_desc)
        self.from_addr = kwargs.get('from', None)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        match = NotifyBase.is_email(self.from_addr)
        if not match:
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        # Using the match, we want to extract the user id and domain
        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.to_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, self.from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (self.from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        try:
            socket.quit()

        except:
            # no problem
            pass

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        else:
            # get 'To' email address
            try:
                to_addr = '%s@%s' % (
                    re.split(
                        '[\s@]+', NotifyBase.unquote(results['user']))[0],
                    results.get('host', '')
                )

            except (AttributeError, IndexError):
                # No problem, we have other ways of getting
                # the To address
                pass

        # Attempt to detect 'from' email address
        from_addr = to_addr
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])
            if not NotifyBase.is_email(from_addr):
                # Lets be clever and attempt to make the from
                # address an email based on the to address
                from_addr = '%s@%s' % (
                    re.split('[\s@]+', from_addr)[0],
                    re.split('[\s@]+', to_addr)[-1],
                )

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from .NotifyBase import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, to, notify_format, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            notify_format=notify_format,
            **kwargs)

        # Store To Addr
        self.to_addr = to

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', NotifyBase.app_desc)
        self.from_addr = kwargs.get('from', None)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        match = NotifyBase.is_email(self.from_addr)
        if not match:
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        # Using the match, we want to extract the user id and domain
        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.to_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, self.from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (self.from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        else:
            # get 'To' email address
            to_addr = '%s@%s' % (
                re.split(
                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )

        # Attempt to detect 'from' email address
        from_addr = to_addr
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])
            if not NotifyBase.is_email(from_addr):
                # Lets be clever and attempt to make the from
                # address an email based on the to address
                from_addr = '%s@%s' % (
                    re.split('[\s@]+', from_addr)[0],
                    re.split('[\s@]+', to_addr)[-1],
                )

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","@@ -189,7 +189,7 @@ class NotifyEmail(NotifyBase):
             # over-riding any smarts to be applied
             return
 
-        for i in range(len(WEBBASE_LOOKUP_TABLE)):
+        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
             self.logger.debug('Scanning %s against %s' % (
                 self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
             ))
@@ -290,13 +290,10 @@ class NotifyEmail(NotifyBase):
             # Return; we're done
             return False
 
-        try:
+        finally:
+            # Gracefully terminate the connection with the server
             socket.quit()
 
-        except:
-            # no problem
-            pass
-
         return True
 
     @staticmethod
@@ -332,17 +329,11 @@ class NotifyEmail(NotifyBase):
 
         else:
             # get 'To' email address
-            try:
-                to_addr = '%s@%s' % (
-                    re.split(
-                        '[\s@]+', NotifyBase.unquote(results['user']))[0],
-                    results.get('host', '')
-                )
-
-            except (AttributeError, IndexError):
-                # No problem, we have other ways of getting
-                # the To address
-                pass
+            to_addr = '%s@%s' % (
+                re.split(
+                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
+                results.get('host', '')
+            )
 
         # Attempt to detect 'from' email address
         from_addr = to_addr
",add more comments to the notifyemail class,0.67,-3,-9
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyFaast.py,"# -*- coding: utf-8 -*-
#
# Faast Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize

# Image Support (72x72)
FAAST_IMAGE_XY = NotifyImageSize.XY_72


class NotifyFaast(NotifyBase):
    """"""
    A wrapper for Faast Notifications
    """"""

    # The default protocol (this is secure for faast)
    protocol = 'faast'

    # Faast uses the http protocol with JSON requests
    notify_url = 'https://www.appnotifications.com/account/notifications.json'

    def __init__(self, authtoken, **kwargs):
        """"""
        Initialize Faast Object
        """"""
        super(NotifyFaast, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=FAAST_IMAGE_XY,
            **kwargs)

        self.authtoken = authtoken

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Faast Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'multipart/form-data'
        }

        # prepare JSON Object
        payload = {
            'user_credentials': self.authtoken,
            'title': title,
            'message': body,
        }

        if self.include_image:
            image_url = self.image_url(
                notify_type,
            )
            if image_url:
                payload['icon_url'] = image_url

        self.logger.debug('Faast POST URL: %s (cert_verify=%r)' % (
            self.notify_url, self.verify_certificate,
        ))
        self.logger.debug('Faast Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.notify_url,
                data=payload,
                headers=headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Faast notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to send Faast notification '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False
            else:
                self.logger.info('Sent Faast notification.')

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending Faast notification.',
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Store our authtoken using the host
        results['authtoken'] = results['host']

        return results
","# -*- coding: utf-8 -*-
#
# Faast Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize

# Image Support (72x72)
FAAST_IMAGE_XY = NotifyImageSize.XY_72


class NotifyFaast(NotifyBase):
    """"""
    A wrapper for Faast Notifications
    """"""

    # The default protocol (this is secure for faast)
    protocol = 'faast'

    # Faast uses the http protocol with JSON requests
    notify_url = 'https://www.appnotifications.com/account/notifications.json'

    def __init__(self, authtoken, **kwargs):
        """"""
        Initialize Faast Object
        """"""
        super(NotifyFaast, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=FAAST_IMAGE_XY,
            **kwargs)

        self.authtoken = authtoken

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Faast Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'multipart/form-data'
        }

        # prepare JSON Object
        payload = {
            'user_credentials': self.authtoken,
            'title': title,
            'message': body,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['icon_url'] = image_url

        self.logger.debug('Faast POST URL: %s (cert_verify=%r)' % (
            self.notify_url, self.verify_certificate,
        ))
        self.logger.debug('Faast Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.notify_url,
                data=payload,
                headers=headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Faast notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to send Faast notification '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False
            else:
                self.logger.info('Sent Faast notification.')

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending Faast notification.',
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Store our authtoken using the host
        results['authtoken'] = results['host']

        return results
","@@ -64,12 +64,9 @@ class NotifyFaast(NotifyBase):
             'message': body,
         }
 
-        if self.include_image:
-            image_url = self.image_url(
-                notify_type,
-            )
-            if image_url:
-                payload['icon_url'] = image_url
+        image_url = self.image_url(notify_type)
+        if image_url:
+            payload['icon_url'] = image_url
 
         self.logger.debug('Faast POST URL: %s (cert_verify=%r)' % (
             self.notify_url, self.verify_certificate,
",add missing image_url to notifyfaast,0.3,-1,-3
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyGrowl.py,"# -*- coding: utf-8 -*-
#
# Growl Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from .gntp.notifier import GrowlNotifier
from .gntp.errors import NetworkError as GrowlNetworkError
from .gntp.errors import AuthError as GrowlAuthenticationError

from ..NotifyBase import NotifyBase
from ...common import NotifyImageSize

# Image Support (72x72)
GROWL_IMAGE_XY = NotifyImageSize.XY_72


# Priorities
class GrowlPriority(object):
    VERY_LOW = -2
    MODERATE = -1
    NORMAL = 0
    HIGH = 1
    EMERGENCY = 2


GROWL_PRIORITIES = (
    GrowlPriority.VERY_LOW,
    GrowlPriority.MODERATE,
    GrowlPriority.NORMAL,
    GrowlPriority.HIGH,
    GrowlPriority.EMERGENCY,
)

GROWL_NOTIFICATION_TYPE = ""New Messages""


class NotifyGrowl(NotifyBase):
    """"""
    A wrapper to Growl Notifications

    """"""

    # The default protocol
    protocol = 'growl'

    # Default Growl Port
    default_port = 23053

    def __init__(self, priority=GrowlPriority.NORMAL, version=2, **kwargs):
        """"""
        Initialize Growl Object
        """"""
        super(NotifyGrowl, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=GROWL_IMAGE_XY, **kwargs)

        # A Global flag that tracks registration
        self.is_registered = False

        if not self.port:
            self.port = self.default_port

        # The Priority of the message
        if priority not in GROWL_PRIORITIES:
            self.priority = GrowlPriority.NORMAL

        else:
            self.priority = priority

        # Always default the sticky flag to False
        self.sticky = False

        # Store Version
        self.version = version

        payload = {
            'applicationName': self.app_id,
            'notifications': [GROWL_NOTIFICATION_TYPE, ],
            'defaultNotifications': [GROWL_NOTIFICATION_TYPE, ],
            'hostname': self.host,
            'port': self.port,
        }

        if self.password is not None:
            payload['password'] = self.password

        self.logger.debug('Growl Registration Payload: %s' % str(payload))
        self.growl = GrowlNotifier(**payload)

        try:
            self.growl.register()
            # Toggle our flag
            self.is_registered = True
            self.logger.debug(
                'Growl server registration completed successfully.'
            )

        except GrowlNetworkError:
            self.logger.warning(
                'A network error occured sending Growl '
                'notification to %s.' % self.host)
            return

        except GrowlAuthenticationError:
            self.logger.warning(
                'An authentication error occured sending Growl '
                'notification to %s.' % self.host)
            return

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Growl Notification
        """"""

        if not self.is_registered:
            # We can't do anything
            return None

        # Limit results to just the first 2 line otherwise there is just to
        # much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        icon = None
        if self.include_image:
            if self.version >= 2:
                # URL Based
                icon = self.image_url(notify_type)
            else:
                # Raw
                icon = self.image_raw(notify_type)

        payload = {
            'noteType': GROWL_NOTIFICATION_TYPE,
            'title': title,
            'description': body,
            'icon': icon is not None,
            'sticky': False,
            'priority': self.priority,
        }
        self.logger.debug('Growl Payload: %s' % str(payload))

        # Update icon of payload to be raw data
        payload['icon'] = icon

        try:
            response = self.growl.notify(**payload)
            if not isinstance(response, bool):
                self.logger.warning(
                    'Growl notification failed to send with response: %s' %
                    str(response),
                )

            else:
                self.logger.debug(
                    'Growl notification sent successfully.'
                )

        except GrowlNetworkError as e:
            # Since Growl servers listen for UDP broadcasts, it's possible
            # that you will never get to this part of the code since there is
            # no acknowledgement as to whether it accepted what was sent to it
            # or not.

            # However, if the host/server is unavailable, you will get to this
            # point of the code.
            self.logger.warning(
                'A Connection error occured sending Growl '
                'notification to %s.' % self.host)
            self.logger.debug('Growl Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        version = None
        if 'version' in results['qsd'] and len(results['qsd']['version']):
            # Allow the user to specify the version of the protocol to use.
            try:
                version = int(
                    NotifyBase.unquote(
                        results['qsd']['version']).strip().split('.')[0])

            except (AttributeError, IndexError, TypeError, ValueError):
                NotifyBase.logger.warning(
                    'An invalid Growl version of ""%s"" was specified and will '
                    'be ignored.' % results['qsd']['version']
                )
                pass

        # Because of the URL formatting, the password is actually where the
        # username field is. For this reason, we just preform this small hack
        # to make it (the URL) conform correctly. The following strips out the
        # existing password entry (if exists) so that it can be swapped with
        # the new one we specify.
        results['user'] = None
        results['password'] = results.get('user', None)
        if version:
            results['version'] = version

        return results
","# -*- coding: utf-8 -*-
#
# Growl Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from .gntp.notifier import GrowlNotifier
from .gntp.errors import NetworkError as GrowlNetworkError
from .gntp.errors import AuthError as GrowlAuthenticationError

from ..NotifyBase import NotifyBase
from ...common import NotifyImageSize

# Image Support (72x72)
GROWL_IMAGE_XY = NotifyImageSize.XY_72


# Priorities
class GrowlPriority(object):
    VERY_LOW = -2
    MODERATE = -1
    NORMAL = 0
    HIGH = 1
    EMERGENCY = 2


GROWL_PRIORITIES = (
    GrowlPriority.VERY_LOW,
    GrowlPriority.MODERATE,
    GrowlPriority.NORMAL,
    GrowlPriority.HIGH,
    GrowlPriority.EMERGENCY,
)

GROWL_NOTIFICATION_TYPE = ""New Messages""


class NotifyGrowl(NotifyBase):
    """"""
    A wrapper to Growl Notifications

    """"""

    # The default protocol
    protocol = 'growl'

    # Default Growl Port
    default_port = 23053

    def __init__(self, priority=GrowlPriority.NORMAL, version=2, **kwargs):
        """"""
        Initialize Growl Object
        """"""
        super(NotifyGrowl, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=GROWL_IMAGE_XY, **kwargs)

        # A Global flag that tracks registration
        self.is_registered = False

        if not self.port:
            self.port = self.default_port

        # The Priority of the message
        if priority not in GROWL_PRIORITIES:
            self.priority = GrowlPriority.NORMAL

        else:
            self.priority = priority

        # Always default the sticky flag to False
        self.sticky = False

        # Store Version
        self.version = version

        payload = {
            'applicationName': self.app_id,
            'notifications': [GROWL_NOTIFICATION_TYPE, ],
            'defaultNotifications': [GROWL_NOTIFICATION_TYPE, ],
            'hostname': self.host,
            'port': self.port,
        }

        if self.password is not None:
            payload['password'] = self.password

        self.logger.debug('Growl Registration Payload: %s' % str(payload))
        self.growl = GrowlNotifier(**payload)

        try:
            self.growl.register()
            # Toggle our flag
            self.is_registered = True
            self.logger.debug(
                'Growl server registration completed successfully.'
            )

        except GrowlNetworkError:
            self.logger.warning(
                'A network error occured sending Growl '
                'notification to %s.' % self.host)
            return

        except GrowlAuthenticationError:
            self.logger.warning(
                'An authentication error occured sending Growl '
                'notification to %s.' % self.host)
            return

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Growl Notification
        """"""

        if not self.is_registered:
            # We can't do anything
            return None

        # Limit results to just the first 2 line otherwise there is just to
        # much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        icon = None
        if self.version >= 2:
            # URL Based
            icon = self.image_url(notify_type)

        else:
            # Raw
            icon = self.image_raw(notify_type)

        payload = {
            'noteType': GROWL_NOTIFICATION_TYPE,
            'title': title,
            'description': body,
            'icon': icon is not None,
            'sticky': False,
            'priority': self.priority,
        }
        self.logger.debug('Growl Payload: %s' % str(payload))

        # Update icon of payload to be raw data
        payload['icon'] = icon

        try:
            response = self.growl.notify(**payload)
            if not isinstance(response, bool):
                self.logger.warning(
                    'Growl notification failed to send with response: %s' %
                    str(response),
                )

            else:
                self.logger.debug(
                    'Growl notification sent successfully.'
                )

        except GrowlNetworkError as e:
            # Since Growl servers listen for UDP broadcasts, it's possible
            # that you will never get to this part of the code since there is
            # no acknowledgement as to whether it accepted what was sent to it
            # or not.

            # However, if the host/server is unavailable, you will get to this
            # point of the code.
            self.logger.warning(
                'A Connection error occured sending Growl '
                'notification to %s.' % self.host)
            self.logger.debug('Growl Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        version = None
        if 'version' in results['qsd'] and len(results['qsd']['version']):
            # Allow the user to specify the version of the protocol to use.
            try:
                version = int(
                    NotifyBase.unquote(
                        results['qsd']['version']).strip().split('.')[0])

            except (AttributeError, IndexError, TypeError, ValueError):
                NotifyBase.logger.warning(
                    'An invalid Growl version of ""%s"" was specified and will '
                    'be ignored.' % results['qsd']['version']
                )
                pass

        # Because of the URL formatting, the password is actually where the
        # username field is. For this reason, we just preform this small hack
        # to make it (the URL) conform correctly. The following strips out the
        # existing password entry (if exists) so that it can be swapped with
        # the new one we specify.
        results['user'] = None
        results['password'] = results.get('user', None)
        if version:
            results['version'] = version

        return results
","@@ -140,13 +140,13 @@ class NotifyGrowl(NotifyBase):
         body = '\r\n'.join(body[0:2])
 
         icon = None
-        if self.include_image:
-            if self.version >= 2:
-                # URL Based
-                icon = self.image_url(notify_type)
-            else:
-                # Raw
-                icon = self.image_raw(notify_type)
+        if self.version >= 2:
+            # URL Based
+            icon = self.image_url(notify_type)
+
+        else:
+            # Raw
+            icon = self.image_raw(notify_type)
 
         payload = {
             'noteType': GROWL_NOTIFICATION_TYPE,
",add missing url in notifyGrowl,0.26,-1,0
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyJSON.py,"# -*- coding: utf-8 -*-
#
# JSON Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
JSON_IMAGE_XY = NotifyImageSize.XY_128


class NotifyJSON(NotifyBase):
    """"""
    A wrapper for JSON Notifications
    """"""

    # The default protocol
    protocol = 'json'

    # The default secure protocol
    secure_protocol = 'jsons'

    def __init__(self, **kwargs):
        """"""
        Initialize JSON Object
        """"""
        super(NotifyJSON, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=JSON_IMAGE_XY,
            **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        self.fullpath = kwargs.get('fullpath')
        if not compat_is_basestring(self.fullpath):
            self.fullpath = '/'

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform JSON Notification
        """"""

        # prepare JSON Object
        payload = {
            # Version: Major.Minor,  Major is only updated if the entire
            # schema is changed. If just adding new items (or removing
            # old ones, only increment the Minor!
            'version': '1.0',
            'title': title,
            'message': body,
            'type': notify_type,
        }

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += self.fullpath

        self.logger.debug('JSON POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('JSON Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=dumps(payload),
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                try:
                    self.logger.warning(
                        'Failed to send JSON notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send JSON notification '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending JSON '
                'notification to %s.' % self.host)
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True
","# -*- coding: utf-8 -*-
#
# JSON Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
JSON_IMAGE_XY = NotifyImageSize.XY_128


class NotifyJSON(NotifyBase):
    """"""
    A wrapper for JSON Notifications
    """"""

    # The default protocol
    protocol = 'json'

    # The default secure protocol
    secure_protocol = 'jsons'

    def __init__(self, **kwargs):
        """"""
        Initialize JSON Object
        """"""
        super(NotifyJSON, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=JSON_IMAGE_XY,
            **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        self.fullpath = kwargs.get('fullpath')
        if not compat_is_basestring(self.fullpath):
            self.fullpath = '/'

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform JSON Notification
        """"""

        # prepare JSON Object
        payload = {
            # Version: Major.Minor,  Major is only updated if the entire
            # schema is changed. If just adding new items (or removing
            # old ones, only increment the Minor!
            'version': '1.0',
            'title': title,
            'message': body,
            'type': notify_type,
        }

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += self.fullpath

        self.logger.debug('JSON POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('JSON Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=dumps(payload),
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                try:
                    self.logger.warning(
                        'Failed to send JSON notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send JSON notification '
                        '(error=%s).' % (r.status_code))

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending JSON '
                'notification to %s.' % self.host)
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True
","@@ -113,8 +113,7 @@ class NotifyJSON(NotifyBase):
                 except KeyError:
                     self.logger.warning(
                         'Failed to send JSON notification '
-                        '(error=%s).' % (
-                            r.status_code))
+                        '(error=%s).' % (r.status_code))
 
                 # Return; we're done
                 return False
",add missing return statement,0.04,0,-1
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyJoin.py,"# -*- coding: utf-8 -*-
#
# Join Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# Join URL: http://joaoapps.com/join/
# To use this plugin, you need to first access (make sure your browser allows
#  popups): https://joinjoaomgcd.appspot.com/
#
# To register you just need to allow it to connect to your Google Profile but
# the good news is it doesn't ask for anything too personal.
#
# You can download the app for your phone here:
#   https://play.google.com/store/apps/details?id=com.joaomgcd.join

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
VALIDATE_APIKEY = re.compile(r'[A-Za-z0-9]{32}')

# Extend HTTP Error Messages
JOIN_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
JOIN_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of devices
DEVICE_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Used to detect a device
IS_DEVICE_RE = re.compile(r'([A-Za-z0-9]{32})')

# Used to detect a device
IS_GROUP_RE = re.compile(
    r'(group\.)?(?P<name>(all|android|chrome|windows10|phone|tablet|pc))',
    re.IGNORECASE,
)

# Image Support (72x72)
JOIN_IMAGE_XY = NotifyImageSize.XY_72


class NotifyJoin(NotifyBase):
    """"""
    A wrapper for Join Notifications
    """"""

    # The default protocol
    protocol = 'join'

    # Join uses the http protocol with JSON requests
    notify_url = \
        'https://joinjoaomgcd.appspot.com/_ah/api/messaging/v1/sendPush'

    def __init__(self, apikey, devices, **kwargs):
        """"""
        Initialize Join Object
        """"""
        super(NotifyJoin, self).__init__(
            title_maxlen=250, body_maxlen=1000, image_size=JOIN_IMAGE_XY,
            **kwargs)

        if not VALIDATE_APIKEY.match(apikey.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % apikey,
            )

            raise TypeError(
                'The first API Token specified (%s) is invalid.' % apikey,
            )

        # The token associated with the account
        self.apikey = apikey.strip()

        if compat_is_basestring(devices):
            self.devices = filter(bool, DEVICE_LIST_DELIM.split(
                devices,
            ))

        elif isinstance(devices, (set, tuple, list)):
            self.devices = devices

        else:
            self.devices = list()

        if len(self.devices) == 0:
            self.logger.warning('No device(s) were specified.')
            raise TypeError('No device(s) were specified.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Join Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/x-www-form-urlencoded',
        }

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the devices list
        devices = list(self.devices)
        while len(devices):
            device = devices.pop(0)
            group_re = IS_GROUP_RE.match(device)
            if group_re:
                device = 'group.%s' % group_re.group('name').lower()

            elif not IS_DEVICE_RE.match(device):
                self.logger.warning(
                    ""The specified device '%s' is invalid; skipping."" % (
                        device,
                    )
                )
                continue

            url_args = {
                'apikey': self.apikey,
                'deviceId': device,
                'title': title,
                'text': body,
            }

            if self.include_image:
                image_url = self.image_url(
                    notify_type,
                )
                if image_url:
                    url_args['icon'] = image_url

            # prepare payload
            payload = {}

            # Prepare the URL
            url = '%s?%s' % (self.notify_url, NotifyBase.urlencode(url_args))

            self.logger.debug('Join POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Join Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=payload,
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Join:%s '
                            'notification: %s (error=%s).' % (
                                device,
                                JOIN_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Join:%s '
                            'notification (error=%s).' % (
                                device,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Join:%s '
                    'notification.' % device
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(devices):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            devices = ' '.join(
                filter(bool, NotifyBase.split_path(results['fullpath'])))

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            devices = None

        results['apikey'] = results['host']
        results['devices'] = devices

        return results
","# -*- coding: utf-8 -*-
#
# Join Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# Join URL: http://joaoapps.com/join/
# To use this plugin, you need to first access (make sure your browser allows
#  popups): https://joinjoaomgcd.appspot.com/
#
# To register you just need to allow it to connect to your Google Profile but
# the good news is it doesn't ask for anything too personal.
#
# You can download the app for your phone here:
#   https://play.google.com/store/apps/details?id=com.joaomgcd.join

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
VALIDATE_APIKEY = re.compile(r'[A-Za-z0-9]{32}')

# Extend HTTP Error Messages
JOIN_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
JOIN_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of devices
DEVICE_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Used to detect a device
IS_DEVICE_RE = re.compile(r'([A-Za-z0-9]{32})')

# Used to detect a device
IS_GROUP_RE = re.compile(
    r'(group\.)?(?P<name>(all|android|chrome|windows10|phone|tablet|pc))',
    re.IGNORECASE,
)

# Image Support (72x72)
JOIN_IMAGE_XY = NotifyImageSize.XY_72


class NotifyJoin(NotifyBase):
    """"""
    A wrapper for Join Notifications
    """"""

    # The default protocol
    protocol = 'join'

    # Join uses the http protocol with JSON requests
    notify_url = \
        'https://joinjoaomgcd.appspot.com/_ah/api/messaging/v1/sendPush'

    def __init__(self, apikey, devices, **kwargs):
        """"""
        Initialize Join Object
        """"""
        super(NotifyJoin, self).__init__(
            title_maxlen=250, body_maxlen=1000, image_size=JOIN_IMAGE_XY,
            **kwargs)

        if not VALIDATE_APIKEY.match(apikey.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % apikey,
            )

            raise TypeError(
                'The first API Token specified (%s) is invalid.' % apikey,
            )

        # The token associated with the account
        self.apikey = apikey.strip()

        if compat_is_basestring(devices):
            self.devices = filter(bool, DEVICE_LIST_DELIM.split(
                devices,
            ))

        elif isinstance(devices, (set, tuple, list)):
            self.devices = devices

        else:
            self.devices = list()

        if len(self.devices) == 0:
            self.logger.warning('No device(s) were specified.')
            raise TypeError('No device(s) were specified.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Join Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/x-www-form-urlencoded',
        }

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the devices list
        devices = list(self.devices)
        while len(devices):
            device = devices.pop(0)
            group_re = IS_GROUP_RE.match(device)
            if group_re:
                device = 'group.%s' % group_re.group('name').lower()

            elif not IS_DEVICE_RE.match(device):
                self.logger.warning(
                    ""The specified device '%s' is invalid; skipping."" % (
                        device,
                    )
                )
                continue

            url_args = {
                'apikey': self.apikey,
                'deviceId': device,
                'title': title,
                'text': body,
            }

            image_url = self.image_url(notify_type)
            if image_url:
                url_args['icon'] = image_url

            # prepare payload
            payload = {}

            # Prepare the URL
            url = '%s?%s' % (self.notify_url, NotifyBase.urlencode(url_args))

            self.logger.debug('Join POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Join Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=payload,
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Join:%s '
                            'notification: %s (error=%s).' % (
                                device,
                                JOIN_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Join:%s '
                            'notification (error=%s).' % (
                                device,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Join:%s '
                    'notification.' % device
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(devices):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            devices = ' '.join(
                filter(bool, NotifyBase.split_path(results['fullpath'])))

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            devices = None

        results['apikey'] = results['host']
        results['devices'] = devices

        return results
","@@ -148,12 +148,9 @@ class NotifyJoin(NotifyBase):
                 'text': body,
             }
 
-            if self.include_image:
-                image_url = self.image_url(
-                    notify_type,
-                )
-                if image_url:
-                    url_args['icon'] = image_url
+            image_url = self.image_url(notify_type)
+            if image_url:
+                url_args['icon'] = image_url
 
             # prepare payload
             payload = {}
",add missing image_url to notify join,0.3,-1,-3
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyPushBullet.py,"# -*- coding: utf-8 -*-
#
# PushBullet Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from .NotifyBase import IS_EMAIL_RE

from ..utils import compat_is_basestring

# Flag used as a placeholder to sending to all devices
PUSHBULLET_SEND_TO_ALL = 'ALL_DEVICES'

# Used to break apart list of potential recipients by their delimiter
# into a usable list.
RECIPIENTS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Extend HTTP Error Messages
PUSHBULLET_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
PUSHBULLET_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})


class NotifyPushBullet(NotifyBase):
    """"""
    A wrapper for PushBullet Notifications
    """"""

    # The default protocol
    protocol = 'pbul'

    # The default secure protocol
    secure_protocol = 'pbul'

    # PushBullet uses the http protocol with JSON requests
    notify_url = 'https://api.pushbullet.com/v2/pushes'

    def __init__(self, accesstoken, recipients=None, **kwargs):
        """"""
        Initialize PushBullet Object
        """"""
        super(NotifyPushBullet, self).__init__(
            title_maxlen=250, body_maxlen=32768, **kwargs)

        self.accesstoken = accesstoken
        if compat_is_basestring(recipients):
            self.recipients = filter(bool, RECIPIENTS_LIST_DELIM.split(
                recipients,
            ))

        elif isinstance(recipients, (tuple, list)):
            self.recipients = recipients

        else:
            self.recipients = list()

        if len(self.recipients) == 0:
            self.recipients = (PUSHBULLET_SEND_TO_ALL, )

    def notify(self, title, body, **kwargs):
        """"""
        Perform PushBullet Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }
        auth = (self.accesstoken, '')

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the recipients list
        recipients = list(self.recipients)
        while len(recipients):
            recipient = recipients.pop(0)

            # prepare JSON Object
            payload = {
                'type': 'note',
                'title': title,
                'body': body,
            }

            if recipient is PUSHBULLET_SEND_TO_ALL:
                # Send to all
                pass

            elif IS_EMAIL_RE.match(recipient):
                payload['email'] = recipient
                self.logger.debug(
                    ""Recipient '%s' is an email address"" % recipient)

            elif recipient[0] == '#':
                payload['channel_tag'] = recipient[1:]
                self.logger.debug(""Recipient '%s' is a channel"" % recipient)

            else:
                payload['device_iden'] = recipient
                self.logger.debug(
                    ""Recipient '%s' is a device"" % recipient)

            self.logger.debug('PushBullet POST URL: %s (cert_verify=%r)' % (
                self.notify_url, self.verify_certificate,
            ))
            self.logger.debug('PushBullet Payload: %s' % str(payload))
            try:
                r = requests.post(
                    self.notify_url,
                    data=dumps(payload),
                    headers=headers,
                    auth=auth,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send PushBullet notification: '
                            '%s (error=%s).' % (
                                PUSHBULLET_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send PushBullet notification '
                            '(error=%s).' % r.status_code)

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending PushBullet '
                    'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(recipients):
                # Prevent thrashing requests
                self.throttle()

        return not has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            recipients = NotifyBase.unquote(results['fullpath'])

        except AttributeError:
            recipients = ''

        results['accesstoken'] = results['host']
        results['recipients'] = recipients

        return results
","# -*- coding: utf-8 -*-
#
# PushBullet Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from .NotifyBase import IS_EMAIL_RE

from ..utils import compat_is_basestring

# Flag used as a placeholder to sending to all devices
PUSHBULLET_SEND_TO_ALL = 'ALL_DEVICES'

# Used to break apart list of potential recipients by their delimiter
# into a usable list.
RECIPIENTS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Extend HTTP Error Messages
PUSHBULLET_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
PUSHBULLET_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})


class NotifyPushBullet(NotifyBase):
    """"""
    A wrapper for PushBullet Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'pbul'

    # PushBullet uses the http protocol with JSON requests
    notify_url = 'https://api.pushbullet.com/v2/pushes'

    def __init__(self, accesstoken, recipients=None, **kwargs):
        """"""
        Initialize PushBullet Object
        """"""
        super(NotifyPushBullet, self).__init__(
            title_maxlen=250, body_maxlen=32768, **kwargs)

        self.accesstoken = accesstoken
        if compat_is_basestring(recipients):
            self.recipients = filter(bool, RECIPIENTS_LIST_DELIM.split(
                recipients,
            ))

        elif isinstance(recipients, (tuple, list)):
            self.recipients = recipients

        else:
            self.recipients = list()

        if len(self.recipients) == 0:
            self.recipients = (PUSHBULLET_SEND_TO_ALL, )

    def notify(self, title, body, **kwargs):
        """"""
        Perform PushBullet Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }
        auth = (self.accesstoken, '')

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the recipients list
        recipients = list(self.recipients)
        while len(recipients):
            recipient = recipients.pop(0)

            # prepare JSON Object
            payload = {
                'type': 'note',
                'title': title,
                'body': body,
            }

            if recipient is PUSHBULLET_SEND_TO_ALL:
                # Send to all
                pass

            elif IS_EMAIL_RE.match(recipient):
                payload['email'] = recipient
                self.logger.debug(
                    ""Recipient '%s' is an email address"" % recipient)

            elif recipient[0] == '#':
                payload['channel_tag'] = recipient[1:]
                self.logger.debug(""Recipient '%s' is a channel"" % recipient)

            else:
                payload['device_iden'] = recipient
                self.logger.debug(
                    ""Recipient '%s' is a device"" % recipient)

            self.logger.debug('PushBullet POST URL: %s (cert_verify=%r)' % (
                self.notify_url, self.verify_certificate,
            ))
            self.logger.debug('PushBullet Payload: %s' % str(payload))
            try:
                r = requests.post(
                    self.notify_url,
                    data=dumps(payload),
                    headers=headers,
                    auth=auth,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send PushBullet notification: '
                            '%s (error=%s).' % (
                                PUSHBULLET_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send PushBullet notification '
                            '(error=%s).' % r.status_code)

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending PushBullet '
                    'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(recipients):
                # Prevent thrashing requests
                self.throttle()

        return not has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            recipients = NotifyBase.unquote(results['fullpath'])

        except AttributeError:
            recipients = ''

        results['accesstoken'] = results['host']
        results['recipients'] = recipients

        return results
","@@ -45,9 +45,6 @@ class NotifyPushBullet(NotifyBase):
     A wrapper for PushBullet Notifications
     """"""
 
-    # The default protocol
-    protocol = 'pbul'
-
     # The default secure protocol
     secure_protocol = 'pbul'
 
",add missing comment,0.07,0,-3
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyPushalot.py,"# -*- coding: utf-8 -*-
#
# Pushalot Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize

# Image Support (72x72)
PUSHALOT_IMAGE_XY = NotifyImageSize.XY_72

# Extend HTTP Error Messages
PUSHALOT_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
PUSHALOT_HTTP_ERROR_MAP.update({
    406: 'Message throttle limit hit.',
    410: 'AuthorizedToken is no longer valid.',
})

# Used to validate Authorization Token
VALIDATE_AUTHTOKEN = re.compile(r'[A-Za-z0-9]{32}')


class NotifyPushalot(NotifyBase):
    """"""
    A wrapper for Pushalot Notifications
    """"""

    # The default protocol
    protocol = 'palot'

    # The default secure protocol
    secure_protocol = 'palot'

    # Pushalot uses the http protocol with JSON requests
    notify_url = 'https://pushalot.com/api/sendmessage'

    def __init__(self, authtoken, is_important=False, **kwargs):
        """"""
        Initialize Pushalot Object
        """"""
        super(NotifyPushalot, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=PUSHALOT_IMAGE_XY, **kwargs)

        # Is Important Flag
        self.is_important = is_important

        self.authtoken = authtoken
        # Validate authtoken
        if not VALIDATE_AUTHTOKEN.match(authtoken):
            self.logger.warning(
                'Invalid Pushalot Authorization Token Specified.'
            )
            raise TypeError(
                'Invalid Pushalot Authorization Token Specified.'
            )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Pushalot Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'AuthorizationToken': self.authtoken,
            'IsImportant': self.is_important,
            'Title': title,
            'Body': body,
            'Source': self.app_id,
        }

        if self.include_image:
            image_url = self.image_url(
                notify_type,
            )
            if image_url:
                payload['Image'] = image_url

        self.logger.debug('Pushalot POST URL: %s (cert_verify=%r)' % (
            self.notify_url, self.verify_certificate,
        ))
        self.logger.debug('Pushalot Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.notify_url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )

            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Pushalot notification: '
                        '%s (error=%s).' % (
                            PUSHALOT_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to send Pushalot notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent Pushalot notification.')

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending Pushalot notification.')
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        results['authtoken'] = results['host']

        return results
","# -*- coding: utf-8 -*-
#
# Pushalot Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize

# Image Support (72x72)
PUSHALOT_IMAGE_XY = NotifyImageSize.XY_72

# Extend HTTP Error Messages
PUSHALOT_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
PUSHALOT_HTTP_ERROR_MAP.update({
    406: 'Message throttle limit hit.',
    410: 'AuthorizedToken is no longer valid.',
})

# Used to validate Authorization Token
VALIDATE_AUTHTOKEN = re.compile(r'[A-Za-z0-9]{32}')


class NotifyPushalot(NotifyBase):
    """"""
    A wrapper for Pushalot Notifications
    """"""

    # The default protocol
    protocol = 'palot'

    # The default secure protocol
    secure_protocol = 'palot'

    # Pushalot uses the http protocol with JSON requests
    notify_url = 'https://pushalot.com/api/sendmessage'

    def __init__(self, authtoken, is_important=False, **kwargs):
        """"""
        Initialize Pushalot Object
        """"""
        super(NotifyPushalot, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=PUSHALOT_IMAGE_XY, **kwargs)

        # Is Important Flag
        self.is_important = is_important

        self.authtoken = authtoken
        # Validate authtoken
        if not VALIDATE_AUTHTOKEN.match(authtoken):
            self.logger.warning(
                'Invalid Pushalot Authorization Token Specified.'
            )
            raise TypeError(
                'Invalid Pushalot Authorization Token Specified.'
            )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Pushalot Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'AuthorizationToken': self.authtoken,
            'IsImportant': self.is_important,
            'Title': title,
            'Body': body,
            'Source': self.app_id,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['Image'] = image_url

        self.logger.debug('Pushalot POST URL: %s (cert_verify=%r)' % (
            self.notify_url, self.verify_certificate,
        ))
        self.logger.debug('Pushalot Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.notify_url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )

            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Pushalot notification: '
                        '%s (error=%s).' % (
                            PUSHALOT_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to send Pushalot notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent Pushalot notification.')

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending Pushalot notification.')
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        results['authtoken'] = results['host']

        return results
","@@ -92,12 +92,9 @@ class NotifyPushalot(NotifyBase):
             'Source': self.app_id,
         }
 
-        if self.include_image:
-            image_url = self.image_url(
-                notify_type,
-            )
-            if image_url:
-                payload['Image'] = image_url
+        image_url = self.image_url(notify_type)
+        if image_url:
+            payload['Image'] = image_url
 
         self.logger.debug('Pushalot POST URL: %s (cert_verify=%r)' % (
             self.notify_url, self.verify_certificate,
",add image field to notifypushalot,0.36,-1,-3
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifySlack.py,"# -*- coding: utf-8 -*-
#
# Slack Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.slack.com
# Specifically https://my.slack.com/services/new/incoming-webhook/
# to create a new incoming webhook for your account. You'll need to
# follow the wizard to pre-determine the channel(s) you want your
# message to broadcast to, and when you're complete, you will
# recieve a URL that looks something like this:
# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7F
#                                     ^         ^               ^
#                                     |         |               |
#  These are important <--------------^---------^---------------^
#
#
import re
import requests
from json import dumps
from time import time

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
#  /AAAAAAAAA/........./........................
VALIDATE_TOKEN_A = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./BBBBBBBBB/........................
VALIDATE_TOKEN_B = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./........./CCCCCCCCCCCCCCCCCCCCCCCC
VALIDATE_TOKEN_C = re.compile(r'[A-Za-z0-9]{24}')

# Default User
SLACK_DEFAULT_USER = 'apprise'

# Extend HTTP Error Messages
SLACK_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
SLACK_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of devices
CHANNEL_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')

# Used to detect a device
IS_CHANNEL_RE = re.compile(r'#?([A-Za-z0-9_]{1,32})')

# Image Support (72x72)
SLACK_IMAGE_XY = NotifyImageSize.XY_72


class NotifySlack(NotifyBase):
    """"""
    A wrapper for Slack Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'slack'

    # Slack uses the http protocol with JSON requests
    notify_url = 'https://hooks.slack.com/services'

    def __init__(self, token_a, token_b, token_c, channels, **kwargs):
        """"""
        Initialize Slack Object
        """"""
        super(NotifySlack, self).__init__(
            title_maxlen=250, body_maxlen=1000,
            image_size=SLACK_IMAGE_XY, **kwargs)

        if not VALIDATE_TOKEN_A.match(token_a.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % token_a,
            )
            raise TypeError(
                'The first API Token specified (%s) is invalid.' % token_a,
            )

        # The token associated with the account
        self.token_a = token_a.strip()

        if not VALIDATE_TOKEN_B.match(token_b.strip()):
            self.logger.warning(
                'The second API Token specified (%s) is invalid.' % token_b,
            )
            raise TypeError(
                'The second API Token specified (%s) is invalid.' % token_b,
            )

        # The token associated with the account
        self.token_b = token_b.strip()

        if not VALIDATE_TOKEN_C.match(token_c.strip()):
            self.logger.warning(
                'The third API Token specified (%s) is invalid.' % token_c,
            )
            raise TypeError(
                'The third API Token specified (%s) is invalid.' % token_c,
            )

        # The token associated with the account
        self.token_c = token_c.strip()

        if not self.user:
            self.logger.warning(
                'No user was specified; using %s.' % SLACK_DEFAULT_USER)
            self.user = SLACK_DEFAULT_USER

        if compat_is_basestring(channels):
            self.channels = filter(bool, CHANNEL_LIST_DELIM.split(
                channels,
            ))
        elif isinstance(channels, (set, tuple, list)):
            self.channels = channels
        else:
            self.channels = list()

        if len(self.channels) == 0:
            self.logger.warning('No channel(s) were specified.')
            raise TypeError('No channel(s) were specified.')

        # Formatting requirements are defined here:
        # https://api.slack.com/docs/message-formatting
        self._re_formatting_map = {
            # New lines must become the string version
            '\r\*\n': '\\n',
            # Escape other special characters
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
        }

        # Iterate over above list and store content accordingly
        self._re_formatting_rules = re.compile(
            r'(' + '|'.join(self._re_formatting_map.keys()) + r')',
            re.IGNORECASE,
        )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Slack Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        has_error = False

        # Perform Formatting
        title = self._re_formatting_rules.sub(
            lambda x: self._re_formatting_map[x.group()], title,
        )
        body = self._re_formatting_rules.sub(
            lambda x: self._re_formatting_map[x.group()], body,
        )
        url = '%s/%s/%s/%s' % (
            self.notify_url,
            self.token_a,
            self.token_b,
            self.token_c,
        )

        image_url = None
        if self.include_image:
            image_url = self.image_url(
                notify_type,
            )

        # Create a copy of the channel list
        channels = list(self.channels)
        while len(channels):
            channel = channels.pop(0)
            if not IS_CHANNEL_RE.match(channel):
                self.logger.warning(
                    ""The specified channel '%s' is invalid; skipping."" % (
                        channel,
                    )
                )
                continue

            if len(channel) > 1 and channel[0] == '+':
                # Treat as encoded id if prefixed with a +
                _channel = channel[1:]
            elif len(channel) > 1 and channel[0] == '@':
                # Treat @ value 'as is'
                _channel = channel
            else:
                # Prefix with channel hash tag
                _channel = '#%s' % channel

            # prepare JSON Object
            payload = {
                'channel': _channel,
                'username': self.user,
                # Use Markdown language
                'mrkdwn': True,
                'attachments': [{
                    'title': title,
                    'text': body,
                    'color': self.asset.html_color[notify_type],
                    # Time
                    'ts': time(),
                    'footer': self.app_id,
                }],
            }

            if image_url:
                payload['attachments'][0]['footer_icon'] = image_url

            self.logger.debug('Slack POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Slack Payload: %s' % str(payload))
            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification: %s (error=%s).' % (
                                channel,
                                SLACK_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification (error=%s).' % (
                                channel,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Slack:%s ' % (
                        channel) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(channels):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostnamee
        token_a = results['host']

        # Now fetch the remaining tokens
        try:
            token_b, token_c = filter(
                bool, NotifyBase.split_path(results['fullpath']))[0:2]

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            token_b = None
            token_c = None

        try:
            channels = '#'.join(filter(
                bool, NotifyBase.split_path(results['fullpath']))[2:])

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            channels = None

        results['token_a'] = token_a
        results['token_b'] = token_b
        results['token_c'] = token_c
        results['channels'] = channels

        return results
","# -*- coding: utf-8 -*-
#
# Slack Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.slack.com
# Specifically https://my.slack.com/services/new/incoming-webhook/
# to create a new incoming webhook for your account. You'll need to
# follow the wizard to pre-determine the channel(s) you want your
# message to broadcast to, and when you're complete, you will
# recieve a URL that looks something like this:
# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ
#                                     ^         ^               ^
#                                     |         |               |
#  These are important <--------------^---------^---------------^
#
#
import re
import requests
from json import dumps
from time import time

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
#  /AAAAAAAAA/........./........................
VALIDATE_TOKEN_A = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./BBBBBBBBB/........................
VALIDATE_TOKEN_B = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./........./CCCCCCCCCCCCCCCCCCCCCCCC
VALIDATE_TOKEN_C = re.compile(r'[A-Za-z0-9]{24}')

# Default User
SLACK_DEFAULT_USER = 'apprise'

# Extend HTTP Error Messages
SLACK_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
SLACK_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of channels
CHANNEL_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')

# Used to detect a channel
IS_CHANNEL_RE = re.compile(r'[+#@]?([A-Z0-9_]{1,32})', re.I)

# Image Support (72x72)
SLACK_IMAGE_XY = NotifyImageSize.XY_72


class NotifySlack(NotifyBase):
    """"""
    A wrapper for Slack Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'slack'

    # Slack uses the http protocol with JSON requests
    notify_url = 'https://hooks.slack.com/services'

    def __init__(self, token_a, token_b, token_c, channels, **kwargs):
        """"""
        Initialize Slack Object
        """"""
        super(NotifySlack, self).__init__(
            title_maxlen=250, body_maxlen=1000,
            image_size=SLACK_IMAGE_XY, **kwargs)

        if not VALIDATE_TOKEN_A.match(token_a.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % token_a,
            )
            raise TypeError(
                'The first API Token specified (%s) is invalid.' % token_a,
            )

        # The token associated with the account
        self.token_a = token_a.strip()

        if not VALIDATE_TOKEN_B.match(token_b.strip()):
            self.logger.warning(
                'The second API Token specified (%s) is invalid.' % token_b,
            )
            raise TypeError(
                'The second API Token specified (%s) is invalid.' % token_b,
            )

        # The token associated with the account
        self.token_b = token_b.strip()

        if not VALIDATE_TOKEN_C.match(token_c.strip()):
            self.logger.warning(
                'The third API Token specified (%s) is invalid.' % token_c,
            )
            raise TypeError(
                'The third API Token specified (%s) is invalid.' % token_c,
            )

        # The token associated with the account
        self.token_c = token_c.strip()

        if not self.user:
            self.logger.warning(
                'No user was specified; using %s.' % SLACK_DEFAULT_USER)
            self.user = SLACK_DEFAULT_USER

        if compat_is_basestring(channels):
            self.channels = [x for x in filter(bool, CHANNEL_LIST_DELIM.split(
                channels,
            ))]

        elif isinstance(channels, (set, tuple, list)):
            self.channels = channels

        else:
            self.channels = list()

        if len(self.channels) == 0:
            self.logger.warning('No channel(s) were specified.')
            raise TypeError('No channel(s) were specified.')

        # Formatting requirements are defined here:
        # https://api.slack.com/docs/message-formatting
        self._re_formatting_map = {
            # New lines must become the string version
            '\r\*\n': '\\n',
            # Escape other special characters
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
        }

        # Iterate over above list and store content accordingly
        self._re_formatting_rules = re.compile(
            r'(' + '|'.join(self._re_formatting_map.keys()) + r')',
            re.IGNORECASE,
        )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Slack Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        notify_okay = True

        # Perform Formatting
        title = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], title,
        )
        body = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], body,
        )
        url = '%s/%s/%s/%s' % (
            self.notify_url,
            self.token_a,
            self.token_b,
            self.token_c,
        )

        image_url = self.image_url(notify_type)

        # Create a copy of the channel list
        channels = list(self.channels)
        while len(channels):
            channel = channels.pop(0)
            if not IS_CHANNEL_RE.match(channel):
                self.logger.warning(
                    ""The specified channel '%s' is invalid; skipping."" % (
                        channel,
                    )
                )
                continue

            if len(channel) > 1 and channel[0] == '+':
                # Treat as encoded id if prefixed with a +
                _channel = channel[1:]

            elif len(channel) > 1 and channel[0] == '@':
                # Treat @ value 'as is'
                _channel = channel

            else:
                # Prefix with channel hash tag
                _channel = '#%s' % channel

            # prepare JSON Object
            payload = {
                'channel': _channel,
                'username': self.user,
                # Use Markdown language
                'mrkdwn': True,
                'attachments': [{
                    'title': title,
                    'text': body,
                    'color': self.asset.html_color(notify_type),
                    # Time
                    'ts': time(),
                    'footer': self.app_id,
                }],
            }

            if image_url:
                payload['attachments'][0]['footer_icon'] = image_url

            self.logger.debug('Slack POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Slack Payload: %s' % str(payload))
            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification: %s (error=%s).' % (
                                channel,
                                SLACK_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except KeyError:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification (error=%s).' % (
                                channel,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    notify_okay = False

            except requests.RequestException as e:
                self.logger.warning(
                    'A Connection error occured sending Slack:%s ' % (
                        channel) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                notify_okay = False

            if len(channels):
                # Prevent thrashing requests
                self.throttle()

        return notify_okay

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostnamee
        token_a = results['host']

        # Now fetch the remaining tokens
        try:
            token_b, token_c = [x for x in filter(
                bool, NotifyBase.split_path(results['fullpath']))][0:2]

        except (ValueError, AttributeError, IndexError):
            # We're done
            return None

        channels = [x for x in filter(
            bool, NotifyBase.split_path(results['fullpath']))][2:]

        results['token_a'] = token_a
        results['token_b'] = token_b
        results['token_c'] = token_c
        results['channels'] = channels

        return results
","@@ -22,7 +22,7 @@
 # follow the wizard to pre-determine the channel(s) you want your
 # message to broadcast to, and when you're complete, you will
 # recieve a URL that looks something like this:
-# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7F
+# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ
 #                                     ^         ^               ^
 #                                     |         |               |
 #  These are important <--------------^---------^---------------^
@@ -59,11 +59,11 @@ SLACK_HTTP_ERROR_MAP.update({
     401: 'Unauthorized - Invalid Token.',
 })
 
-# Used to break path apart into list of devices
+# Used to break path apart into list of channels
 CHANNEL_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')
 
-# Used to detect a device
-IS_CHANNEL_RE = re.compile(r'#?([A-Za-z0-9_]{1,32})')
+# Used to detect a channel
+IS_CHANNEL_RE = re.compile(r'[+#@]?([A-Z0-9_]{1,32})', re.I)
 
 # Image Support (72x72)
 SLACK_IMAGE_XY = NotifyImageSize.XY_72
@@ -127,11 +127,13 @@ class NotifySlack(NotifyBase):
             self.user = SLACK_DEFAULT_USER
 
         if compat_is_basestring(channels):
-            self.channels = filter(bool, CHANNEL_LIST_DELIM.split(
+            self.channels = [x for x in filter(bool, CHANNEL_LIST_DELIM.split(
                 channels,
-            ))
+            ))]
+
         elif isinstance(channels, (set, tuple, list)):
             self.channels = channels
+
         else:
             self.channels = list()
 
@@ -167,13 +169,13 @@ class NotifySlack(NotifyBase):
         }
 
         # error tracking (used for function return)
-        has_error = False
+        notify_okay = True
 
         # Perform Formatting
-        title = self._re_formatting_rules.sub(
+        title = self._re_formatting_rules.sub(  # pragma: no branch
             lambda x: self._re_formatting_map[x.group()], title,
         )
-        body = self._re_formatting_rules.sub(
+        body = self._re_formatting_rules.sub(  # pragma: no branch
             lambda x: self._re_formatting_map[x.group()], body,
         )
         url = '%s/%s/%s/%s' % (
@@ -183,11 +185,7 @@ class NotifySlack(NotifyBase):
             self.token_c,
         )
 
-        image_url = None
-        if self.include_image:
-            image_url = self.image_url(
-                notify_type,
-            )
+        image_url = self.image_url(notify_type)
 
         # Create a copy of the channel list
         channels = list(self.channels)
@@ -204,9 +202,11 @@ class NotifySlack(NotifyBase):
             if len(channel) > 1 and channel[0] == '+':
                 # Treat as encoded id if prefixed with a +
                 _channel = channel[1:]
+
             elif len(channel) > 1 and channel[0] == '@':
                 # Treat @ value 'as is'
                 _channel = channel
+
             else:
                 # Prefix with channel hash tag
                 _channel = '#%s' % channel
@@ -220,7 +220,7 @@ class NotifySlack(NotifyBase):
                 'attachments': [{
                     'title': title,
                     'text': body,
-                    'color': self.asset.html_color[notify_type],
+                    'color': self.asset.html_color(notify_type),
                     # Time
                     'ts': time(),
                     'footer': self.app_id,
@@ -251,7 +251,7 @@ class NotifySlack(NotifyBase):
                                 SLACK_HTTP_ERROR_MAP[r.status_code],
                                 r.status_code))
 
-                    except IndexError:
+                    except KeyError:
                         self.logger.warning(
                             'Failed to send Slack:%s '
                             'notification (error=%s).' % (
@@ -261,21 +261,21 @@ class NotifySlack(NotifyBase):
                     # self.logger.debug('Response Details: %s' % r.raw.read())
 
                     # Return; we're done
-                    has_error = True
+                    notify_okay = False
 
-            except requests.ConnectionError as e:
+            except requests.RequestException as e:
                 self.logger.warning(
                     'A Connection error occured sending Slack:%s ' % (
                         channel) + 'notification.'
                 )
                 self.logger.debug('Socket Exception: %s' % str(e))
-                has_error = True
+                notify_okay = False
 
             if len(channels):
                 # Prevent thrashing requests
                 self.throttle()
 
-        return has_error
+        return notify_okay
 
     @staticmethod
     def parse_url(url):
@@ -297,23 +297,15 @@ class NotifySlack(NotifyBase):
 
         # Now fetch the remaining tokens
         try:
-            token_b, token_c = filter(
-                bool, NotifyBase.split_path(results['fullpath']))[0:2]
+            token_b, token_c = [x for x in filter(
+                bool, NotifyBase.split_path(results['fullpath']))][0:2]
 
-        except (AttributeError, IndexError):
-            # Force some bad values that will get caught
-            # in parsing later
-            token_b = None
-            token_c = None
-
-        try:
-            channels = '#'.join(filter(
-                bool, NotifyBase.split_path(results['fullpath']))[2:])
+        except (ValueError, AttributeError, IndexError):
+            # We're done
+            return None
 
-        except (AttributeError, IndexError):
-            # Force some bad values that will get caught
-            # in parsing later
-            channels = None
+        channels = [x for x in filter(
+            bool, NotifyBase.split_path(results['fullpath']))][2:]
 
         results['token_a'] = token_a
         results['token_b'] = token_b
",add more info about slack notifications,0.45,2,-8
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyTelegram.py,"# -*- coding: utf-8 -*-
#
# Telegram Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.telegram.org
# You need to create a bot and acquire it's Token Identifier (bot_token)
#
# Basically you need to create a chat with a user called the 'BotFather'
# and type: /newbot
#
# Then follow through the wizard, it will provide you an api key
# that looks like this:123456789:alphanumeri_characters
#
# For each chat_id a bot joins will have a chat_id associated with it.
# You will need this value as well to send the notification.
#
# Log into the webpage version of the site if you like by accessing:
#    https://web.telegram.org
#
# You can't check out to see if your entry is working using:
#    https://api.telegram.org/botAPI_KEY/getMe
#
#    Pay attention to the word 'bot' that must be present infront of your
#    api key that the BotFather gave you.
#
#  For example, a url might look like this:
#    https://api.telegram.org/bot123456789:alphanumeri_characters/getMe
#
import requests
import re

from json import loads
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import NotifyFormat
from .NotifyBase import HTTP_ERROR_MAP

from ..utils import compat_is_basestring

# Token required as part of the API request
# allow the word 'bot' infront
VALIDATE_BOT_TOKEN = re.compile(
    r'(bot)?(?P<key>[0-9]+:[A-Za-z0-9_-]+)/*$',
    re.IGNORECASE,
)

# Chat ID is required
# If the Chat ID is positive, then it's addressed to a single person
# If the Chat ID is negative, then it's targeting a group
IS_CHAT_ID_RE = re.compile(
    r'(@*(?P<idno>-?[0-9]{1,32})|(?P<name>[a-z_-][a-z0-9_-]*))',
    re.IGNORECASE,
)

# Disable image support for now
# The stickers/images are kind of big and consume a lot of space
# It's not as appealing as just having the post not contain
# an image at all.
TELEGRAM_IMAGE_XY = None

# Used to break path apart into list of chat identifiers
CHAT_ID_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')


class NotifyTelegram(NotifyBase):
    """"""
    A wrapper for Telegram Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'tgram'

    # Telegram uses the http protocol with JSON requests
    notify_url = 'https://api.telegram.org/bot'

    def __init__(self, bot_token, chat_ids, **kwargs):
        """"""
        Initialize Telegram Object
        """"""
        super(NotifyTelegram, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            image_size=TELEGRAM_IMAGE_XY, **kwargs)

        if bot_token is None:
            raise TypeError(
                'The Bot Token specified is invalid.'
            )

        result = VALIDATE_BOT_TOKEN.match(bot_token.strip())
        if not result:
            raise TypeError(
                'The Bot Token specified (%s) is invalid.' % bot_token,
            )

        # Store our API Key
        self.bot_token = result.group('key')

        if compat_is_basestring(chat_ids):
            self.chat_ids = filter(bool, CHAT_ID_LIST_DELIM.split(
                chat_ids,
            ))

        elif isinstance(chat_ids, (set, tuple, list)):
            self.chat_ids = list(chat_ids)

        else:
            self.chat_ids = list()

        if self.user:
            # Treat this as a channel too
            self.chat_ids.append(self.user)

        # Bot's can't send messages to themselves which is fair enough
        # but if or when they can, this code will allow a default fallback
        # solution if no chat_id and/or channel is specified
        # if len(self.chat_ids) == 0:
        #
        #     chat_id = self._get_chat_id()
        #     if chat_id is not None:
        #         self.logger.warning(
        #             'No chat_id or @channel was specified; ' +\
        #             'using detected bot_chat_id (%d).' % chat_id,
        #         )
        #         self.chat_ids.append(str(chat_id))

        if len(self.chat_ids) == 0:
            self.logger.warning('No chat_id(s) were specified.')
            raise TypeError('No chat_id(s) were specified.')

    def _get_chat_id(self):
        """"""
        This function retrieves the chat id belonging to the key specified
        """"""
        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'getMe'
        )

        self.logger.debug('Telegram (Detection) GET URL: %s' % url)

        chat_id = None
        try:
            r = requests.post(url, headers=headers)
            if r.status_code == requests.codes.ok:
                # Extract our chat ID
                result = loads(r.text)
                if result.get('ok', False) is True:
                    chat_id = result['result'].get('id')
                    if chat_id <= 0:
                        chat_id = None
            else:
                # We had a problem
                try:
                    # Try to get the error message if we can:
                    error_msg = loads(r.text)['description']

                except:
                    error_msg = None

                try:
                    if error_msg:
                        self.logger.warning(
                            'Failed to lookup Telegram chat_id from '
                            'apikey: (%s) %s.' % (r.status_code, error_msg))

                    else:
                        self.logger.warning(
                            'Failed to lookup Telegram chat_id from '
                            'apikey: %s (error=%s).' % (
                                HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to lookup Telegram chat_id from '
                        'apikey: (error=%s).' % r.status_code)

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured looking up Telegram chat_id '
                'from apikey.')
            self.logger.debug('Socket Exception: %s' % str(e))

        return chat_id

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Telegram Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        has_error = False

        image_url = None
        if self.include_image:
            image_content = self.image_raw(notify_type)
            if image_content is not None:
                # prepare our image URL
                image_url = '%s%s/%s' % (
                    self.notify_url,
                    self.bot_token,
                    'sendPhoto'
                )

                # Set up our upload
                files = {'photo': ('%s.png' % notify_type, image_content)}

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'sendMessage'
        )

        payload = {}

        if self.notify_format == NotifyFormat.HTML:
            # HTML
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (title, body)

        else:
            # Text
            # payload['parse_mode'] = 'Markdown'
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (
                NotifyBase.escape_html(title),
                NotifyBase.escape_html(body),
            )

        # Create a copy of the chat_ids list
        chat_ids = list(self.chat_ids)
        while len(chat_ids):
            chat_id = chat_ids.pop(0)
            chat_id = IS_CHAT_ID_RE.match(chat_id)
            if not chat_id:
                self.logger.warning(
                    ""The specified chat_id '%s' is invalid; skipping."" % (
                        chat_id,
                    )
                )
                continue

            if chat_id.group('name') is not None:
                # Name
                payload['chat_id'] = '@%s' % chat_id.group('name')

            else:
                # ID
                payload['chat_id'] = chat_id.group('idno')

            if image_url is not None:
                image_payload = {
                    'chat_id': payload['chat_id'],
                    'disable_notification': True,
                }

                self.logger.debug(
                    'Telegram (image) POST URL: %s (cert_verify=%r)' % (
                        image_url, self.verify_certificate))

                self.logger.debug(
                    'Telegram (image) Payload: %s' % str(image_payload))

                try:
                    r = requests.post(
                        image_url,
                        data=image_payload,
                        headers={
                            'User-Agent': self.app_id,
                        },
                        files=files,
                        verify=self.verify_certificate,
                    )
                    if r.status_code != requests.codes.ok:
                        # We had a problem

                        try:
                            # Try to get the error message if we can:
                            error_msg = loads(r.text)['description']
                        except:
                            error_msg = None

                        try:
                            if error_msg:
                                self.logger.warning(
                                    'Failed to send Telegram Image:%s '
                                    'notification: (%s) %s.' % (
                                        payload['chat_id'],
                                        r.status_code, error_msg))

                            else:
                                self.logger.warning(
                                    'Failed to send Telegram Image:%s '
                                    'notification: %s (error=%s).' % (
                                        payload['chat_id'],
                                        HTTP_ERROR_MAP[r.status_code],
                                        r.status_code))

                        except IndexError:
                            self.logger.warning(
                                'Failed to send Telegram Image:%s '
                                'notification (error=%s).' % (
                                    payload['chat_id'],
                                    r.status_code))

                        has_error = True
                        continue

                except requests.ConnectionError as e:
                    self.logger.warning(
                        'A Connection error occured sending Telegram:%s ' % (
                            payload['chat_id']) + 'notification.'
                    )
                    self.logger.debug('Socket Exception: %s' % str(e))
                    has_error = True
                    continue

            self.logger.debug('Telegram POST URL: %s' % url)
            self.logger.debug('Telegram POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Telegram Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem

                    try:
                        # Try to get the error message if we can:
                        error_msg = loads(r.text)['description']
                    except:
                        error_msg = None

                    try:
                        if error_msg:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: (%s) %s.' % (
                                    payload['chat_id'],
                                    r.status_code, error_msg))

                        else:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: %s (error=%s).' % (
                                    payload['chat_id'],
                                    HTTP_ERROR_MAP[r.status_code],
                                    r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Telegram:%s '
                            'notification (error=%s).' % (
                                payload['chat_id'], r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Telegram:%s ' % (
                        payload['chat_id']) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(chat_ids):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        # super() is formatted slightly different when dealing with
        # static method inheritance
        results = NotifyBase.parse_url(url)

        if results:
            # We're done early
            return results

        # This is a dirty hack; but it's the only work around to
        # tgram:// messages since the bot_token has a colon in it.
        # It invalidates an normal URL.

        # This hack searches for this bogus URL and corrects it
        # so we can properly load it further down. The other
        # alternative is to ask users to actually change the colon
        # into a slash (which will work too), but it's more likely
        # to cause confusion... So this is the next best thing
        tgram = re.match(
            r'(?P<protocol>%s://)(bot)?(?P<prefix>([a-z0-9_-]+)'
            r'(:[a-z0-9_-]+)?@)?(?P<btoken_a>[0-9]+):+'
            r'(?P<remaining>.*)$' % 'tgram',
            url, re.I)

        if not tgram:
            # Content is simply not parseable
            return None

        if tgram.group('prefix'):
            # Try again
            result = NotifyBase.parse_url(
                '%s%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('prefix'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        else:
            # Try again
            result = NotifyBase.parse_url(
                '%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        # The first token is stored in the hostnamee
        bot_token_a = result['host']

        # Now fetch the remaining tokens
        try:
            bot_token_b = filter(
                bool, NotifyBase.split_path(result['fullpath']))[0]

            bot_token = '%s:%s' % (bot_token_a, bot_token_b)

        except (AttributeError, IndexError):
            # Force a bad value that will get caught in parsing later
            bot_token = None

        try:
            chat_ids = ','.join(
                filter(bool, NotifyBase.split_path(result['fullpath']))[1:])

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            chat_ids = None

        # Return our results
        return result + {
            'bot_token': bot_token,
            'chat_ids': chat_ids,
        }.items()
","# -*- coding: utf-8 -*-
#
# Telegram Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.telegram.org
# You need to create a bot and acquire it's Token Identifier (bot_token)
#
# Basically you need to create a chat with a user called the 'BotFather'
# and type: /newbot
#
# Then follow through the wizard, it will provide you an api key
# that looks like this:123456789:alphanumeri_characters
#
# For each chat_id a bot joins will have a chat_id associated with it.
# You will need this value as well to send the notification.
#
# Log into the webpage version of the site if you like by accessing:
#    https://web.telegram.org
#
# You can't check out to see if your entry is working using:
#    https://api.telegram.org/botAPI_KEY/getMe
#
#    Pay attention to the word 'bot' that must be present infront of your
#    api key that the BotFather gave you.
#
#  For example, a url might look like this:
#    https://api.telegram.org/bot123456789:alphanumeri_characters/getMe
#
import requests
import re

from json import loads
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import NotifyFormat
from .NotifyBase import HTTP_ERROR_MAP

from ..utils import compat_is_basestring

# Token required as part of the API request
# allow the word 'bot' infront
VALIDATE_BOT_TOKEN = re.compile(
    r'(bot)?(?P<key>[0-9]+:[A-Za-z0-9_-]+)/*$',
    re.IGNORECASE,
)

# Chat ID is required
# If the Chat ID is positive, then it's addressed to a single person
# If the Chat ID is negative, then it's targeting a group
IS_CHAT_ID_RE = re.compile(
    r'(@*(?P<idno>-?[0-9]{1,32})|(?P<name>[a-z_-][a-z0-9_-]*))',
    re.IGNORECASE,
)

# Disable image support for now
# The stickers/images are kind of big and consume a lot of space
# It's not as appealing as just having the post not contain
# an image at all.
TELEGRAM_IMAGE_XY = None

# Used to break path apart into list of chat identifiers
CHAT_ID_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')


class NotifyTelegram(NotifyBase):
    """"""
    A wrapper for Telegram Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'tgram'

    # Telegram uses the http protocol with JSON requests
    notify_url = 'https://api.telegram.org/bot'

    def __init__(self, bot_token, chat_ids, **kwargs):
        """"""
        Initialize Telegram Object
        """"""
        super(NotifyTelegram, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            image_size=TELEGRAM_IMAGE_XY, **kwargs)

        if bot_token is None:
            raise TypeError(
                'The Bot Token specified is invalid.'
            )

        result = VALIDATE_BOT_TOKEN.match(bot_token.strip())
        if not result:
            raise TypeError(
                'The Bot Token specified (%s) is invalid.' % bot_token,
            )

        # Store our API Key
        self.bot_token = result.group('key')

        if compat_is_basestring(chat_ids):
            self.chat_ids = filter(bool, CHAT_ID_LIST_DELIM.split(
                chat_ids,
            ))

        elif isinstance(chat_ids, (set, tuple, list)):
            self.chat_ids = list(chat_ids)

        else:
            self.chat_ids = list()

        if self.user:
            # Treat this as a channel too
            self.chat_ids.append(self.user)

        # Bot's can't send messages to themselves which is fair enough
        # but if or when they can, this code will allow a default fallback
        # solution if no chat_id and/or channel is specified
        # if len(self.chat_ids) == 0:
        #
        #     chat_id = self._get_chat_id()
        #     if chat_id is not None:
        #         self.logger.warning(
        #             'No chat_id or @channel was specified; ' +\
        #             'using detected bot_chat_id (%d).' % chat_id,
        #         )
        #         self.chat_ids.append(str(chat_id))

        if len(self.chat_ids) == 0:
            self.logger.warning('No chat_id(s) were specified.')
            raise TypeError('No chat_id(s) were specified.')

    def _get_chat_id(self):
        """"""
        This function retrieves the chat id belonging to the key specified
        """"""
        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'getMe'
        )

        self.logger.debug('Telegram (Detection) GET URL: %s' % url)

        chat_id = None
        try:
            r = requests.post(url, headers=headers)
            if r.status_code == requests.codes.ok:
                # Extract our chat ID
                result = loads(r.text)
                if result.get('ok', False) is True:
                    chat_id = result['result'].get('id')
                    if chat_id <= 0:
                        chat_id = None
            else:
                # We had a problem
                try:
                    # Try to get the error message if we can:
                    error_msg = loads(r.text)['description']

                except:
                    error_msg = None

                try:
                    if error_msg:
                        self.logger.warning(
                            'Failed to lookup Telegram chat_id from '
                            'apikey: (%s) %s.' % (r.status_code, error_msg))

                    else:
                        self.logger.warning(
                            'Failed to lookup Telegram chat_id from '
                            'apikey: %s (error=%s).' % (
                                HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                except IndexError:
                    self.logger.warning(
                        'Failed to lookup Telegram chat_id from '
                        'apikey: (error=%s).' % r.status_code)

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured looking up Telegram chat_id '
                'from apikey.')
            self.logger.debug('Socket Exception: %s' % str(e))

        return chat_id

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Telegram Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        has_error = False

        image_url = None
        image_content = self.image_raw(notify_type)
        if image_content is not None:
            # prepare our image URL
            image_url = '%s%s/%s' % (
                self.notify_url,
                self.bot_token,
                'sendPhoto'
            )

            # Set up our upload
            files = {'photo': ('%s.png' % notify_type, image_content)}

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'sendMessage'
        )

        payload = {}

        if self.notify_format == NotifyFormat.HTML:
            # HTML
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (title, body)

        else:
            # Text
            # payload['parse_mode'] = 'Markdown'
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (
                NotifyBase.escape_html(title),
                NotifyBase.escape_html(body),
            )

        # Create a copy of the chat_ids list
        chat_ids = list(self.chat_ids)
        while len(chat_ids):
            chat_id = chat_ids.pop(0)
            chat_id = IS_CHAT_ID_RE.match(chat_id)
            if not chat_id:
                self.logger.warning(
                    ""The specified chat_id '%s' is invalid; skipping."" % (
                        chat_id,
                    )
                )
                continue

            if chat_id.group('name') is not None:
                # Name
                payload['chat_id'] = '@%s' % chat_id.group('name')

            else:
                # ID
                payload['chat_id'] = chat_id.group('idno')

            if image_url is not None:
                image_payload = {
                    'chat_id': payload['chat_id'],
                    'disable_notification': True,
                }

                self.logger.debug(
                    'Telegram (image) POST URL: %s (cert_verify=%r)' % (
                        image_url, self.verify_certificate))

                self.logger.debug(
                    'Telegram (image) Payload: %s' % str(image_payload))

                try:
                    r = requests.post(
                        image_url,
                        data=image_payload,
                        headers={
                            'User-Agent': self.app_id,
                        },
                        files=files,
                        verify=self.verify_certificate,
                    )
                    if r.status_code != requests.codes.ok:
                        # We had a problem

                        try:
                            # Try to get the error message if we can:
                            error_msg = loads(r.text)['description']
                        except:
                            error_msg = None

                        try:
                            if error_msg:
                                self.logger.warning(
                                    'Failed to send Telegram Image:%s '
                                    'notification: (%s) %s.' % (
                                        payload['chat_id'],
                                        r.status_code, error_msg))

                            else:
                                self.logger.warning(
                                    'Failed to send Telegram Image:%s '
                                    'notification: %s (error=%s).' % (
                                        payload['chat_id'],
                                        HTTP_ERROR_MAP[r.status_code],
                                        r.status_code))

                        except IndexError:
                            self.logger.warning(
                                'Failed to send Telegram Image:%s '
                                'notification (error=%s).' % (
                                    payload['chat_id'],
                                    r.status_code))

                        has_error = True
                        continue

                except requests.ConnectionError as e:
                    self.logger.warning(
                        'A Connection error occured sending Telegram:%s ' % (
                            payload['chat_id']) + 'notification.'
                    )
                    self.logger.debug('Socket Exception: %s' % str(e))
                    has_error = True
                    continue

            self.logger.debug('Telegram POST URL: %s' % url)
            self.logger.debug('Telegram POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Telegram Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem

                    try:
                        # Try to get the error message if we can:
                        error_msg = loads(r.text)['description']
                    except:
                        error_msg = None

                    try:
                        if error_msg:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: (%s) %s.' % (
                                    payload['chat_id'],
                                    r.status_code, error_msg))

                        else:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: %s (error=%s).' % (
                                    payload['chat_id'],
                                    HTTP_ERROR_MAP[r.status_code],
                                    r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Telegram:%s '
                            'notification (error=%s).' % (
                                payload['chat_id'], r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Telegram:%s ' % (
                        payload['chat_id']) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(chat_ids):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        # super() is formatted slightly different when dealing with
        # static method inheritance
        results = NotifyBase.parse_url(url)

        if results:
            # We're done early
            return results

        # This is a dirty hack; but it's the only work around to
        # tgram:// messages since the bot_token has a colon in it.
        # It invalidates an normal URL.

        # This hack searches for this bogus URL and corrects it
        # so we can properly load it further down. The other
        # alternative is to ask users to actually change the colon
        # into a slash (which will work too), but it's more likely
        # to cause confusion... So this is the next best thing
        tgram = re.match(
            r'(?P<protocol>%s://)(bot)?(?P<prefix>([a-z0-9_-]+)'
            r'(:[a-z0-9_-]+)?@)?(?P<btoken_a>[0-9]+):+'
            r'(?P<remaining>.*)$' % 'tgram',
            url, re.I)

        if not tgram:
            # Content is simply not parseable
            return None

        if tgram.group('prefix'):
            # Try again
            result = NotifyBase.parse_url(
                '%s%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('prefix'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        else:
            # Try again
            result = NotifyBase.parse_url(
                '%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        # The first token is stored in the hostnamee
        bot_token_a = result['host']

        # Now fetch the remaining tokens
        try:
            bot_token_b = filter(
                bool, NotifyBase.split_path(result['fullpath']))[0]

            bot_token = '%s:%s' % (bot_token_a, bot_token_b)

        except (AttributeError, IndexError):
            # Force a bad value that will get caught in parsing later
            bot_token = None

        try:
            chat_ids = ','.join(
                filter(bool, NotifyBase.split_path(result['fullpath']))[1:])

        except (AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            chat_ids = None

        # Return our results
        return result + {
            'bot_token': bot_token,
            'chat_ids': chat_ids,
        }.items()
","@@ -218,18 +218,17 @@ class NotifyTelegram(NotifyBase):
         has_error = False
 
         image_url = None
-        if self.include_image:
-            image_content = self.image_raw(notify_type)
-            if image_content is not None:
-                # prepare our image URL
-                image_url = '%s%s/%s' % (
-                    self.notify_url,
-                    self.bot_token,
-                    'sendPhoto'
-                )
+        image_content = self.image_raw(notify_type)
+        if image_content is not None:
+            # prepare our image URL
+            image_url = '%s%s/%s' % (
+                self.notify_url,
+                self.bot_token,
+                'sendPhoto'
+            )
 
-                # Set up our upload
-                files = {'photo': ('%s.png' % notify_type, image_content)}
+            # Set up our upload
+            files = {'photo': ('%s.png' % notify_type, image_content)}
 
         url = '%s%s/%s' % (
             self.notify_url,
",add missing tag,0.21,-1,-1
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyToasty.py,"# -*- coding: utf-8 -*-
#
# (Super) Toasty Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
TOASTY_IMAGE_XY = NotifyImageSize.XY_128

# Used to break apart list of potential devices by their delimiter
# into a usable list.
DEVICES_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyToasty(NotifyBase):
    """"""
    A wrapper for Toasty Notifications
    """"""

    # The default protocol
    protocol = 'toasty'

    # Toasty uses the http protocol with JSON requests
    notify_url = 'http://api.supertoasty.com/notify/'

    def __init__(self, devices, **kwargs):
        """"""
        Initialize Toasty Object
        """"""
        super(NotifyToasty, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=TOASTY_IMAGE_XY,
            **kwargs)

        if compat_is_basestring(devices):
            self.devices = filter(bool, DEVICES_LIST_DELIM.split(
                devices,
            ))

        elif isinstance(devices, (tuple, list)):
            self.devices = devices

        else:
            raise TypeError('You must specify at least 1 device.')

        if not self.user:
            raise TypeError('You must specify a username.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Toasty Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'multipart/form-data',
        }

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the devices list
        devices = list(self.devices)
        while len(devices):
            device = devices.pop(0)

            # prepare JSON Object
            payload = {
                'sender': NotifyBase.quote(self.user),
                'title': NotifyBase.quote(title),
                'text': NotifyBase.quote(body),
            }

            if self.include_image:
                image_url = self.image_url(
                    notify_type,
                )
                if image_url:
                    payload['image'] = image_url

            # URL to transmit content via
            url = '%s%s' % (self.notify_url, device)

            self.logger.debug('Toasty POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Toasty Payload: %s' % str(payload))
            try:
                r = requests.get(
                    url,
                    data=payload,
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Toasty:%s '
                            'notification: %s (error=%s).' % (
                                device,
                                HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Toasty:%s '
                            'notification (error=%s).' % (
                                device,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Toasty:%s ' % (
                        device) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(devices):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            devices = NotifyBase.unquote(results['fullpath'])

        except AttributeError:
            devices = ''

        # Store our devices
        results['devices'] = '%s/%s' % (results['host'], devices)

        return results
","# -*- coding: utf-8 -*-
#
# (Super) Toasty Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
TOASTY_IMAGE_XY = NotifyImageSize.XY_128

# Used to break apart list of potential devices by their delimiter
# into a usable list.
DEVICES_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyToasty(NotifyBase):
    """"""
    A wrapper for Toasty Notifications
    """"""

    # The default protocol
    protocol = 'toasty'

    # Toasty uses the http protocol with JSON requests
    notify_url = 'http://api.supertoasty.com/notify/'

    def __init__(self, devices, **kwargs):
        """"""
        Initialize Toasty Object
        """"""
        super(NotifyToasty, self).__init__(
            title_maxlen=250, body_maxlen=32768, image_size=TOASTY_IMAGE_XY,
            **kwargs)

        if compat_is_basestring(devices):
            self.devices = filter(bool, DEVICES_LIST_DELIM.split(
                devices,
            ))

        elif isinstance(devices, (tuple, list)):
            self.devices = devices

        else:
            raise TypeError('You must specify at least 1 device.')

        if not self.user:
            raise TypeError('You must specify a username.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Toasty Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'multipart/form-data',
        }

        # error tracking (used for function return)
        has_error = False

        # Create a copy of the devices list
        devices = list(self.devices)
        while len(devices):
            device = devices.pop(0)

            # prepare JSON Object
            payload = {
                'sender': NotifyBase.quote(self.user),
                'title': NotifyBase.quote(title),
                'text': NotifyBase.quote(body),
            }

            image_url = self.image_url(notify_type)
            if image_url:
                payload['image'] = image_url

            # URL to transmit content via
            url = '%s%s' % (self.notify_url, device)

            self.logger.debug('Toasty POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Toasty Payload: %s' % str(payload))
            try:
                r = requests.get(
                    url,
                    data=payload,
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Toasty:%s '
                            'notification: %s (error=%s).' % (
                                device,
                                HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except IndexError:
                        self.logger.warning(
                            'Failed to send Toasty:%s '
                            'notification (error=%s).' % (
                                device,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    has_error = True

            except requests.ConnectionError as e:
                self.logger.warning(
                    'A Connection error occured sending Toasty:%s ' % (
                        device) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            if len(devices):
                # Prevent thrashing requests
                self.throttle()

        return has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        try:
            devices = NotifyBase.unquote(results['fullpath'])

        except AttributeError:
            devices = ''

        # Store our devices
        results['devices'] = '%s/%s' % (results['host'], devices)

        return results
","@@ -90,12 +90,9 @@ class NotifyToasty(NotifyBase):
                 'text': NotifyBase.quote(body),
             }
 
-            if self.include_image:
-                image_url = self.image_url(
-                    notify_type,
-                )
-                if image_url:
-                    payload['image'] = image_url
+            image_url = self.image_url(notify_type)
+            if image_url:
+                payload['image'] = image_url
 
             # URL to transmit content via
             url = '%s%s' % (self.notify_url, device)
",add image to notifytoasty,0.34,-1,-3
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyXBMC.py,"# -*- coding: utf-8 -*-
#
# XBMC Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize

# Image Support (128x128)
XBMC_IMAGE_XY = NotifyImageSize.XY_128

# XBMC uses v2
XBMC_PROTOCOL_V2 = 2

# Kodi uses v6
XBMC_PROTOCOL_V6 = 6

SUPPORTED_XBMC_PROTOCOLS = (
    XBMC_PROTOCOL_V2,
    XBMC_PROTOCOL_V6,
)


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    default_port = 8080

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XBMC_IMAGE_XY, **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        if not self.port:
            self.port = self.default_port

        self.protocol = kwargs.get('protocol', XBMC_PROTOCOL_V2)
        if self.protocol not in SUPPORTED_XBMC_PROTOCOLS:
            raise TypeError(""Invalid protocol specified."")

        return

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '6.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        if self.include_image:
            image_url = self.image_url(
                notify_type,
            )
            if image_url:
                payload['image'] = image_url
                if notify_type is NotifyType.Error:
                    payload['type'] = 'error'
                elif notify_type is NotifyType.Warning:
                    payload['type'] = 'warning'
                else:
                    payload['type'] = 'info'

        return (headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        if self.include_image:
            image_url = self.image_url(
                notify_type,
            )
            if image_url:
                payload['image'] = image_url

        return (headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == XBMC_PROTOCOL_V2:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # XBMC v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True
","# -*- coding: utf-8 -*-
#
# XBMC/KODI Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize

# Image Support (128x128)
XBMC_IMAGE_XY = NotifyImageSize.XY_128


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    xbmc_default_port = 8080

    # XBMC default protocol version (v2)
    xbmc_remote_protocol = 2

    # KODI default protocol version (v6)
    kodi_remote_protocol = 6

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XBMC_IMAGE_XY, **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Default protocol
        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '6.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url
            if notify_type is NotifyType.FAILURE:
                payload['type'] = 'error'

            elif notify_type is NotifyType.WARNING:
                payload['type'] = 'warning'

            else:
                payload['type'] = 'info'

        return (headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url

        return (headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC/KODI Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == self.xbmc_remote_protocol:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # KODI v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if self.port:
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)
        if not results:
            # We're done early
            return results

        # We want to set our protocol depending on whether we're using XBMC
        # or KODI
        if results.get('schema', '').startswith('xbmc'):
            # XBMC Support
            results['protocol'] = NotifyXBMC.xbmc_remote_protocol

            # Assign Default XBMC Port
            if not results['port']:
                results['port'] = NotifyXBMC.xbmc_default_port

        else:
            # KODI Support
            results['protocol'] = NotifyXBMC.kodi_remote_protocol

        return results
","@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 #
-# XBMC Notify Wrapper
+# XBMC/KODI Notify Wrapper
 #
 # Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
 #
@@ -28,17 +28,6 @@ from ..common import NotifyImageSize
 # Image Support (128x128)
 XBMC_IMAGE_XY = NotifyImageSize.XY_128
 
-# XBMC uses v2
-XBMC_PROTOCOL_V2 = 2
-
-# Kodi uses v6
-XBMC_PROTOCOL_V6 = 6
-
-SUPPORTED_XBMC_PROTOCOLS = (
-    XBMC_PROTOCOL_V2,
-    XBMC_PROTOCOL_V6,
-)
-
 
 class NotifyXBMC(NotifyBase):
     """"""
@@ -52,7 +41,13 @@ class NotifyXBMC(NotifyBase):
     secure_protocol = ('xbmc', 'kodis')
 
     # XBMC uses the http protocol with JSON requests
-    default_port = 8080
+    xbmc_default_port = 8080
+
+    # XBMC default protocol version (v2)
+    xbmc_remote_protocol = 2
+
+    # KODI default protocol version (v6)
+    kodi_remote_protocol = 6
 
     def __init__(self, **kwargs):
         """"""
@@ -68,14 +63,8 @@ class NotifyXBMC(NotifyBase):
         else:
             self.schema = 'http'
 
-        if not self.port:
-            self.port = self.default_port
-
-        self.protocol = kwargs.get('protocol', XBMC_PROTOCOL_V2)
-        if self.protocol not in SUPPORTED_XBMC_PROTOCOLS:
-            raise TypeError(""Invalid protocol specified."")
-
-        return
+        # Default protocol
+        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)
 
     def _payload_60(self, title, body, notify_type, **kwargs):
         """"""
@@ -102,18 +91,17 @@ class NotifyXBMC(NotifyBase):
             'id': 1,
         }
 
-        if self.include_image:
-            image_url = self.image_url(
-                notify_type,
-            )
-            if image_url:
-                payload['image'] = image_url
-                if notify_type is NotifyType.Error:
-                    payload['type'] = 'error'
-                elif notify_type is NotifyType.Warning:
-                    payload['type'] = 'warning'
-                else:
-                    payload['type'] = 'info'
+        image_url = self.image_url(notify_type)
+        if image_url:
+            payload['image'] = image_url
+            if notify_type is NotifyType.FAILURE:
+                payload['type'] = 'error'
+
+            elif notify_type is NotifyType.WARNING:
+                payload['type'] = 'warning'
+
+            else:
+                payload['type'] = 'info'
 
         return (headers, dumps(payload))
 
@@ -142,18 +130,15 @@ class NotifyXBMC(NotifyBase):
             'id': 1,
         }
 
-        if self.include_image:
-            image_url = self.image_url(
-                notify_type,
-            )
-            if image_url:
-                payload['image'] = image_url
+        image_url = self.image_url(notify_type)
+        if image_url:
+            payload['image'] = image_url
 
         return (headers, dumps(payload))
 
     def notify(self, title, body, notify_type, **kwargs):
         """"""
-        Perform XBMC Notification
+        Perform XBMC/KODI Notification
         """"""
 
         # Limit results to just the first 2 line otherwise
@@ -162,13 +147,13 @@ class NotifyXBMC(NotifyBase):
         body[0] = body[0].strip('#').strip()
         body = '\r\n'.join(body[0:2])
 
-        if self.protocol == XBMC_PROTOCOL_V2:
+        if self.protocol == self.xbmc_remote_protocol:
             # XBMC v2.0
             (headers, payload) = self._payload_20(
                 title, body, notify_type, **kwargs)
 
         else:
-            # XBMC v6.0
+            # KODI v6.0
             (headers, payload) = self._payload_60(
                 title, body, notify_type, **kwargs)
 
@@ -177,7 +162,7 @@ class NotifyXBMC(NotifyBase):
             auth = (self.user, self.password)
 
         url = '%s://%s' % (self.schema, self.host)
-        if isinstance(self.port, int):
+        if self.port:
             url += ':%d' % self.port
 
         url += '/jsonrpc'
@@ -214,7 +199,7 @@ class NotifyXBMC(NotifyBase):
             else:
                 self.logger.info('Sent XBMC/KODI notification.')
 
-        except requests.ConnectionError as e:
+        except requests.RequestException as e:
             self.logger.warning(
                 'A Connection error occured sending XBMC/KODI '
                 'notification.'
@@ -225,3 +210,31 @@ class NotifyXBMC(NotifyBase):
             return False
 
         return True
+
+    @staticmethod
+    def parse_url(url):
+        """"""
+        Parses the URL and returns enough arguments that can allow
+        us to substantiate this object.
+
+        """"""
+        results = NotifyBase.parse_url(url)
+        if not results:
+            # We're done early
+            return results
+
+        # We want to set our protocol depending on whether we're using XBMC
+        # or KODI
+        if results.get('schema', '').startswith('xbmc'):
+            # XBMC Support
+            results['protocol'] = NotifyXBMC.xbmc_remote_protocol
+
+            # Assign Default XBMC Port
+            if not results['port']:
+                results['port'] = NotifyXBMC.xbmc_default_port
+
+        else:
+            # KODI Support
+            results['protocol'] = NotifyXBMC.kodi_remote_protocol
+
+        return results
",add kodi support to the notify class,0.57,-1,13
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,NotifyXML.py,"# -*- coding: utf-8 -*-
#
# XML Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
XML_IMAGE_XY = NotifyImageSize.XY_128


class NotifyXML(NotifyBase):
    """"""
    A wrapper for XML Notifications
    """"""

    # The default protocol
    protocol = 'xml'

    # The default secure protocol
    secure_protocol = 'xmls'

    def __init__(self, **kwargs):
        """"""
        Initialize XML Object
        """"""
        super(NotifyXML, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XML_IMAGE_XY, **kwargs)

        self.payload = """"""<?xml version='1.0' encoding='utf-8'?>
<soapenv:Envelope
    xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/""
    xmlns:xsd=""http://www.w3.org/2001/XMLSchema""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
    <soapenv:Body>
        <Notification xmlns:xsi=""http://nuxref.com/apprise/NotifyXML-1.0.xsd"">
            <Version>1.0</Version>
            <Subject>{SUBJECT}</Subject>
            <MessageType>{MESSAGE_TYPE}</MessageType>
            <Message>{MESSAGE}</Message>
       </Notification>
    </soapenv:Body>
</soapenv:Envelope>""""""

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        self.fullpath = kwargs.get('fullpath')
        if not compat_is_basestring(self.fullpath):
            self.fullpath = '/'

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XML Notification
        """"""

        # prepare XML Object
        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/xml'
        }

        re_map = {
            '{MESSAGE_TYPE}': NotifyBase.quote(notify_type),
            '{SUBJECT}': NotifyBase.quote(title),
            '{MESSAGE}': NotifyBase.quote(body),
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += self.fullpath
        payload = re_table.sub(lambda x: re_map[x.group()], self.payload)

        self.logger.debug('XML POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XML Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                try:
                    self.logger.warning(
                        'Failed to send XML notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XML notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

        except requests.ConnectionError as e:
            self.logger.warning(
                'A Connection error occured sending XML '
                'notification to %s.' % self.host)
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True
","# -*- coding: utf-8 -*-
#
# XML Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Image Support (128x128)
XML_IMAGE_XY = NotifyImageSize.XY_128


class NotifyXML(NotifyBase):
    """"""
    A wrapper for XML Notifications
    """"""

    # The default protocol
    protocol = 'xml'

    # The default secure protocol
    secure_protocol = 'xmls'

    def __init__(self, **kwargs):
        """"""
        Initialize XML Object
        """"""
        super(NotifyXML, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XML_IMAGE_XY, **kwargs)

        self.payload = """"""<?xml version='1.0' encoding='utf-8'?>
<soapenv:Envelope
    xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/""
    xmlns:xsd=""http://www.w3.org/2001/XMLSchema""
    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
    <soapenv:Body>
        <Notification xmlns:xsi=""http://nuxref.com/apprise/NotifyXML-1.0.xsd"">
            <Version>1.0</Version>
            <Subject>{SUBJECT}</Subject>
            <MessageType>{MESSAGE_TYPE}</MessageType>
            <Message>{MESSAGE}</Message>
       </Notification>
    </soapenv:Body>
</soapenv:Envelope>""""""

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        self.fullpath = kwargs.get('fullpath')
        if not compat_is_basestring(self.fullpath):
            self.fullpath = '/'

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XML Notification
        """"""

        # prepare XML Object
        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/xml'
        }

        re_map = {
            '{MESSAGE_TYPE}': NotifyBase.quote(notify_type),
            '{SUBJECT}': NotifyBase.quote(title),
            '{MESSAGE}': NotifyBase.quote(body),
        }

        # Iterate over above list and store content accordingly
        re_table = re.compile(
            r'(' + '|'.join(re_map.keys()) + r')',
            re.IGNORECASE,
        )

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if isinstance(self.port, int):
            url += ':%d' % self.port

        url += self.fullpath
        payload = re_table.sub(lambda x: re_map[x.group()], self.payload)

        self.logger.debug('XML POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XML Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                try:
                    self.logger.warning(
                        'Failed to send XML notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XML notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XML '
                'notification to %s.' % self.host)
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True
","@@ -136,7 +136,7 @@ class NotifyXML(NotifyBase):
                 # Return; we're done
                 return False
 
-        except requests.ConnectionError as e:
+        except requests.RequestException as e:
             self.logger.warning(
                 'A Connection error occured sending XML '
                 'notification to %s.' % self.host)
",add a warning to the notifyxml class,0.0,0,0
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,utils.py,"# -*- coding: utf-8 -*-
#
# A simple collection of general functions
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import expanduser

try:
    # Python 2.7
    from urllib import unquote
    from urllib import quote
    from urlparse import urlparse
    from urlparse import parse_qsl

except ImportError:
    # Python 3.x
    from urllib.parse import unquote
    from urllib.parse import quote
    from urllib.parse import urlparse
    from urllib.parse import parse_qsl

import logging
logger = logging.getLogger(__name__)

# URL Indexing Table for returns via parse_url()
VALID_URL_RE = re.compile(
    r'^[\s]*(?P<schema>[^:\s]+):[/\\]*(?P<path>[^?]+)'
    r'(\?(?P<kwargs>.+))?[\s]*$',
)
VALID_HOST_RE = re.compile(r'^[\s]*(?P<path>[^?\s]+)(\?(?P<kwargs>.+))?')
VALID_QUERY_RE = re.compile(r'^(?P<path>.*[/\\])(?P<query>[^/\\]*)$')

# delimiters used to separate values when content is passed in by string.
# This is useful when turning a string into a list
STRING_DELIMITERS = r'[\[\]\;,\s]+'

# Pre-Escape content since we reference it so much
ESCAPED_PATH_SEPARATOR = re.escape('\\/')
ESCAPED_WIN_PATH_SEPARATOR = re.escape('\\')
ESCAPED_NUX_PATH_SEPARATOR = re.escape('/')

TIDY_WIN_PATH_RE = re.compile(
    r'(^[%s]{2}|[^%s\s][%s]|[\s][%s]{2}])([%s]+)' % (
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
    ),
)
TIDY_WIN_TRIM_RE = re.compile(
    r'^(.+[^:][^%s])[\s%s]*$' % (
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
    ),
)

TIDY_NUX_PATH_RE = re.compile(
    r'([%s])([%s]+)' % (
        ESCAPED_NUX_PATH_SEPARATOR,
        ESCAPED_NUX_PATH_SEPARATOR,
    ),
)

TIDY_NUX_TRIM_RE = re.compile(
    r'([^%s])[\s%s]+$' % (
        ESCAPED_NUX_PATH_SEPARATOR,
        ESCAPED_NUX_PATH_SEPARATOR,
    ),
)


def is_hostname(hostname):
    """"""
    Validate hostname
    """"""
    if len(hostname) > 255 or len(hostname) == 0:
        return False

    if hostname[-1] == ""."":
        hostname = hostname[:-1]

    allowed = re.compile(""(?!-)[A-Z\d_-]{1,63}(?<!-)$"", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("".""))


def compat_is_basestring(content):
    """"""
    Python 3 support for checking if content is unicode and/or
    of a string type
    """"""
    try:
        # Python v2.x
        return isinstance(content, basestring)

    except NameError:
        # Python v3.x
        return isinstance(content, str)


def tidy_path(path):
    """"""take a filename and or directory and attempts to tidy it up by removing
    trailing slashes and correcting any formatting issues.

    For example: ////absolute//path// becomes:
        /absolute/path

    """"""
    # Windows
    path = TIDY_WIN_PATH_RE.sub('\\1', path.strip())
    # Linux
    path = TIDY_NUX_PATH_RE.sub('\\1', path.strip())

    # Linux Based Trim
    path = TIDY_NUX_TRIM_RE.sub('\\1', path.strip())
    # Windows Based Trim
    path = expanduser(TIDY_WIN_TRIM_RE.sub('\\1', path.strip()))
    return path


def parse_url(url, default_schema='http'):
    """"""A function that greatly simplifies the parsing of a url
    specified by the end user.

     Valid syntaxes are:
        <schema>://<user>@<host>:<port>/<path>
        <schema>://<user>:<passwd>@<host>:<port>/<path>
        <schema>://<host>:<port>/<path>
        <schema>://<host>/<path>
        <schema>://<host>

     Argument parsing is also supported:
        <schema>://<user>@<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<user>:<passwd>@<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<host>/<path>?key1=val&key2=val2
        <schema>://<host>?key1=val&key2=val2

     The function returns a simple dictionary with all of
     the parsed content within it and returns 'None' if the
     content could not be extracted.
    """"""

    if not compat_is_basestring(url):
        # Simple error checking
        return None

    # Default Results
    result = {
        # The username (if specified)
        'user': None,
        # The password (if specified)
        'password': None,
        # The port (if specified)
        'port': None,
        # The hostname
        'host': None,
        # The full path (query + path)
        'fullpath': None,
        # The path
        'path': None,
        # The query
        'query': None,
        # The schema
        'schema': None,
        # The schema
        'url': None,
        # The arguments passed in (the parsed query)
        # This is in a dictionary of {'key': 'val', etc }
        # qsd = Query String Dictionary
        'qsd': {}
    }

    qsdata = ''
    match = VALID_URL_RE.search(url)
    if match:
        # Extract basic results
        result['schema'] = match.group('schema').lower().strip()
        host = match.group('path').strip()
        try:
            qsdata = match.group('kwargs').strip()
        except AttributeError:
            # No qsdata
            pass

    else:
        match = VALID_HOST_RE.search(url)
        if not match:
            return None
        result['schema'] = default_schema
        host = match.group('path').strip()
        try:
            qsdata = match.group('kwargs').strip()
        except AttributeError:
            # No qsdata
            pass

    # Now do a proper extraction of data
    parsed = urlparse('http://%s' % host)

    # Parse results
    result['host'] = parsed[1].strip()

    if not result['host']:
        # Nothing more we can do without a hostname
        return None

    result['fullpath'] = quote(unquote(tidy_path(parsed[2].strip())))
    try:
        # Handle trailing slashes removed by tidy_path
        if result['fullpath'][-1] not in ('/', '\\') and \
           url[-1] in ('/', '\\'):
            result['fullpath'] += url.strip()[-1]

    except IndexError:
        # No problem, there simply isn't any returned results
        # and therefore, no trailing slash
        pass

    # Parse Query Arugments ?val=key&key=val
    # while ensureing that all keys are lowercase
    if qsdata:
        result['qsd'] = dict([(k.lower().strip(), v.strip())
                              for k, v in parse_qsl(
            qsdata,
            keep_blank_values=True,
            strict_parsing=False,
        )])

    if not result['fullpath']:
        # Default
        result['fullpath'] = None

    else:
        # Using full path, extract query from path
        match = VALID_QUERY_RE.search(result['fullpath'])
        if match:
            result['path'] = match.group('path')
            result['query'] = match.group('query')
            if not result['query']:
                result['query'] = None
    try:
        (result['user'], result['host']) = \
            re.split('[\s@]+', result['host'])[:2]

    except ValueError:
        # no problem then, host only exists
        # and it's already assigned
        pass

    if result['user'] is not None:
        try:
            (result['user'], result['password']) = \
                re.split('[:\s]+', result['user'])[:2]

        except ValueError:
            # no problem then, user only exists
            # and it's already assigned
            pass

    try:
        (result['host'], result['port']) = \
            re.split('[\s:]+', result['host'])[:2]

    except ValueError:
        # no problem then, user only exists
        # and it's already assigned
        pass

    if result['port']:
        try:
            result['port'] = int(result['port'])

        except (ValueError, TypeError):
            # Invalid Port Specified
            return None

        if result['port'] == 0:
            result['port'] = None

    if not is_hostname(result['host']):
        # Nothing more we can do without a hostname
        return None

    # Re-assemble cleaned up version of the url
    result['url'] = '%s://' % result['schema']
    if compat_is_basestring(result['user']):
        result['url'] += result['user']

        if compat_is_basestring(result['password']):
            result['url'] += ':%s@' % result['password']

        else:
            result['url'] += '@'
    result['url'] += result['host']

    if result['port']:
        result['url'] += ':%d' % result['port']

    if result['fullpath']:
        result['url'] += result['fullpath']

    return result


def parse_bool(arg, default=False):
    """"""
    NZBGet uses 'yes' and 'no' as well as other strings such as 'on' or
    'off' etch to handle boolean operations from it's control interface.

    This method can just simplify checks to these variables.

    If the content could not be parsed, then the default is returned.
    """"""

    if compat_is_basestring(arg):
        # no = no - False
        # of = short for off - False
        # 0  = int for False
        # fa = short for False - False
        # f  = short for False - False
        # n  = short for No or Never - False
        # ne  = short for Never - False
        # di  = short for Disable(d) - False
        # de  = short for Deny - False
        if arg.lower()[0:2] in (
                'de', 'di', 'ne', 'f', 'n', 'no', 'of', '0', 'fa'):
            return False
        # ye = yes - True
        # on = short for off - True
        # 1  = int for True
        # tr = short for True - True
        # t  = short for True - True
        # al = short for Always (and Allow) - True
        # en  = short for Enable(d) - True
        elif arg.lower()[0:2] in (
                'en', 'al', 't', 'y', 'ye', 'on', '1', 'tr'):
            return True
        # otherwise
        return default

    # Handle other types
    return bool(arg)


def parse_list(*args):
    """"""
    Take a string list and break it into a delimited
    list of arguments. This funciton also supports
    the processing of a list of delmited strings and will
    always return a unique set of arguments. Duplicates are
    always combined in the final results.

    You can append as many items to the argument listing for
    parsing.

    Hence: parse_list('.mkv, .iso, .avi') becomes:
        ['.mkv', '.iso', '.avi']

    Hence: parse_list('.mkv, .iso, .avi', ['.avi', '.mp4']) becomes:
        ['.mkv', '.iso', '.avi', '.mp4']

    The parsing is very forgiving and accepts spaces, slashes, commas
    semicolons, and pipes as delimiters
    """"""

    result = []
    for arg in args:
        if compat_is_basestring(arg):
            result += re.split(STRING_DELIMITERS, arg)

        elif isinstance(arg, (set, list, tuple)):
            result += parse_list(*arg)

        else:
            # Convert whatever it is to a string and work with it
            result += parse_list(str(arg))

    #
    # filter() eliminates any empty entries
    #
    # Since Python v3 returns a filter (iterator) where-as Python v2 returned
    # a list, we need to change it into a list object to remain compatible with
    # both distribution types.
    return sorted([x for x in filter(bool, list(set(result)))])
","# -*- coding: utf-8 -*-
#
# A simple collection of general functions
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from os.path import expanduser

try:
    # Python 2.7
    from urllib import unquote
    from urllib import quote
    from urlparse import urlparse
    from urlparse import parse_qsl

except ImportError:
    # Python 3.x
    from urllib.parse import unquote
    from urllib.parse import quote
    from urllib.parse import urlparse
    from urllib.parse import parse_qsl

import logging
logger = logging.getLogger(__name__)

# URL Indexing Table for returns via parse_url()
VALID_URL_RE = re.compile(
    r'^[\s]*(?P<schema>[^:\s]+):[/\\]*(?P<path>[^?]+)'
    r'(\?(?P<kwargs>.+))?[\s]*$',
)
VALID_HOST_RE = re.compile(r'^[\s]*(?P<path>[^?\s]+)(\?(?P<kwargs>.+))?')
VALID_QUERY_RE = re.compile(r'^(?P<path>.*[/\\])(?P<query>[^/\\]*)$')

# delimiters used to separate values when content is passed in by string.
# This is useful when turning a string into a list
STRING_DELIMITERS = r'[\[\]\;,\s]+'

# Pre-Escape content since we reference it so much
ESCAPED_PATH_SEPARATOR = re.escape('\\/')
ESCAPED_WIN_PATH_SEPARATOR = re.escape('\\')
ESCAPED_NUX_PATH_SEPARATOR = re.escape('/')

TIDY_WIN_PATH_RE = re.compile(
    r'(^[%s]{2}|[^%s\s][%s]|[\s][%s]{2}])([%s]+)' % (
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
    ),
)
TIDY_WIN_TRIM_RE = re.compile(
    r'^(.+[^:][^%s])[\s%s]*$' % (
        ESCAPED_WIN_PATH_SEPARATOR,
        ESCAPED_WIN_PATH_SEPARATOR,
    ),
)

TIDY_NUX_PATH_RE = re.compile(
    r'([%s])([%s]+)' % (
        ESCAPED_NUX_PATH_SEPARATOR,
        ESCAPED_NUX_PATH_SEPARATOR,
    ),
)

TIDY_NUX_TRIM_RE = re.compile(
    r'([^%s])[\s%s]+$' % (
        ESCAPED_NUX_PATH_SEPARATOR,
        ESCAPED_NUX_PATH_SEPARATOR,
    ),
)


def is_hostname(hostname):
    """"""
    Validate hostname
    """"""
    if len(hostname) > 255 or len(hostname) == 0:
        return False

    if hostname[-1] == ""."":
        hostname = hostname[:-1]

    allowed = re.compile(""(?!-)[A-Z\d_-]{1,63}(?<!-)$"", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("".""))


def compat_is_basestring(content):
    """"""
    Python 3 support for checking if content is unicode and/or
    of a string type
    """"""
    try:
        # Python v2.x
        return isinstance(content, basestring)

    except NameError:
        # Python v3.x
        return isinstance(content, str)


def tidy_path(path):
    """"""take a filename and or directory and attempts to tidy it up by removing
    trailing slashes and correcting any formatting issues.

    For example: ////absolute//path// becomes:
        /absolute/path

    """"""
    # Windows
    path = TIDY_WIN_PATH_RE.sub('\\1', path.strip())
    # Linux
    path = TIDY_NUX_PATH_RE.sub('\\1', path.strip())

    # Linux Based Trim
    path = TIDY_NUX_TRIM_RE.sub('\\1', path.strip())
    # Windows Based Trim
    path = expanduser(TIDY_WIN_TRIM_RE.sub('\\1', path.strip()))
    return path


def parse_url(url, default_schema='http', verify_host=True):
    """"""A function that greatly simplifies the parsing of a url
    specified by the end user.

     Valid syntaxes are:
        <schema>://<user>@<host>:<port>/<path>
        <schema>://<user>:<passwd>@<host>:<port>/<path>
        <schema>://<host>:<port>/<path>
        <schema>://<host>/<path>
        <schema>://<host>

     Argument parsing is also supported:
        <schema>://<user>@<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<user>:<passwd>@<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<host>:<port>/<path>?key1=val&key2=val2
        <schema>://<host>/<path>?key1=val&key2=val2
        <schema>://<host>?key1=val&key2=val2

     The function returns a simple dictionary with all of
     the parsed content within it and returns 'None' if the
     content could not be extracted.
    """"""

    if not compat_is_basestring(url):
        # Simple error checking
        return None

    # Default Results
    result = {
        # The username (if specified)
        'user': None,
        # The password (if specified)
        'password': None,
        # The port (if specified)
        'port': None,
        # The hostname
        'host': None,
        # The full path (query + path)
        'fullpath': None,
        # The path
        'path': None,
        # The query
        'query': None,
        # The schema
        'schema': None,
        # The schema
        'url': None,
        # The arguments passed in (the parsed query)
        # This is in a dictionary of {'key': 'val', etc }
        # qsd = Query String Dictionary
        'qsd': {}
    }

    qsdata = ''
    match = VALID_URL_RE.search(url)
    if match:
        # Extract basic results
        result['schema'] = match.group('schema').lower().strip()
        host = match.group('path').strip()
        try:
            qsdata = match.group('kwargs').strip()
        except AttributeError:
            # No qsdata
            pass

    else:
        match = VALID_HOST_RE.search(url)
        if not match:
            return None
        result['schema'] = default_schema
        host = match.group('path').strip()
        try:
            qsdata = match.group('kwargs').strip()
        except AttributeError:
            # No qsdata
            pass

    # Now do a proper extraction of data
    parsed = urlparse('http://%s' % host)

    # Parse results
    result['host'] = parsed[1].strip()

    if not result['host']:
        # Nothing more we can do without a hostname
        return None

    result['fullpath'] = quote(unquote(tidy_path(parsed[2].strip())))
    try:
        # Handle trailing slashes removed by tidy_path
        if result['fullpath'][-1] not in ('/', '\\') and \
           url[-1] in ('/', '\\'):
            result['fullpath'] += url.strip()[-1]

    except IndexError:
        # No problem, there simply isn't any returned results
        # and therefore, no trailing slash
        pass

    # Parse Query Arugments ?val=key&key=val
    # while ensureing that all keys are lowercase
    if qsdata:
        result['qsd'] = dict([(k.lower().strip(), v.strip())
                              for k, v in parse_qsl(
            qsdata,
            keep_blank_values=True,
            strict_parsing=False,
        )])

    if not result['fullpath']:
        # Default
        result['fullpath'] = None

    else:
        # Using full path, extract query from path
        match = VALID_QUERY_RE.search(result['fullpath'])
        if match:
            result['path'] = match.group('path')
            result['query'] = match.group('query')
            if not result['query']:
                result['query'] = None
    try:
        (result['user'], result['host']) = \
            re.split('[\s@]+', result['host'])[:2]

    except ValueError:
        # no problem then, host only exists
        # and it's already assigned
        pass

    if result['user'] is not None:
        try:
            (result['user'], result['password']) = \
                re.split('[:\s]+', result['user'])[:2]

        except ValueError:
            # no problem then, user only exists
            # and it's already assigned
            pass

    try:
        (result['host'], result['port']) = \
            re.split('[\s:]+', result['host'])[:2]

    except ValueError:
        # no problem then, user only exists
        # and it's already assigned
        pass

    if result['port']:
        try:
            result['port'] = int(result['port'])

        except (ValueError, TypeError):
            # Invalid Port Specified
            return None

        if result['port'] == 0:
            result['port'] = None

    if verify_host and not is_hostname(result['host']):
        # Nothing more we can do without a hostname
        return None

    # Re-assemble cleaned up version of the url
    result['url'] = '%s://' % result['schema']
    if compat_is_basestring(result['user']):
        result['url'] += result['user']

        if compat_is_basestring(result['password']):
            result['url'] += ':%s@' % result['password']

        else:
            result['url'] += '@'
    result['url'] += result['host']

    if result['port']:
        result['url'] += ':%d' % result['port']

    if result['fullpath']:
        result['url'] += result['fullpath']

    return result


def parse_bool(arg, default=False):
    """"""
    NZBGet uses 'yes' and 'no' as well as other strings such as 'on' or
    'off' etch to handle boolean operations from it's control interface.

    This method can just simplify checks to these variables.

    If the content could not be parsed, then the default is returned.
    """"""

    if compat_is_basestring(arg):
        # no = no - False
        # of = short for off - False
        # 0  = int for False
        # fa = short for False - False
        # f  = short for False - False
        # n  = short for No or Never - False
        # ne  = short for Never - False
        # di  = short for Disable(d) - False
        # de  = short for Deny - False
        if arg.lower()[0:2] in (
                'de', 'di', 'ne', 'f', 'n', 'no', 'of', '0', 'fa'):
            return False
        # ye = yes - True
        # on = short for off - True
        # 1  = int for True
        # tr = short for True - True
        # t  = short for True - True
        # al = short for Always (and Allow) - True
        # en  = short for Enable(d) - True
        elif arg.lower()[0:2] in (
                'en', 'al', 't', 'y', 'ye', 'on', '1', 'tr'):
            return True
        # otherwise
        return default

    # Handle other types
    return bool(arg)


def parse_list(*args):
    """"""
    Take a string list and break it into a delimited
    list of arguments. This funciton also supports
    the processing of a list of delmited strings and will
    always return a unique set of arguments. Duplicates are
    always combined in the final results.

    You can append as many items to the argument listing for
    parsing.

    Hence: parse_list('.mkv, .iso, .avi') becomes:
        ['.mkv', '.iso', '.avi']

    Hence: parse_list('.mkv, .iso, .avi', ['.avi', '.mp4']) becomes:
        ['.mkv', '.iso', '.avi', '.mp4']

    The parsing is very forgiving and accepts spaces, slashes, commas
    semicolons, and pipes as delimiters
    """"""

    result = []
    for arg in args:
        if compat_is_basestring(arg):
            result += re.split(STRING_DELIMITERS, arg)

        elif isinstance(arg, (set, list, tuple)):
            result += parse_list(*arg)

        else:
            # Convert whatever it is to a string and work with it
            result += parse_list(str(arg))

    #
    # filter() eliminates any empty entries
    #
    # Since Python v3 returns a filter (iterator) where-as Python v2 returned
    # a list, we need to change it into a list object to remain compatible with
    # both distribution types.
    return sorted([x for x in filter(bool, list(set(result)))])
","@@ -133,7 +133,7 @@ def tidy_path(path):
     return path
 
 
-def parse_url(url, default_schema='http'):
+def parse_url(url, default_schema='http', verify_host=True):
     """"""A function that greatly simplifies the parsing of a url
     specified by the end user.
 
@@ -293,7 +293,7 @@ def parse_url(url, default_schema='http'):
         if result['port'] == 0:
             result['port'] = None
 
-    if not is_hostname(result['host']):
+    if verify_host and not is_hostname(result['host']):
         # Nothing more we can do without a hostname
         return None
 
",add missing comments,-0.23,1,0
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,notify.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Apprise notify CLI tool
#
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import click
import logging
import sys

from apprise import Apprise
from apprise import AppriseAsset
from apprise import NotifyType

# Logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

# Defines our click context settings adding -h to the additional options that
# can be specified to get the help menu to come up
CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])


def print_help_msg(command):
    """"""
    Prints help message when -h or --help is specified.

    """"""
    with click.Context(command) as ctx:
        click.echo(command.get_help(ctx))


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--title', '-t', default=None, type=str,
              help='Specify the message title.')
@click.option('--body', '-b', default=None, type=str,
              help='Specify the message body.')
@click.option('--notification-type', '-t', default=NotifyType.INFO, type=str,
              metavar='TYPE', help='Specify the message type (default=info).')
@click.option('--theme', '-T', default='default', type=str,
              help='Specify the default theme.')
@click.argument('urls', nargs=-1,
                metavar='SERVER_URL [SERVER_URL2 [SERVER_URL3]]',)
def _main(title, body, urls, notification_type, theme):
    """"""
    Send a notification to all of the specified servers identified by their
    URLs the content provided within the title, body and notification-type.

    """"""
    if not urls:
        logger.error('You must specify at least one server URL.')
        print_help_msg(_main)
        return 1

    # Prepare our asset
    asset = AppriseAsset(theme=theme)

    # Create our object
    apprise = Apprise(asset=asset)

    # Load our inventory up
    for url in urls:
        apprise.add(url)

    if body is None:
        # if no body was specified, then read from STDIN
        body = click.get_text_stream('stdin').read()

    # now print it out
    apprise.notify(title=title, body=body, notify_type=notification_type)

    return 0


if __name__ == '__main__':
    exit(_main())
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Apprise notify CLI tool
#
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import click
import logging
import sys

from apprise import NotifyType
import apprise

# Logging
logger = logging.getLogger('apprise.plugins.NotifyBase')

# Defines our click context settings adding -h to the additional options that
# can be specified to get the help menu to come up
CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])


def print_help_msg(command):
    """"""
    Prints help message when -h or --help is specified.

    """"""
    with click.Context(command) as ctx:
        click.echo(command.get_help(ctx))


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--title', '-t', default=None, type=str,
              help='Specify the message title.')
@click.option('--body', '-b', default=None, type=str,
              help='Specify the message body.')
@click.option('--notification-type', '-n', default=NotifyType.INFO, type=str,
              metavar='TYPE', help='Specify the message type (default=info).')
@click.option('--theme', '-T', default='default', type=str,
              help='Specify the default theme.')
@click.option('-v', '--verbose', count=True)
@click.argument('urls', nargs=-1,
                metavar='SERVER_URL [SERVER_URL2 [SERVER_URL3]]',)
def _main(title, body, urls, notification_type, theme, verbose):
    """"""
    Send a notification to all of the specified servers identified by their
    URLs the content provided within the title, body and notification-type.

    """"""

    # Logging
    ch = logging.StreamHandler(sys.stdout)
    if verbose > 2:
        logger.setLevel(logging.DEBUG)

    elif verbose == 1:
        logger.setLevel(logging.INFO)

    else:
        logger.setLevel(logging.NONE)

    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if not urls:
        logger.error('You must specify at least one server URL.')
        print_help_msg(_main)
        return 1

    # Prepare our asset
    asset = apprise.AppriseAsset(theme=theme)

    # Create our object
    a = apprise.Apprise(asset=asset)

    # Load our inventory up
    for url in urls:
        a.add(url)

    if body is None:
        # if no body was specified, then read from STDIN
        body = click.get_text_stream('stdin').read()

    # now print it out
    if a.notify(title=title, body=body, notify_type=notification_type):
        return 0
    return 1


if __name__ == '__main__':
    exit(_main())
","@@ -27,19 +27,11 @@ import click
 import logging
 import sys
 
-from apprise import Apprise
-from apprise import AppriseAsset
 from apprise import NotifyType
+import apprise
 
 # Logging
-logger = logging.getLogger(__name__)
-logger.setLevel(logging.INFO)
-
-ch = logging.StreamHandler(sys.stdout)
-ch.setLevel(logging.INFO)
-formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
-ch.setFormatter(formatter)
-logger.addHandler(ch)
+logger = logging.getLogger('apprise.plugins.NotifyBase')
 
 # Defines our click context settings adding -h to the additional options that
 # can be specified to get the help menu to come up
@@ -60,41 +52,58 @@ def print_help_msg(command):
               help='Specify the message title.')
 @click.option('--body', '-b', default=None, type=str,
               help='Specify the message body.')
-@click.option('--notification-type', '-t', default=NotifyType.INFO, type=str,
+@click.option('--notification-type', '-n', default=NotifyType.INFO, type=str,
               metavar='TYPE', help='Specify the message type (default=info).')
 @click.option('--theme', '-T', default='default', type=str,
               help='Specify the default theme.')
+@click.option('-v', '--verbose', count=True)
 @click.argument('urls', nargs=-1,
                 metavar='SERVER_URL [SERVER_URL2 [SERVER_URL3]]',)
-def _main(title, body, urls, notification_type, theme):
+def _main(title, body, urls, notification_type, theme, verbose):
     """"""
     Send a notification to all of the specified servers identified by their
     URLs the content provided within the title, body and notification-type.
 
     """"""
+
+    # Logging
+    ch = logging.StreamHandler(sys.stdout)
+    if verbose > 2:
+        logger.setLevel(logging.DEBUG)
+
+    elif verbose == 1:
+        logger.setLevel(logging.INFO)
+
+    else:
+        logger.setLevel(logging.NONE)
+
+    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
+    ch.setFormatter(formatter)
+    logger.addHandler(ch)
+
     if not urls:
         logger.error('You must specify at least one server URL.')
         print_help_msg(_main)
         return 1
 
     # Prepare our asset
-    asset = AppriseAsset(theme=theme)
+    asset = apprise.AppriseAsset(theme=theme)
 
     # Create our object
-    apprise = Apprise(asset=asset)
+    a = apprise.Apprise(asset=asset)
 
     # Load our inventory up
     for url in urls:
-        apprise.add(url)
+        a.add(url)
 
     if body is None:
         # if no body was specified, then read from STDIN
         body = click.get_text_stream('stdin').read()
 
     # now print it out
-    apprise.notify(title=title, body=body, notify_type=notification_type)
-
-    return 0
+    if a.notify(title=title, body=body, notify_type=notification_type):
+        return 0
+    return 1
 
 
 if __name__ == '__main__':
",add apprise-notify-base.py,-2.99,3,9
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,test_api.py,"# -*- coding: utf-8 -*-
#
# Apprise and AppriseAsset Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from __future__ import print_function
from __future__ import unicode_literals
from os import chmod
from os.path import dirname
from apprise import Apprise
from apprise import AppriseAsset
from apprise.Apprise import SCHEMA_MAP
from apprise import NotifyBase
from apprise import NotifyType
from apprise import NotifyImageSize
from apprise.Apprise import __load_matrix


def test_apprise():
    """"""
    API: Apprise() object

    """"""
    # Caling load matix a second time which is an internal function causes it
    # to skip over content already loaded into our matrix and thefore accesses
    # other if/else parts of the code that aren't otherwise called
    __load_matrix()

    a = Apprise()

    # no items
    assert(len(a) == 0)

    # Create an Asset object
    asset = AppriseAsset(theme='default')

    # We can load the device using our asset
    a = Apprise(asset=asset)

    # We can load our servers up front as well
    servers = [
        'faast://abcdefghijklmnop-abcdefg',
        'kodi://kodi.server.local',
        'palot://1f418df7577e32b89ac6511f2eb9aa68',
    ]

    a = Apprise(servers=servers)

    # 3 servers loaded
    assert(len(a) == 3)

    # We can add another server
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4') is True)
    assert(len(a) == 4)

    # We can empty our set
    a.clear()
    assert(len(a) == 0)

    # An invalid schema
    assert(
        a.add('this is not a parseable url at all') is False)
    assert(len(a) == 0)

    # An unsupported schema
    assert(
        a.add('invalid://we.just.do.not.support.this.plugin.type') is False)
    assert(len(a) == 0)

    # A poorly formatted URL
    assert(
        a.add('json://user:@@@:bad?no.good') is False)
    assert(len(a) == 0)

    # Add a server with our asset we created earlier
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4', asset=asset) is True)

    # Clear our server listings again
    a.clear()

    # No servers to notify
    assert(a.notify(title=""my title"", body=""my body"") is False)

    class BadNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(BadNotification, self).__init__()

            # We fail whenever we're initialized
            raise TypeError()

    class GoodNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(GoodNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return True

    # Store our bad notification in our schema map
    SCHEMA_MAP['bad'] = BadNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['good'] = GoodNotification

    # Just to explain what is happening here, we would have parsed the
    # url properly but failed when we went to go and create an instance
    # of it.
    assert(a.add('bad://localhost') is False)
    assert(len(a) == 0)

    assert(a.add('good://localhost') is True)
    assert(len(a) == 1)

    # Bad Notification Type is still allowed as it is presumed the user
    # know's what their doing
    assert(a.notify(
        title=""my title"", body=""my body"", notify_type='bad') is True)

    # No Title/Body combo's
    assert(a.notify(title=None, body=None) is False)
    assert(a.notify(title='', body=None) is False)
    assert(a.notify(title=None, body='') is False)

    # As long as one is present, we're good
    assert(a.notify(title=None, body='present') is True)
    assert(a.notify(title='present', body=None) is True)
    assert(a.notify(title=""present"", body=""present"") is True)

    # Clear our server listings again
    a.clear()

    class ThrowNotification(NotifyBase):
        def notify(self, **kwargs):
            # Pretend everything is okay
            raise TypeError()

    class FailNotification(NotifyBase):

        def notify(self, **kwargs):
            # Pretend everything is okay
            return False

    # Store our bad notification in our schema map
    SCHEMA_MAP['throw'] = ThrowNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['fail'] = FailNotification

    assert(a.add('throw://localhost') is True)
    assert(a.add('fail://localhost') is True)
    assert(len(a) == 2)

    # Test when our notify both throws an exception and or just
    # simply returns False
    assert(a.notify(title=""present"", body=""present"") is False)

    # Test instantiating a plugin
    class ThrowInstantiateNotification(NotifyBase):
        def __init__(self, **kwargs):
            # Pretend everything is okay
            raise TypeError()
    SCHEMA_MAP['throw'] = ThrowInstantiateNotification

    # Reset our object
    a.clear()
    assert(len(a) == 0)

    # Instantiate a good object
    plugin = a.instantiate('good://localhost')
    assert(isinstance(plugin, NotifyBase))

    # We an add already substatiated instances into our Apprise object
    a.add(plugin)
    assert(len(a) == 1)

    # Reset our object again
    a.clear()
    try:
        a.instantiate('throw://localhost', suppress_exceptions=False)
        assert(False)

    except TypeError:
        assert(True)
    assert(len(a) == 0)

    assert(a.instantiate(
        'throw://localhost', suppress_exceptions=True) is None)
    assert(len(a) == 0)


def test_apprise_asset(tmpdir):
    """"""
    API: AppriseAsset() object

    """"""
    a = AppriseAsset(theme=None)
    # Default theme
    assert(a.theme == 'default')

    a = AppriseAsset(
        theme='dark',
        image_path_mask='/{THEME}/{TYPE}-{XY}.png',
        image_url_mask='http://localhost/{THEME}/{TYPE}-{XY}.png',
    )

    a.default_html_color = '#abcabc'
    a.html_notify_map[NotifyType.INFO] = '#aaaaaa'

    assert(a.html_color('invalid') == '#abcabc')
    assert(a.html_color(NotifyType.INFO) == '#aaaaaa')

    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) ==
           'http://localhost/dark/info-256x256.png')

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=False) == '/dark/info-256x256.png')

    # This path doesn't exist so image_raw will fail (since we just
    # randompyl picked it for testing)
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is None)

    # Create a new object (with our default settings)
    a = AppriseAsset()

    # Our default configuration can access our file
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # Create a temporary directory
    sub = tmpdir.mkdir(""great.theme"")

    # Write a file
    sub.join(""{0}-{1}.png"".format(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
    )).write(""the content doesn't matter for testing."")

    # Create an asset that will reference our file we just created
    a = AppriseAsset(
        theme='great.theme',
        image_path_mask='%s/{THEME}/{TYPE}-{XY}.png' % dirname(sub.strpath),
    )

    # We'll be able to read file we just created
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # We can retrieve the filename at this point even with must_exist set
    # to True
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # If we make the file un-readable however, we won't be able to read it
    # This test is just showing that we won't throw an exception
    chmod(dirname(sub.strpath), 0o000)
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    # Our path doesn't exist anymore using this logic
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is None)

    # Return our permission so we don't have any problems with our cleanup
    chmod(dirname(sub.strpath), 0o700)

    # Our content is retrivable again
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # our file path is accessible again too
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # We do the same test, but set the permission on the file
    chmod(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256), 0o000)

    # our path will still exist in this case
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # but we will not be able to open it
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    # Restore our permissions
    chmod(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256), 0o640)
","# -*- coding: utf-8 -*-
#
# Apprise and AppriseAsset Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from __future__ import print_function
from __future__ import unicode_literals
from os import chmod
from os.path import dirname
from apprise import Apprise
from apprise import AppriseAsset
from apprise.Apprise import SCHEMA_MAP
from apprise import NotifyBase
from apprise import NotifyType
from apprise import NotifyImageSize
from apprise.Apprise import __load_matrix


def test_apprise():
    """"""
    API: Apprise() object

    """"""
    # Caling load matix a second time which is an internal function causes it
    # to skip over content already loaded into our matrix and thefore accesses
    # other if/else parts of the code that aren't otherwise called
    __load_matrix()

    a = Apprise()

    # no items
    assert(len(a) == 0)

    # Create an Asset object
    asset = AppriseAsset(theme='default')

    # We can load the device using our asset
    a = Apprise(asset=asset)

    # We can load our servers up front as well
    servers = [
        'faast://abcdefghijklmnop-abcdefg',
        'kodi://kodi.server.local',
        'palot://1f418df7577e32b89ac6511f2eb9aa68',
    ]

    a = Apprise(servers=servers)

    # 3 servers loaded
    assert(len(a) == 3)

    # We can add another server
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4') is True)
    assert(len(a) == 4)

    # We can empty our set
    a.clear()
    assert(len(a) == 0)

    # An invalid schema
    assert(
        a.add('this is not a parseable url at all') is False)
    assert(len(a) == 0)

    # An unsupported schema
    assert(
        a.add('invalid://we.just.do.not.support.this.plugin.type') is False)
    assert(len(a) == 0)

    # A poorly formatted URL
    assert(
        a.add('json://user:@@@:bad?no.good') is False)
    assert(len(a) == 0)

    # Add a server with our asset we created earlier
    assert(
        a.add('mmosts://mattermost.server.local/'
              '3ccdd113474722377935511fc85d3dd4', asset=asset) is True)

    # Clear our server listings again
    a.clear()

    # No servers to notify
    assert(a.notify(title=""my title"", body=""my body"") is False)

    class BadNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(BadNotification, self).__init__()

            # We fail whenever we're initialized
            raise TypeError()

    class GoodNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(GoodNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return True

    # Store our bad notification in our schema map
    SCHEMA_MAP['bad'] = BadNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['good'] = GoodNotification

    # Just to explain what is happening here, we would have parsed the
    # url properly but failed when we went to go and create an instance
    # of it.
    assert(a.add('bad://localhost') is False)
    assert(len(a) == 0)

    assert(a.add('good://localhost') is True)
    assert(len(a) == 1)

    # Bad Notification Type is still allowed as it is presumed the user
    # know's what their doing
    assert(a.notify(
        title=""my title"", body=""my body"", notify_type='bad') is True)

    # No Title/Body combo's
    assert(a.notify(title=None, body=None) is False)
    assert(a.notify(title='', body=None) is False)
    assert(a.notify(title=None, body='') is False)

    # As long as one is present, we're good
    assert(a.notify(title=None, body='present') is True)
    assert(a.notify(title='present', body=None) is True)
    assert(a.notify(title=""present"", body=""present"") is True)

    # Clear our server listings again
    a.clear()

    class ThrowNotification(NotifyBase):
        def notify(self, **kwargs):
            # Pretend everything is okay
            raise TypeError()

    class FailNotification(NotifyBase):

        def notify(self, **kwargs):
            # Pretend everything is okay
            return False

    # Store our bad notification in our schema map
    SCHEMA_MAP['throw'] = ThrowNotification

    # Store our good notification in our schema map
    SCHEMA_MAP['fail'] = FailNotification

    assert(a.add('throw://localhost') is True)
    assert(a.add('fail://localhost') is True)
    assert(len(a) == 2)

    # Test when our notify both throws an exception and or just
    # simply returns False
    assert(a.notify(title=""present"", body=""present"") is False)

    # Test instantiating a plugin
    class ThrowInstantiateNotification(NotifyBase):
        def __init__(self, **kwargs):
            # Pretend everything is okay
            raise TypeError()
    SCHEMA_MAP['throw'] = ThrowInstantiateNotification

    # Reset our object
    a.clear()
    assert(len(a) == 0)

    # Instantiate a good object
    plugin = a.instantiate('good://localhost')
    assert(isinstance(plugin, NotifyBase))

    # We an add already substatiated instances into our Apprise object
    a.add(plugin)
    assert(len(a) == 1)

    # Reset our object again
    a.clear()
    try:
        a.instantiate('throw://localhost', suppress_exceptions=False)
        assert(False)

    except TypeError:
        assert(True)
    assert(len(a) == 0)

    assert(a.instantiate(
        'throw://localhost', suppress_exceptions=True) is None)
    assert(len(a) == 0)


def test_apprise_asset(tmpdir):
    """"""
    API: AppriseAsset() object

    """"""
    a = AppriseAsset(theme=None)
    # Default theme
    assert(a.theme == 'default')

    a = AppriseAsset(
        theme='dark',
        image_path_mask='/{THEME}/{TYPE}-{XY}.png',
        image_url_mask='http://localhost/{THEME}/{TYPE}-{XY}.png',
    )

    a.default_html_color = '#abcabc'
    a.html_notify_map[NotifyType.INFO] = '#aaaaaa'

    assert(a.html_color('invalid') == '#abcabc')
    assert(a.html_color(NotifyType.INFO) == '#aaaaaa')

    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) ==
           'http://localhost/dark/info-256x256.png')

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=False) == '/dark/info-256x256.png')

    # This path doesn't exist so image_raw will fail (since we just
    # randompyl picked it for testing)
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is None)

    # Create a new object (with our default settings)
    a = AppriseAsset()

    # Our default configuration can access our file
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # Create a temporary directory
    sub = tmpdir.mkdir(""great.theme"")

    # Write a file
    sub.join(""{0}-{1}.png"".format(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
    )).write(""the content doesn't matter for testing."")

    # Create an asset that will reference our file we just created
    a = AppriseAsset(
        theme='great.theme',
        image_path_mask='%s/{THEME}/{TYPE}-{XY}.png' % dirname(sub.strpath),
    )

    # We'll be able to read file we just created
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # We can retrieve the filename at this point even with must_exist set
    # to True
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # If we make the file un-readable however, we won't be able to read it
    # This test is just showing that we won't throw an exception
    chmod(dirname(sub.strpath), 0o000)
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    # Our path doesn't exist anymore using this logic
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is None)

    # Return our permission so we don't have any problems with our cleanup
    chmod(dirname(sub.strpath), 0o700)

    # Our content is retrivable again
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is not None)

    # our file path is accessible again too
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # We do the same test, but set the permission on the file
    chmod(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256), 0o000)

    # our path will still exist in this case
    assert(a.image_path(
        NotifyType.INFO,
        NotifyImageSize.XY_256,
        must_exist=True) is not None)

    # but we will not be able to open it
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)

    # Restore our permissions
    chmod(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256), 0o640)

    # Disable all image references
    a = AppriseAsset(image_path_mask=False, image_url_mask=False)
    # We always return none in these calls now
    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)
    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) is None)
    assert(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256,
           must_exist=False) is None)
    assert(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256,
           must_exist=True) is None)
","@@ -316,3 +316,13 @@ def test_apprise_asset(tmpdir):
 
     # Restore our permissions
     chmod(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256), 0o640)
+
+    # Disable all image references
+    a = AppriseAsset(image_path_mask=False, image_url_mask=False)
+    # We always return none in these calls now
+    assert(a.image_raw(NotifyType.INFO, NotifyImageSize.XY_256) is None)
+    assert(a.image_url(NotifyType.INFO, NotifyImageSize.XY_256) is None)
+    assert(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256,
+           must_exist=False) is None)
+    assert(a.image_path(NotifyType.INFO, NotifyImageSize.XY_256,
+           must_exist=True) is None)
",add test for appriseasset,-1.24,4,10
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,test_notify_base.py,"# -*- coding: utf-8 -*-
#
# NotifyBase Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise.plugins.NotifyBase import NotifyBase
from apprise import NotifyType
from apprise import NotifyImageSize
from timeit import default_timer


def test_notify_base():
    """"""
    API: NotifyBase() object

    """"""

    # invalid types throw exceptions
    try:
        nb = NotifyBase(notify_format='invalid')
        # We should never reach here as an exception should be thrown
        assert(False)

    except TypeError:
        assert(True)

    try:
        nb = NotifyBase(image_size='invalid')
        # We should never reach here as an exception should be thrown
        assert(False)

    except TypeError:
        assert(True)

    # Bad port information
    nb = NotifyBase(port='invalid')
    assert nb.port is None

    nb = NotifyBase(port=10)
    assert nb.port == 10

    # Throttle overrides..
    nb = NotifyBase(throttle=0)
    start_time = default_timer()
    nb.throttle()
    elapsed = default_timer() - start_time
    # Should be a very fast response time since we set it to zero but we'll
    # check for less then 500 to be fair as some testing systems may be slower
    # then other
    assert elapsed < 0.5

    start_time = default_timer()
    nb.throttle(1.0)
    elapsed = default_timer() - start_time
    # Should be a very fast response time since we set it to zero but we'll
    # check for less then 500 to be fair as some testing systems may be slower
    # then other
    assert elapsed < 1.5

    # our NotifyBase wasn't initialized with an ImageSize so this will fail
    assert nb.image_url(notify_type=NotifyType.INFO) is None
    assert nb.image_path(notify_type=NotifyType.INFO) is None
    assert nb.image_raw(notify_type=NotifyType.INFO) is None

    # Create an object with an ImageSize loaded into it
    nb = NotifyBase(image_size=NotifyImageSize.XY_256)

    # We'll get an object thi time around
    assert nb.image_url(notify_type=NotifyType.INFO) is not None
    assert nb.image_path(notify_type=NotifyType.INFO) is not None
    assert nb.image_raw(notify_type=NotifyType.INFO) is not None

    # But we will not get a response with an invalid notification type
    assert nb.image_url(notify_type='invalid') is None
    assert nb.image_path(notify_type='invalid') is None
    assert nb.image_raw(notify_type='invalid') is None

    # Static function testing
    assert NotifyBase.escape_html(""<content>'\t \n</content>"") == \
        '&lt;content&gt;&apos;&emsp;&nbsp;\n&lt;/content&gt;'

    assert NotifyBase.escape_html(
        ""<content>'\t \n</content>"", convert_new_lines=True) == \
        '&lt;content&gt;&apos;&emsp;&nbsp;&lt;br/&gt;&lt;/content&gt;'

    assert NotifyBase.split_path(
        '/path/?name=Dr%20Disrespect', unquote=False) == \
        ['path', '?name=Dr%20Disrespect']

    assert NotifyBase.split_path(
        '/path/?name=Dr%20Disrespect', unquote=True) == \
        ['path', '?name=Dr', 'Disrespect']

    assert NotifyBase.is_email('test@gmail.com') is True
    assert NotifyBase.is_email('invalid.com') is False


def test_notify_base_urls():
    """"""
    API: NotifyBase() URLs

    """"""

    # Test verify switch whih is used as part of the SSL Verification
    # by default all SSL sites are verified unless this flag is set to
    # something like 'No', 'False', 'Disabled', etc.  Boolean values are
    # pretty forgiving.
    results = NotifyBase.parse_url('https://localhost:8080/?verify=No')
    assert 'verify' in results
    assert results['verify'] is False

    results = NotifyBase.parse_url('https://localhost:8080/?verify=Yes')
    assert 'verify' in results
    assert results['verify'] is True

    # The default is to verify
    results = NotifyBase.parse_url('https://localhost:8080')
    assert 'verify' in results
    assert results['verify'] is True

    # Password Handling

    # pass keyword over-rides default password
    results = NotifyBase.parse_url('https://user:pass@localhost')
    assert 'password' in results
    assert results['password'] == ""pass""

    # pass keyword over-rides default password
    results = NotifyBase.parse_url(
        'https://user:pass@localhost?pass=newpassword')
    assert 'password' in results
    assert results['password'] == ""newpassword""

    # User Handling

    # user keyword over-rides default password
    results = NotifyBase.parse_url('https://user:pass@localhost')
    assert 'user' in results
    assert results['user'] == ""user""

    # user keyword over-rides default password
    results = NotifyBase.parse_url(
        'https://user:pass@localhost?user=newuser')
    assert 'user' in results
    assert results['user'] == ""newuser""

    # Test invalid urls
    assert NotifyBase.parse_url('https://:@/') is None
    assert NotifyBase.parse_url('http://:@') is None
    assert NotifyBase.parse_url('http://@') is None
    assert NotifyBase.parse_url('http:///') is None
    assert NotifyBase.parse_url('http://:test/') is None
    assert NotifyBase.parse_url('http://pass:test/') is None
","# -*- coding: utf-8 -*-
#
# NotifyBase Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise.plugins.NotifyBase import NotifyBase
from apprise import NotifyType
from apprise import NotifyImageSize
from timeit import default_timer


def test_notify_base():
    """"""
    API: NotifyBase() object

    """"""

    # invalid types throw exceptions
    try:
        nb = NotifyBase(notify_format='invalid')
        # We should never reach here as an exception should be thrown
        assert(False)

    except TypeError:
        assert(True)

    try:
        nb = NotifyBase(image_size='invalid')
        # We should never reach here as an exception should be thrown
        assert(False)

    except TypeError:
        assert(True)

    # Bad port information
    nb = NotifyBase(port='invalid')
    assert nb.port is None

    nb = NotifyBase(port=10)
    assert nb.port == 10

    # Throttle overrides..
    nb = NotifyBase(throttle=0)
    start_time = default_timer()
    nb.throttle()
    elapsed = default_timer() - start_time
    # Should be a very fast response time since we set it to zero but we'll
    # check for less then 500 to be fair as some testing systems may be slower
    # then other
    assert elapsed < 0.5

    start_time = default_timer()
    nb.throttle(1.0)
    elapsed = default_timer() - start_time
    # Should be a very fast response time since we set it to zero but we'll
    # check for less then 500 to be fair as some testing systems may be slower
    # then other
    assert elapsed < 1.5

    # our NotifyBase wasn't initialized with an ImageSize so this will fail
    assert nb.image_url(notify_type=NotifyType.INFO) is None
    assert nb.image_path(notify_type=NotifyType.INFO) is None
    assert nb.image_raw(notify_type=NotifyType.INFO) is None

    # Create an object with an ImageSize loaded into it
    nb = NotifyBase(image_size=NotifyImageSize.XY_256)

    # We'll get an object this time around
    assert nb.image_url(notify_type=NotifyType.INFO) is not None
    assert nb.image_path(notify_type=NotifyType.INFO) is not None
    assert nb.image_raw(notify_type=NotifyType.INFO) is not None

    # But we will not get a response with an invalid notification type
    assert nb.image_url(notify_type='invalid') is None
    assert nb.image_path(notify_type='invalid') is None
    assert nb.image_raw(notify_type='invalid') is None

    # Static function testing
    assert NotifyBase.escape_html(""<content>'\t \n</content>"") == \
        '&lt;content&gt;&apos;&emsp;&nbsp;\n&lt;/content&gt;'

    assert NotifyBase.escape_html(
        ""<content>'\t \n</content>"", convert_new_lines=True) == \
        '&lt;content&gt;&apos;&emsp;&nbsp;&lt;br/&gt;&lt;/content&gt;'

    assert NotifyBase.split_path(
        '/path/?name=Dr%20Disrespect', unquote=False) == \
        ['path', '?name=Dr%20Disrespect']

    assert NotifyBase.split_path(
        '/path/?name=Dr%20Disrespect', unquote=True) == \
        ['path', '?name=Dr', 'Disrespect']

    # Test is_email
    assert NotifyBase.is_email('test@gmail.com') is True
    assert NotifyBase.is_email('invalid.com') is False

    # Test is_hostname
    assert NotifyBase.is_hostname('example.com') is True


def test_notify_base_urls():
    """"""
    API: NotifyBase() URLs

    """"""

    # Test verify switch whih is used as part of the SSL Verification
    # by default all SSL sites are verified unless this flag is set to
    # something like 'No', 'False', 'Disabled', etc.  Boolean values are
    # pretty forgiving.
    results = NotifyBase.parse_url('https://localhost:8080/?verify=No')
    assert 'verify' in results
    assert results['verify'] is False

    results = NotifyBase.parse_url('https://localhost:8080/?verify=Yes')
    assert 'verify' in results
    assert results['verify'] is True

    # The default is to verify
    results = NotifyBase.parse_url('https://localhost:8080')
    assert 'verify' in results
    assert results['verify'] is True

    # Password Handling

    # pass keyword over-rides default password
    results = NotifyBase.parse_url('https://user:pass@localhost')
    assert 'password' in results
    assert results['password'] == ""pass""

    # pass keyword over-rides default password
    results = NotifyBase.parse_url(
        'https://user:pass@localhost?pass=newpassword')
    assert 'password' in results
    assert results['password'] == ""newpassword""

    # User Handling

    # user keyword over-rides default password
    results = NotifyBase.parse_url('https://user:pass@localhost')
    assert 'user' in results
    assert results['user'] == ""user""

    # user keyword over-rides default password
    results = NotifyBase.parse_url(
        'https://user:pass@localhost?user=newuser')
    assert 'user' in results
    assert results['user'] == ""newuser""

    # Test invalid urls
    assert NotifyBase.parse_url('https://:@/') is None
    assert NotifyBase.parse_url('http://:@') is None
    assert NotifyBase.parse_url('http://@') is None
    assert NotifyBase.parse_url('http:///') is None
    assert NotifyBase.parse_url('http://:test/') is None
    assert NotifyBase.parse_url('http://pass:test/') is None
","@@ -78,7 +78,7 @@ def test_notify_base():
     # Create an object with an ImageSize loaded into it
     nb = NotifyBase(image_size=NotifyImageSize.XY_256)
 
-    # We'll get an object thi time around
+    # We'll get an object this time around
     assert nb.image_url(notify_type=NotifyType.INFO) is not None
     assert nb.image_path(notify_type=NotifyType.INFO) is not None
     assert nb.image_raw(notify_type=NotifyType.INFO) is not None
@@ -104,9 +104,13 @@ def test_notify_base():
         '/path/?name=Dr%20Disrespect', unquote=True) == \
         ['path', '?name=Dr', 'Disrespect']
 
+    # Test is_email
     assert NotifyBase.is_email('test@gmail.com') is True
     assert NotifyBase.is_email('invalid.com') is False
 
+    # Test is_hostname
+    assert NotifyBase.is_hostname('example.com') is True
+
 
 def test_notify_base_urls():
     """"""
",add more tests for the notifybase class,-0.4,1,4
82c5a11e5bf174dc4845b00b589ec079eac3168c,more unittesting + bugfixes,test_rest_plugins.py,"# -*- coding: utf-8 -*-
#
# REST Based Plugins - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
import requests
import mock


VALID_URLS = (
    ##################################
    # NotifyJSON
    ##################################
    ('json://', {
        'instance': None,
    }),
    ('jsons://', {
        'instance': None,
    }),
    ('json://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost:8080/path/', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://:@/', {
        'instance': None,
    }),
    ('json://user:pass@localhost:8081', {
        'instance': plugins.NotifyJSON,
        # force a failure
        'response': False,
        'requests_response_code': 500,
    }),
    ('json://user:pass@localhost:8082', {
        'instance': plugins.NotifyJSON,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('json://user:pass@localhost:8083', {
        'instance': plugins.NotifyJSON,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMatterMost
    ##################################
    ('mmost://', {
        'instance': None,
    }),
    ('mmosts://', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://user@localhost/3ccdd113474722377935511fc85d3dd4?channel=test', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:8080/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:0/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:invalid-port/3ccdd113474722377935511fc85d3dd4', {
        'instance': None,
    }),
    ('mmosts://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmosts://localhost', {
        'instance': plugins.NotifyMatterMost,
        # Thrown because there was no webhook id specified
        'exception': TypeError,
    }),
    ('mmost://localhost/bad-web-hook', {
        'instance': plugins.NotifyMatterMost,
        # Thrown because the webhook is not in a valid format
        'exception': TypeError,
    }),
    ('mmost://:@/', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # force a failure
        'response': False,
        'requests_response_code': 500,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_rest_plugins(mock_post, mock_get):
    """"""
    API: REST Based Plugins()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in VALID_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        # Allow us to force the server response code to be something other then
        # the defaults
        requests_response_code = meta.get(
            'requests_response_code', 200 if response else 404)

        test_requests_exceptions = meta.get(
            'test_requests_exceptions', False)

        mock_get.return_value = requests.Request()
        mock_post.return_value = requests.Request()
        if test_requests_exceptions is False:
            # Handle our default response
            mock_post.return_value.status_code = requests_response_code
            mock_get.return_value.status_code = requests_response_code
            mock_post.side_effect = None
            mock_get.side_effect = None

        else:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_requests_exceptions = (
                requests.ConnectionError(
                    0, 'requests.ConnectionError() not handled'),
                requests.RequestException(
                    0, 'requests.RequestException() not handled'),
                requests.HTTPError(
                    0, 'requests.HTTPError() not handled'),
                requests.ReadTimeout(
                    0, 'requests.ReadTimeout() not handled'),
                requests.TooManyRedirects(
                    0, 'requests.TooManyRedirects() not handled'),
            )

        try:
            obj = Apprise.instantiate(url, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_requests_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=NotifyType.INFO) == response

                else:
                    for exception in test_requests_exceptions:
                        mock_post.side_effect = exception
                        mock_get.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                print('%s AssertionError' % url)
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s / %s' % (url, str(e)))
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))
","# -*- coding: utf-8 -*-
#
# REST Based Plugins - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
from apprise import AppriseAsset
import requests
import mock


TEST_URLS = (
    ##################################
    # NotifyBoxcar
    ##################################
    ('boxcar://', {
        'instance': None,
    }),
    # No secret specified
    ('boxcar://%s' % ('a' * 64), {
        'instance': None,
    }),
    # An invalid access and secret key specified
    ('boxcar://access.key/secret.key/', {
        'instance': plugins.NotifyBoxcar,
        # Thrown because there were no recipients specified
        'exception': TypeError,
    }),
    # Provide both an access and a secret
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # Test without image set
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
        # don't include an image by default
        'include_image': False,
    }),
    # our access, secret and device are all 64 characters
    # which is what we're doing here
    ('boxcar://%s/%s/@tag1/tag2///%s/' % (
        'a' * 64, 'b' * 64, 'd' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # An invalid tag
    ('boxcar://%s/%s/@%s' % ('a' * 64, 'b' * 64, 't' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    ('boxcar://:@/', {
        'instance': None,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyJSON
    ##################################
    ('json://', {
        'instance': None,
    }),
    ('jsons://', {
        'instance': None,
    }),
    ('json://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost:8080/path/', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://:@/', {
        'instance': None,
    }),
    ('json://user:pass@localhost:8081', {
        'instance': plugins.NotifyJSON,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('json://user:pass@localhost:8082', {
        'instance': plugins.NotifyJSON,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('json://user:pass@localhost:8083', {
        'instance': plugins.NotifyJSON,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('kodi://', {
        'instance': None,
    }),
    ('kodis://', {
        'instance': None,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost:8080/path/', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('kodis://localhost:443', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('kodi://:@/', {
        'instance': None,
    }),
    ('kodi://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('kodi://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('kodi://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMatterMost
    ##################################
    ('mmost://', {
        'instance': None,
    }),
    ('mmosts://', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://user@localhost/3ccdd113474722377935511fc85d3dd4?channel=test', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:8080/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:0/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:invalid-port/3ccdd113474722377935511fc85d3dd4', {
        'instance': None,
    }),
    ('mmosts://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmosts://localhost', {
        'instance': plugins.NotifyMatterMost,
        # Thrown because there was no webhook id specified
        'exception': TypeError,
    }),
    ('mmost://localhost/bad-web-hook', {
        'instance': plugins.NotifyMatterMost,
        # Thrown because the webhook is not in a valid format
        'exception': TypeError,
    }),
    ('mmost://:@/', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifySlack
    ##################################
    ('slack://', {
        'instance': None,
    }),
    ('slack://:@/', {
        'instance': None,
    }),
    ('slack://T1JJ3T3L2', {
        # Just Token 1 provided
        'instance': None,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#hmm/#-invalid-', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#channel', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
        # don't include an image by default
        'include_image': False,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/+id/%20/@id/', {
        # + encoded id,
        # @ userid
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#nuxref', {
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ', {
        # Missing a channel
        'exception': TypeError,
    }),
    ('slack://username@INVALID/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#cool', {
        # invalid 1st Token
        'exception': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/INVALID/TIiajkdnlazkcOXrIdevi7FQ/#great', {
        # invalid 2rd Token
        'exception': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/INVALID/#channel', {
        # invalid 3rd Token
        'exception': TypeError,
    }),
    ('slack://l2g@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#usenet', {
        'instance': plugins.NotifySlack,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('slack://respect@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#a', {
        'instance': plugins.NotifySlack,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('slack://notify@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#b', {
        'instance': plugins.NotifySlack,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('xbmc://', {
        'instance': None,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('xbmc://:@/', {
        'instance': None,
    }),
    ('xbmc://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xbmc://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xbmc://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyXML
    ##################################
    ('xml://', {
        'instance': None,
    }),
    ('xmls://', {
        'instance': None,
    }),
    ('xml://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost:8080/path/', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://:@/', {
        'instance': None,
    }),
    ('xml://user:pass@localhost:8081', {
        'instance': plugins.NotifyXML,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xml://user:pass@localhost:8082', {
        'instance': plugins.NotifyXML,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xml://user:pass@localhost:8083', {
        'instance': plugins.NotifyXML,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_rest_plugins(mock_post, mock_get):
    """"""
    API: REST Based Plugins()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        # Allow us to force the server response code to be something other then
        # the defaults
        requests_response_code = meta.get(
            'requests_response_code',
            requests.codes.ok if response else requests.codes.not_found,
        )

        # Allow notification type override, otherwise default to INFO
        notify_type = meta.get('notify_type', NotifyType.INFO)

        # Whether or not we should include an image with our request; unless
        # otherwise specified, we assume that images are to be included
        include_image = meta.get('include_image', True)
        if include_image:
            # a default asset
            asset = AppriseAsset()

        else:
            # Disable images
            asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

        test_requests_exceptions = meta.get(
            'test_requests_exceptions', False)

        mock_get.return_value = requests.Request()
        mock_post.return_value = requests.Request()
        if test_requests_exceptions is False:
            # Handle our default response
            mock_post.return_value.status_code = requests_response_code
            mock_get.return_value.status_code = requests_response_code
            mock_post.side_effect = None
            mock_get.side_effect = None

        else:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_requests_exceptions = (
                requests.ConnectionError(
                    0, 'requests.ConnectionError() not handled'),
                requests.RequestException(
                    0, 'requests.RequestException() not handled'),
                requests.HTTPError(
                    0, 'requests.HTTPError() not handled'),
                requests.ReadTimeout(
                    0, 'requests.ReadTimeout() not handled'),
                requests.TooManyRedirects(
                    0, 'requests.TooManyRedirects() not handled'),
            )

        try:
            obj = Apprise.instantiate(
                url, asset=asset, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_requests_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=notify_type) == response

                else:
                    for exception in test_requests_exceptions:
                        mock_post.side_effect = exception
                        mock_get.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                print('%s AssertionError' % url)
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_boxcar_plugin(mock_post, mock_get):
    """"""
    API: NotifyBoxcar() Extra Checks

    """"""
    # Generate some generic message types
    device = 'A' * 64
    tag = '@B' * 63

    access = '-' * 64
    secret = '_' * 64

    # Initializes the plugin with recipients set to None
    plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)

    # Initializes the plugin with a valid access, but invalid access key
    try:
        plugins.NotifyBoxcar(access=None, secret=secret, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret key
    try:
        plugins.NotifyBoxcar(access=access, secret='invalid', recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid key
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret
    try:
        plugins.NotifyBoxcar(access=access, secret=None, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with recipients list
    # the below also tests our the variation of recipient types
    plugins.NotifyBoxcar(
        access=access, secret=secret, recipients=[device, tag])

    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.created
    mock_get.return_value.status_code = requests.codes.created
    # Test notifications without a body or a title
    p = plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)
    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_slack_plugin(mock_post, mock_get):
    """"""
    API: NotifySlack() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    token_a = 'A' * 9
    token_b = 'B' * 9
    token_c = 'c' * 24

    # Support strings
    channels = 'chan1,#chan2,+id,@user,,,'

    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels)
    assert(len(obj.channels) == 4)
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # Empty Channel list
    try:
        plugins.NotifySlack(
            token_a=token_a, token_b=token_b, token_c=token_c,
            channels=None)
        assert(False)

    except TypeError:
        # we'll thrown because an empty list of channels was provided
        assert(True)

    # Test include_image
    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels,
        include_image=True)

    # This call includes an image with it's payload:
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True
","@@ -19,11 +19,74 @@
 from apprise import plugins
 from apprise import NotifyType
 from apprise import Apprise
+from apprise import AppriseAsset
 import requests
 import mock
 
 
-VALID_URLS = (
+TEST_URLS = (
+    ##################################
+    # NotifyBoxcar
+    ##################################
+    ('boxcar://', {
+        'instance': None,
+    }),
+    # No secret specified
+    ('boxcar://%s' % ('a' * 64), {
+        'instance': None,
+    }),
+    # An invalid access and secret key specified
+    ('boxcar://access.key/secret.key/', {
+        'instance': plugins.NotifyBoxcar,
+        # Thrown because there were no recipients specified
+        'exception': TypeError,
+    }),
+    # Provide both an access and a secret
+    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        'requests_response_code': requests.codes.created,
+    }),
+    # Test without image set
+    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        'requests_response_code': requests.codes.created,
+        # don't include an image by default
+        'include_image': False,
+    }),
+    # our access, secret and device are all 64 characters
+    # which is what we're doing here
+    ('boxcar://%s/%s/@tag1/tag2///%s/' % (
+        'a' * 64, 'b' * 64, 'd' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        'requests_response_code': requests.codes.created,
+    }),
+    # An invalid tag
+    ('boxcar://%s/%s/@%s' % ('a' * 64, 'b' * 64, 't' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        'requests_response_code': requests.codes.created,
+    }),
+    ('boxcar://:@/', {
+        'instance': None,
+    }),
+    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
+        'instance': plugins.NotifyBoxcar,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
+
     ##################################
     # NotifyJSON
     ##################################
@@ -64,7 +127,7 @@ VALID_URLS = (
         'instance': plugins.NotifyJSON,
         # force a failure
         'response': False,
-        'requests_response_code': 500,
+        'requests_response_code': requests.codes.internal_server_error,
     }),
     ('json://user:pass@localhost:8082', {
         'instance': plugins.NotifyJSON,
@@ -79,6 +142,76 @@ VALID_URLS = (
         'test_requests_exceptions': True,
     }),
 
+    ##################################
+    # NotifyKODI
+    ##################################
+    ('kodi://', {
+        'instance': None,
+    }),
+    ('kodis://', {
+        'instance': None,
+    }),
+    ('kodi://localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodi://user:pass@localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodi://localhost:8080', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodi://user:pass@localhost:8080', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodis://localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodis://user:pass@localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodis://localhost:8080/path/', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodis://user:pass@localhost:8080', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('kodi://localhost', {
+        'instance': plugins.NotifyXBMC,
+        # Experement with different notification types
+        'notify_type': NotifyType.WARNING,
+    }),
+    ('kodi://localhost', {
+        'instance': plugins.NotifyXBMC,
+        # Experement with different notification types
+        'notify_type': NotifyType.FAILURE,
+    }),
+    ('kodis://localhost:443', {
+        'instance': plugins.NotifyXBMC,
+        # don't include an image by default
+        'include_image': False,
+    }),
+    ('kodi://:@/', {
+        'instance': None,
+    }),
+    ('kodi://user:pass@localhost:8081', {
+        'instance': plugins.NotifyXBMC,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('kodi://user:pass@localhost:8082', {
+        'instance': plugins.NotifyXBMC,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('kodi://user:pass@localhost:8083', {
+        'instance': plugins.NotifyXBMC,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
+
     ##################################
     # NotifyMatterMost
     ##################################
@@ -123,7 +256,7 @@ VALID_URLS = (
         'instance': plugins.NotifyMatterMost,
         # force a failure
         'response': False,
-        'requests_response_code': 500,
+        'requests_response_code': requests.codes.internal_server_error,
     }),
     ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
         'instance': plugins.NotifyMatterMost,
@@ -137,6 +270,184 @@ VALID_URLS = (
         # is set and tests that we gracfully handle them
         'test_requests_exceptions': True,
     }),
+
+    ##################################
+    # NotifySlack
+    ##################################
+    ('slack://', {
+        'instance': None,
+    }),
+    ('slack://:@/', {
+        'instance': None,
+    }),
+    ('slack://T1JJ3T3L2', {
+        # Just Token 1 provided
+        'instance': None,
+    }),
+    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#hmm/#-invalid-', {
+        # No username specified; this is still okay as we sub in
+        # default; The one invalid channel is skipped when sending a message
+        'instance': plugins.NotifySlack,
+    }),
+    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#channel', {
+        # No username specified; this is still okay as we sub in
+        # default; The one invalid channel is skipped when sending a message
+        'instance': plugins.NotifySlack,
+        # don't include an image by default
+        'include_image': False,
+    }),
+    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/+id/%20/@id/', {
+        # + encoded id,
+        # @ userid
+        'instance': plugins.NotifySlack,
+    }),
+    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#nuxref', {
+        'instance': plugins.NotifySlack,
+    }),
+    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ', {
+        # Missing a channel
+        'exception': TypeError,
+    }),
+    ('slack://username@INVALID/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#cool', {
+        # invalid 1st Token
+        'exception': TypeError,
+    }),
+    ('slack://username@T1JJ3T3L2/INVALID/TIiajkdnlazkcOXrIdevi7FQ/#great', {
+        # invalid 2rd Token
+        'exception': TypeError,
+    }),
+    ('slack://username@T1JJ3T3L2/A1BRTD4JD/INVALID/#channel', {
+        # invalid 3rd Token
+        'exception': TypeError,
+    }),
+    ('slack://l2g@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#usenet', {
+        'instance': plugins.NotifySlack,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('slack://respect@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#a', {
+        'instance': plugins.NotifySlack,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('slack://notify@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#b', {
+        'instance': plugins.NotifySlack,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
+
+    ##################################
+    # NotifyKODI
+    ##################################
+    ('xbmc://', {
+        'instance': None,
+    }),
+    ('xbmc://localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('xbmc://user:pass@localhost', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('xbmc://localhost:8080', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('xbmc://user:pass@localhost:8080', {
+        'instance': plugins.NotifyXBMC,
+    }),
+    ('xbmc://localhost', {
+        'instance': plugins.NotifyXBMC,
+        # don't include an image by default
+        'include_image': False,
+    }),
+    ('xbmc://localhost', {
+        'instance': plugins.NotifyXBMC,
+        # Experement with different notification types
+        'notify_type': NotifyType.WARNING,
+    }),
+    ('xbmc://localhost', {
+        'instance': plugins.NotifyXBMC,
+        # Experement with different notification types
+        'notify_type': NotifyType.FAILURE,
+    }),
+    ('xbmc://:@/', {
+        'instance': None,
+    }),
+    ('xbmc://user:pass@localhost:8081', {
+        'instance': plugins.NotifyXBMC,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('xbmc://user:pass@localhost:8082', {
+        'instance': plugins.NotifyXBMC,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('xbmc://user:pass@localhost:8083', {
+        'instance': plugins.NotifyXBMC,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
+
+    ##################################
+    # NotifyXML
+    ##################################
+    ('xml://', {
+        'instance': None,
+    }),
+    ('xmls://', {
+        'instance': None,
+    }),
+    ('xml://localhost', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xml://user:pass@localhost', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xml://localhost:8080', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xml://user:pass@localhost:8080', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xmls://localhost', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xmls://user:pass@localhost', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xmls://localhost:8080/path/', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xmls://user:pass@localhost:8080', {
+        'instance': plugins.NotifyXML,
+    }),
+    ('xml://:@/', {
+        'instance': None,
+    }),
+    ('xml://user:pass@localhost:8081', {
+        'instance': plugins.NotifyXML,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('xml://user:pass@localhost:8082', {
+        'instance': plugins.NotifyXML,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('xml://user:pass@localhost:8083', {
+        'instance': plugins.NotifyXML,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
 )
 
 
@@ -149,7 +460,7 @@ def test_rest_plugins(mock_post, mock_get):
     """"""
 
     # iterate over our dictionary and test it out
-    for (url, meta) in VALID_URLS:
+    for (url, meta) in TEST_URLS:
 
         # Our expected instance
         instance = meta.get('instance', None)
@@ -166,7 +477,23 @@ def test_rest_plugins(mock_post, mock_get):
         # Allow us to force the server response code to be something other then
         # the defaults
         requests_response_code = meta.get(
-            'requests_response_code', 200 if response else 404)
+            'requests_response_code',
+            requests.codes.ok if response else requests.codes.not_found,
+        )
+
+        # Allow notification type override, otherwise default to INFO
+        notify_type = meta.get('notify_type', NotifyType.INFO)
+
+        # Whether or not we should include an image with our request; unless
+        # otherwise specified, we assume that images are to be included
+        include_image = meta.get('include_image', True)
+        if include_image:
+            # a default asset
+            asset = AppriseAsset()
+
+        else:
+            # Disable images
+            asset = AppriseAsset(image_path_mask=False, image_url_mask=False)
 
         test_requests_exceptions = meta.get(
             'test_requests_exceptions', False)
@@ -197,7 +524,8 @@ def test_rest_plugins(mock_post, mock_get):
             )
 
         try:
-            obj = Apprise.instantiate(url, suppress_exceptions=False)
+            obj = Apprise.instantiate(
+                url, asset=asset, suppress_exceptions=False)
 
             assert(exception is None)
 
@@ -224,7 +552,7 @@ def test_rest_plugins(mock_post, mock_get):
                     # check that we're as expected
                     assert obj.notify(
                         title='test', body='body',
-                        notify_type=NotifyType.INFO) == response
+                        notify_type=notify_type) == response
 
                 else:
                     for exception in test_requests_exceptions:
@@ -255,7 +583,7 @@ def test_rest_plugins(mock_post, mock_get):
 
         except AssertionError:
             # Don't mess with these entries
-            print('%s / %s' % (url, str(e)))
+            print('%s AssertionError' % url)
             raise
 
         except Exception as e:
@@ -263,3 +591,106 @@ def test_rest_plugins(mock_post, mock_get):
             print('%s / %s' % (url, str(e)))
             assert(exception is not None)
             assert(isinstance(e, exception))
+
+
+@mock.patch('requests.get')
+@mock.patch('requests.post')
+def test_notify_boxcar_plugin(mock_post, mock_get):
+    """"""
+    API: NotifyBoxcar() Extra Checks
+
+    """"""
+    # Generate some generic message types
+    device = 'A' * 64
+    tag = '@B' * 63
+
+    access = '-' * 64
+    secret = '_' * 64
+
+    # Initializes the plugin with recipients set to None
+    plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)
+
+    # Initializes the plugin with a valid access, but invalid access key
+    try:
+        plugins.NotifyBoxcar(access=None, secret=secret, recipients=None)
+        assert(False)
+
+    except TypeError:
+        # We should throw an exception for knowingly having an invalid
+        assert(True)
+
+    # Initializes the plugin with a valid access, but invalid secret key
+    try:
+        plugins.NotifyBoxcar(access=access, secret='invalid', recipients=None)
+        assert(False)
+
+    except TypeError:
+        # We should throw an exception for knowingly having an invalid key
+        assert(True)
+
+    # Initializes the plugin with a valid access, but invalid secret
+    try:
+        plugins.NotifyBoxcar(access=access, secret=None, recipients=None)
+        assert(False)
+
+    except TypeError:
+        # We should throw an exception for knowingly having an invalid
+        assert(True)
+
+    # Initializes the plugin with recipients list
+    # the below also tests our the variation of recipient types
+    plugins.NotifyBoxcar(
+        access=access, secret=secret, recipients=[device, tag])
+
+    mock_get.return_value = requests.Request()
+    mock_post.return_value = requests.Request()
+    mock_post.return_value.status_code = requests.codes.created
+    mock_get.return_value.status_code = requests.codes.created
+    # Test notifications without a body or a title
+    p = plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)
+    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is True
+
+
+@mock.patch('requests.get')
+@mock.patch('requests.post')
+def test_notify_slack_plugin(mock_post, mock_get):
+    """"""
+    API: NotifySlack() Extra Checks
+
+    """"""
+
+    # Initialize some generic (but valid) tokens
+    token_a = 'A' * 9
+    token_b = 'B' * 9
+    token_c = 'c' * 24
+
+    # Support strings
+    channels = 'chan1,#chan2,+id,@user,,,'
+
+    obj = plugins.NotifySlack(
+        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels)
+    assert(len(obj.channels) == 4)
+    mock_get.return_value = requests.Request()
+    mock_post.return_value = requests.Request()
+    mock_post.return_value.status_code = requests.codes.ok
+    mock_get.return_value.status_code = requests.codes.ok
+
+    # Empty Channel list
+    try:
+        plugins.NotifySlack(
+            token_a=token_a, token_b=token_b, token_c=token_c,
+            channels=None)
+        assert(False)
+
+    except TypeError:
+        # we'll thrown because an empty list of channels was provided
+        assert(True)
+
+    # Test include_image
+    obj = plugins.NotifySlack(
+        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels,
+        include_image=True)
+
+    # This call includes an image with it's payload:
+    assert obj.notify(title='title', body='body',
+                      notify_type=NotifyType.INFO) is True
",add tests for invalid urls in apprise_notifications,-13.57,17,431
0c0449fc70c462609e2ee6975bed5d3cefb98a6c,fixed commented typo,NotifyBoxcar.py,"# -*- coding: utf-8 -*-
#
# Boxcar Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from json import dumps
import requests
import re
from time import time
import hmac
from hashlib import sha1
try:
    from urlparse import urlparse

except ImportError:
    from urllib.parse import urlparse

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP

from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Default to sending to all devices if nothing is specified
DEFAULT_TAG = '@all'

# The tags value is an structure containing an array of strings defining the
# list of tagged devices that the notification need to be send to, and a
# boolean operator (and / or) that defines the criteria to match devices
# against those tags.
IS_TAG = re.compile(r'^[@](?P<name>[A-Z0-9]{1,63})$', re.I)

# Device tokens are only referenced when developing.
# it's not likely you'll send a message directly to a device, but
# if you do; this plugin supports it.
IS_DEVICETOKEN = re.compile(r'^[A-Z0-9]{64}$', re.I)

# Both an access key and seret key are created and assigned to each project
# you create on the boxcar website
VALIDATE_ACCESS = re.compile(r'[A-Z0-9_-]{64}', re.I)
VALIDATE_SECRET = re.compile(r'[A-Z0-9_-]{64}', re.I)

# Used to break apart list of potential tags by their delimiter
# into a usable list.
TAGS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Image Support (72x72)
BOXCAR_IMAGE_XY = NotifyImageSize.XY_72


class NotifyBoxcar(NotifyBase):
    """"""
    A wrapper for Boxcar Notifications
    """"""

    # All boxcar notifications are secure
    secure_protocol = 'boxcar'

    # Boxcar URL
    notify_url = 'https://boxcar-api.io/api/push/'

    def __init__(self, access, secret, recipients=None, **kwargs):
        """"""
        Initialize Boxcar Object
        """"""
        super(NotifyBoxcar, self).__init__(
            title_maxlen=250, body_maxlen=10000,
            image_size=BOXCAR_IMAGE_XY, **kwargs)

        # Initialize tag list
        self.tags = list()

        # Initialize device_token list
        self.device_tokens = list()

        try:
            # Access Key (associated with project)
            self.access = access.strip()

        except AttributeError:
            self.logger.warning(
                'The specified access key specified is invalid.',
            )
            raise TypeError(
                'The specified access key specified is invalid.',
            )

        try:
            # Secret Key (associated with project)
            self.secret = secret.strip()

        except AttributeError:
            self.logger.warning(
                'The specified secret key specified is invalid.',
            )
            raise TypeError(
                'The specified secret key specified is invalid.',
            )

        if not VALIDATE_ACCESS.match(self.access):
            self.logger.warning(
                'The access key specified (%s) is invalid.' % self.access,
            )
            raise TypeError(
                'The access key specified (%s) is invalid.' % self.access,
            )

        if not VALIDATE_SECRET.match(self.secret):
            self.logger.warning(
                'The secret key specified (%s) is invalid.' % self.secret,
            )
            raise TypeError(
                'The secret key specified (%s) is invalid.' % self.secret,
            )

        if not recipients:
            self.tags.append(DEFAULT_TAG)
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = [x for x in filter(bool, TAGS_LIST_DELIM.split(
                recipients,
            ))]

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            if IS_TAG.match(recipient):
                # store valid tag/alias
                self.tags.append(IS_TAG.match(recipient).group('name'))

            elif IS_DEVICETOKEN.match(recipient):
                # store valid device
                self.device_tokens.append(recipient)

            else:
                self.logger.warning(
                    'Dropped invalid tag/alias/device_token '
                    '(%s) specified.' % recipient,
                )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Boxcar Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare Boxcar Object
        payload = {
            'aps': {
                'badge': 'auto',
                'alert': '',
            },
            'expires': str(int(time() + 30)),
        }

        if title:
            payload['aps']['@title'] = title

        if body:
            payload['aps']['alert'] = body

        if self.tags:
            payload['tags'] = {'or': self.tags}

        if self.device_tokens:
            payload['device_tokens'] = self.device_tokens

        # Source picture should be <= 450 DP wide, ~2:1 aspect.
        image_url = self.image_url(notify_type)
        if image_url:
            # Set our image
            payload['@img'] = image_url

        # Acquire our hostname
        host = urlparse(self.notify_url).hostname

        # Calculate signature.
        str_to_sign = ""%s\n%s\n%s\n%s"" % (
            ""POST"", host, ""/api/push"", dumps(payload))

        h = hmac.new(
            bytearray(self.secret, 'utf-8'),
            bytearray(str_to_sign, 'utf-8'),
            sha1,
        )

        params = self.urlencode({
            ""publishkey"": self.access,
            ""signature"": h.hexdigest(),
        })

        notify_url = '%s?%s' % (self.notify_url, params)
        self.logger.debug('Boxcar POST URL: %s (cert_verify=%r)' % (
            notify_url, self.verify_certificate,
        ))
        self.logger.debug('Boxcar Payload: %s' % str(payload))

        try:
            r = requests.post(
                notify_url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )

            # Boxcar returns 201 (Created) when successful
            if r.status_code != requests.codes.created:
                try:
                    self.logger.warning(
                        'Failed to send Boxcar notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send Boxcar notification '
                        '(error=%s).' % (
                            r.status_code))

                # self.logger.debug('Response Details: %s' % r.raw.read())

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending Boxcar '
                'notification to %s.' % (host))

            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = NotifyBase.parse_url(url, verify_host=False)

        if not results:
            # We're done early
            return None

        # The first token is stored in the hostnamee
        access = results['host']

        # Now fetch the remaining tokens
        secret = NotifyBase.split_path(results['fullpath'])[0]

        # Our recipients
        recipients = ','.join(
            NotifyBase.split_path(results['fullpath'])[1:])

        if not (access and secret):
            # If we did not recive an access and/or secret code
            # then we're done
            return None

        # Store our required content
        results['recipients'] = recipients if recipients else None
        results['access'] = access
        results['secret'] = secret

        return results
","# -*- coding: utf-8 -*-
#
# Boxcar Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from json import dumps
import requests
import re
from time import time
import hmac
from hashlib import sha1
try:
    from urlparse import urlparse

except ImportError:
    from urllib.parse import urlparse

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP

from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Default to sending to all devices if nothing is specified
DEFAULT_TAG = '@all'

# The tags value is an structure containing an array of strings defining the
# list of tagged devices that the notification need to be send to, and a
# boolean operator (and / or) that defines the criteria to match devices
# against those tags.
IS_TAG = re.compile(r'^[@](?P<name>[A-Z0-9]{1,63})$', re.I)

# Device tokens are only referenced when developing.
# it's not likely you'll send a message directly to a device, but
# if you do; this plugin supports it.
IS_DEVICETOKEN = re.compile(r'^[A-Z0-9]{64}$', re.I)

# Both an access key and seret key are created and assigned to each project
# you create on the boxcar website
VALIDATE_ACCESS = re.compile(r'[A-Z0-9_-]{64}', re.I)
VALIDATE_SECRET = re.compile(r'[A-Z0-9_-]{64}', re.I)

# Used to break apart list of potential tags by their delimiter
# into a usable list.
TAGS_LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')

# Image Support (72x72)
BOXCAR_IMAGE_XY = NotifyImageSize.XY_72


class NotifyBoxcar(NotifyBase):
    """"""
    A wrapper for Boxcar Notifications
    """"""

    # All boxcar notifications are secure
    secure_protocol = 'boxcar'

    # Boxcar URL
    notify_url = 'https://boxcar-api.io/api/push/'

    def __init__(self, access, secret, recipients=None, **kwargs):
        """"""
        Initialize Boxcar Object
        """"""
        super(NotifyBoxcar, self).__init__(
            title_maxlen=250, body_maxlen=10000,
            image_size=BOXCAR_IMAGE_XY, **kwargs)

        # Initialize tag list
        self.tags = list()

        # Initialize device_token list
        self.device_tokens = list()

        try:
            # Access Key (associated with project)
            self.access = access.strip()

        except AttributeError:
            self.logger.warning(
                'The specified access key specified is invalid.',
            )
            raise TypeError(
                'The specified access key specified is invalid.',
            )

        try:
            # Secret Key (associated with project)
            self.secret = secret.strip()

        except AttributeError:
            self.logger.warning(
                'The specified secret key specified is invalid.',
            )
            raise TypeError(
                'The specified secret key specified is invalid.',
            )

        if not VALIDATE_ACCESS.match(self.access):
            self.logger.warning(
                'The access key specified (%s) is invalid.' % self.access,
            )
            raise TypeError(
                'The access key specified (%s) is invalid.' % self.access,
            )

        if not VALIDATE_SECRET.match(self.secret):
            self.logger.warning(
                'The secret key specified (%s) is invalid.' % self.secret,
            )
            raise TypeError(
                'The secret key specified (%s) is invalid.' % self.secret,
            )

        if not recipients:
            self.tags.append(DEFAULT_TAG)
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = [x for x in filter(bool, TAGS_LIST_DELIM.split(
                recipients,
            ))]

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            if IS_TAG.match(recipient):
                # store valid tag/alias
                self.tags.append(IS_TAG.match(recipient).group('name'))

            elif IS_DEVICETOKEN.match(recipient):
                # store valid device
                self.device_tokens.append(recipient)

            else:
                self.logger.warning(
                    'Dropped invalid tag/alias/device_token '
                    '(%s) specified.' % recipient,
                )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Boxcar Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare Boxcar Object
        payload = {
            'aps': {
                'badge': 'auto',
                'alert': '',
            },
            'expires': str(int(time() + 30)),
        }

        if title:
            payload['aps']['@title'] = title

        if body:
            payload['aps']['alert'] = body

        if self.tags:
            payload['tags'] = {'or': self.tags}

        if self.device_tokens:
            payload['device_tokens'] = self.device_tokens

        # Source picture should be <= 450 DP wide, ~2:1 aspect.
        image_url = self.image_url(notify_type)
        if image_url:
            # Set our image
            payload['@img'] = image_url

        # Acquire our hostname
        host = urlparse(self.notify_url).hostname

        # Calculate signature.
        str_to_sign = ""%s\n%s\n%s\n%s"" % (
            ""POST"", host, ""/api/push"", dumps(payload))

        h = hmac.new(
            bytearray(self.secret, 'utf-8'),
            bytearray(str_to_sign, 'utf-8'),
            sha1,
        )

        params = self.urlencode({
            ""publishkey"": self.access,
            ""signature"": h.hexdigest(),
        })

        notify_url = '%s?%s' % (self.notify_url, params)
        self.logger.debug('Boxcar POST URL: %s (cert_verify=%r)' % (
            notify_url, self.verify_certificate,
        ))
        self.logger.debug('Boxcar Payload: %s' % str(payload))

        try:
            r = requests.post(
                notify_url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )

            # Boxcar returns 201 (Created) when successful
            if r.status_code != requests.codes.created:
                try:
                    self.logger.warning(
                        'Failed to send Boxcar notification: '
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send Boxcar notification '
                        '(error=%s).' % (
                            r.status_code))

                # self.logger.debug('Response Details: %s' % r.raw.read())

                # Return; we're done
                return False

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending Boxcar '
                'notification to %s.' % (host))

            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns it broken apart into a dictionary.

        """"""
        results = NotifyBase.parse_url(url, verify_host=False)

        if not results:
            # We're done early
            return None

        # The first token is stored in the hostname
        access = results['host']

        # Now fetch the remaining tokens
        secret = NotifyBase.split_path(results['fullpath'])[0]

        # Our recipients
        recipients = ','.join(
            NotifyBase.split_path(results['fullpath'])[1:])

        if not (access and secret):
            # If we did not recive an access and/or secret code
            # then we're done
            return None

        # Store our required content
        results['recipients'] = recipients if recipients else None
        results['access'] = access
        results['secret'] = secret

        return results
","@@ -264,7 +264,7 @@ class NotifyBoxcar(NotifyBase):
             # We're done early
             return None
 
-        # The first token is stored in the hostnamee
+        # The first token is stored in the hostname
         access = results['host']
 
         # Now fetch the remaining tokens
",add missing comment,0.0,0,0
0c0449fc70c462609e2ee6975bed5d3cefb98a6c,fixed commented typo,NotifySlack.py,"# -*- coding: utf-8 -*-
#
# Slack Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.slack.com
# Specifically https://my.slack.com/services/new/incoming-webhook/
# to create a new incoming webhook for your account. You'll need to
# follow the wizard to pre-determine the channel(s) you want your
# message to broadcast to, and when you're complete, you will
# recieve a URL that looks something like this:
# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ
#                                     ^         ^               ^
#                                     |         |               |
#  These are important <--------------^---------^---------------^
#
#
import re
import requests
from json import dumps
from time import time

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
#  /AAAAAAAAA/........./........................
VALIDATE_TOKEN_A = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./BBBBBBBBB/........................
VALIDATE_TOKEN_B = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./........./CCCCCCCCCCCCCCCCCCCCCCCC
VALIDATE_TOKEN_C = re.compile(r'[A-Za-z0-9]{24}')

# Default User
SLACK_DEFAULT_USER = 'apprise'

# Extend HTTP Error Messages
SLACK_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
SLACK_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of channels
CHANNEL_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')

# Used to detect a channel
IS_CHANNEL_RE = re.compile(r'[+#@]?([A-Z0-9_]{1,32})', re.I)

# Image Support (72x72)
SLACK_IMAGE_XY = NotifyImageSize.XY_72


class NotifySlack(NotifyBase):
    """"""
    A wrapper for Slack Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'slack'

    # Slack uses the http protocol with JSON requests
    notify_url = 'https://hooks.slack.com/services'

    def __init__(self, token_a, token_b, token_c, channels, **kwargs):
        """"""
        Initialize Slack Object
        """"""
        super(NotifySlack, self).__init__(
            title_maxlen=250, body_maxlen=1000,
            image_size=SLACK_IMAGE_XY, **kwargs)

        if not VALIDATE_TOKEN_A.match(token_a.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % token_a,
            )
            raise TypeError(
                'The first API Token specified (%s) is invalid.' % token_a,
            )

        # The token associated with the account
        self.token_a = token_a.strip()

        if not VALIDATE_TOKEN_B.match(token_b.strip()):
            self.logger.warning(
                'The second API Token specified (%s) is invalid.' % token_b,
            )
            raise TypeError(
                'The second API Token specified (%s) is invalid.' % token_b,
            )

        # The token associated with the account
        self.token_b = token_b.strip()

        if not VALIDATE_TOKEN_C.match(token_c.strip()):
            self.logger.warning(
                'The third API Token specified (%s) is invalid.' % token_c,
            )
            raise TypeError(
                'The third API Token specified (%s) is invalid.' % token_c,
            )

        # The token associated with the account
        self.token_c = token_c.strip()

        if not self.user:
            self.logger.warning(
                'No user was specified; using %s.' % SLACK_DEFAULT_USER)
            self.user = SLACK_DEFAULT_USER

        if compat_is_basestring(channels):
            self.channels = [x for x in filter(bool, CHANNEL_LIST_DELIM.split(
                channels,
            ))]

        elif isinstance(channels, (set, tuple, list)):
            self.channels = channels

        else:
            self.channels = list()

        if len(self.channels) == 0:
            self.logger.warning('No channel(s) were specified.')
            raise TypeError('No channel(s) were specified.')

        # Formatting requirements are defined here:
        # https://api.slack.com/docs/message-formatting
        self._re_formatting_map = {
            # New lines must become the string version
            '\r\*\n': '\\n',
            # Escape other special characters
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
        }

        # Iterate over above list and store content accordingly
        self._re_formatting_rules = re.compile(
            r'(' + '|'.join(self._re_formatting_map.keys()) + r')',
            re.IGNORECASE,
        )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Slack Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        notify_okay = True

        # Perform Formatting
        title = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], title,
        )
        body = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], body,
        )
        url = '%s/%s/%s/%s' % (
            self.notify_url,
            self.token_a,
            self.token_b,
            self.token_c,
        )

        image_url = self.image_url(notify_type)

        # Create a copy of the channel list
        channels = list(self.channels)
        while len(channels):
            channel = channels.pop(0)
            if not IS_CHANNEL_RE.match(channel):
                self.logger.warning(
                    ""The specified channel '%s' is invalid; skipping."" % (
                        channel,
                    )
                )
                continue

            if len(channel) > 1 and channel[0] == '+':
                # Treat as encoded id if prefixed with a +
                _channel = channel[1:]

            elif len(channel) > 1 and channel[0] == '@':
                # Treat @ value 'as is'
                _channel = channel

            else:
                # Prefix with channel hash tag
                _channel = '#%s' % channel

            # prepare JSON Object
            payload = {
                'channel': _channel,
                'username': self.user,
                # Use Markdown language
                'mrkdwn': True,
                'attachments': [{
                    'title': title,
                    'text': body,
                    'color': self.color(notify_type),
                    # Time
                    'ts': time(),
                    'footer': self.app_id,
                }],
            }

            if image_url:
                payload['attachments'][0]['footer_icon'] = image_url

            self.logger.debug('Slack POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Slack Payload: %s' % str(payload))
            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification: %s (error=%s).' % (
                                channel,
                                SLACK_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except KeyError:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification (error=%s).' % (
                                channel,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    notify_okay = False

            except requests.RequestException as e:
                self.logger.warning(
                    'A Connection error occured sending Slack:%s ' % (
                        channel) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                notify_okay = False

            if len(channels):
                # Prevent thrashing requests
                self.throttle()

        return notify_okay

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostnamee
        token_a = results['host']

        # Now fetch the remaining tokens
        try:
            token_b, token_c = [x for x in filter(
                bool, NotifyBase.split_path(results['fullpath']))][0:2]

        except (ValueError, AttributeError, IndexError):
            # We're done
            return None

        channels = [x for x in filter(
            bool, NotifyBase.split_path(results['fullpath']))][2:]

        results['token_a'] = token_a
        results['token_b'] = token_b
        results['token_c'] = token_c
        results['channels'] = channels

        return results
","# -*- coding: utf-8 -*-
#
# Slack Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.slack.com
# Specifically https://my.slack.com/services/new/incoming-webhook/
# to create a new incoming webhook for your account. You'll need to
# follow the wizard to pre-determine the channel(s) you want your
# message to broadcast to, and when you're complete, you will
# recieve a URL that looks something like this:
# https://hooks.slack.com/services/T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ
#                                     ^         ^               ^
#                                     |         |               |
#  These are important <--------------^---------^---------------^
#
#
import re
import requests
from json import dumps
from time import time

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
#  /AAAAAAAAA/........./........................
VALIDATE_TOKEN_A = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./BBBBBBBBB/........................
VALIDATE_TOKEN_B = re.compile(r'[A-Z0-9]{9}')

# Token required as part of the API request
#  /........./........./CCCCCCCCCCCCCCCCCCCCCCCC
VALIDATE_TOKEN_C = re.compile(r'[A-Za-z0-9]{24}')

# Default User
SLACK_DEFAULT_USER = 'apprise'

# Extend HTTP Error Messages
SLACK_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
SLACK_HTTP_ERROR_MAP.update({
    401: 'Unauthorized - Invalid Token.',
})

# Used to break path apart into list of channels
CHANNEL_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')

# Used to detect a channel
IS_CHANNEL_RE = re.compile(r'[+#@]?([A-Z0-9_]{1,32})', re.I)

# Image Support (72x72)
SLACK_IMAGE_XY = NotifyImageSize.XY_72


class NotifySlack(NotifyBase):
    """"""
    A wrapper for Slack Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'slack'

    # Slack uses the http protocol with JSON requests
    notify_url = 'https://hooks.slack.com/services'

    def __init__(self, token_a, token_b, token_c, channels, **kwargs):
        """"""
        Initialize Slack Object
        """"""
        super(NotifySlack, self).__init__(
            title_maxlen=250, body_maxlen=1000,
            image_size=SLACK_IMAGE_XY, **kwargs)

        if not VALIDATE_TOKEN_A.match(token_a.strip()):
            self.logger.warning(
                'The first API Token specified (%s) is invalid.' % token_a,
            )
            raise TypeError(
                'The first API Token specified (%s) is invalid.' % token_a,
            )

        # The token associated with the account
        self.token_a = token_a.strip()

        if not VALIDATE_TOKEN_B.match(token_b.strip()):
            self.logger.warning(
                'The second API Token specified (%s) is invalid.' % token_b,
            )
            raise TypeError(
                'The second API Token specified (%s) is invalid.' % token_b,
            )

        # The token associated with the account
        self.token_b = token_b.strip()

        if not VALIDATE_TOKEN_C.match(token_c.strip()):
            self.logger.warning(
                'The third API Token specified (%s) is invalid.' % token_c,
            )
            raise TypeError(
                'The third API Token specified (%s) is invalid.' % token_c,
            )

        # The token associated with the account
        self.token_c = token_c.strip()

        if not self.user:
            self.logger.warning(
                'No user was specified; using %s.' % SLACK_DEFAULT_USER)
            self.user = SLACK_DEFAULT_USER

        if compat_is_basestring(channels):
            self.channels = [x for x in filter(bool, CHANNEL_LIST_DELIM.split(
                channels,
            ))]

        elif isinstance(channels, (set, tuple, list)):
            self.channels = channels

        else:
            self.channels = list()

        if len(self.channels) == 0:
            self.logger.warning('No channel(s) were specified.')
            raise TypeError('No channel(s) were specified.')

        # Formatting requirements are defined here:
        # https://api.slack.com/docs/message-formatting
        self._re_formatting_map = {
            # New lines must become the string version
            '\r\*\n': '\\n',
            # Escape other special characters
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
        }

        # Iterate over above list and store content accordingly
        self._re_formatting_rules = re.compile(
            r'(' + '|'.join(self._re_formatting_map.keys()) + r')',
            re.IGNORECASE,
        )

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Slack Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        notify_okay = True

        # Perform Formatting
        title = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], title,
        )
        body = self._re_formatting_rules.sub(  # pragma: no branch
            lambda x: self._re_formatting_map[x.group()], body,
        )
        url = '%s/%s/%s/%s' % (
            self.notify_url,
            self.token_a,
            self.token_b,
            self.token_c,
        )

        image_url = self.image_url(notify_type)

        # Create a copy of the channel list
        channels = list(self.channels)
        while len(channels):
            channel = channels.pop(0)
            if not IS_CHANNEL_RE.match(channel):
                self.logger.warning(
                    ""The specified channel '%s' is invalid; skipping."" % (
                        channel,
                    )
                )
                continue

            if len(channel) > 1 and channel[0] == '+':
                # Treat as encoded id if prefixed with a +
                _channel = channel[1:]

            elif len(channel) > 1 and channel[0] == '@':
                # Treat @ value 'as is'
                _channel = channel

            else:
                # Prefix with channel hash tag
                _channel = '#%s' % channel

            # prepare JSON Object
            payload = {
                'channel': _channel,
                'username': self.user,
                # Use Markdown language
                'mrkdwn': True,
                'attachments': [{
                    'title': title,
                    'text': body,
                    'color': self.color(notify_type),
                    # Time
                    'ts': time(),
                    'footer': self.app_id,
                }],
            }

            if image_url:
                payload['attachments'][0]['footer_icon'] = image_url

            self.logger.debug('Slack POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Slack Payload: %s' % str(payload))
            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )
                if r.status_code != requests.codes.ok:
                    # We had a problem
                    try:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification: %s (error=%s).' % (
                                channel,
                                SLACK_HTTP_ERROR_MAP[r.status_code],
                                r.status_code))

                    except KeyError:
                        self.logger.warning(
                            'Failed to send Slack:%s '
                            'notification (error=%s).' % (
                                channel,
                                r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Return; we're done
                    notify_okay = False

            except requests.RequestException as e:
                self.logger.warning(
                    'A Connection error occured sending Slack:%s ' % (
                        channel) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                notify_okay = False

            if len(channels):
                # Prevent thrashing requests
                self.throttle()

        return notify_okay

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostname
        token_a = results['host']

        # Now fetch the remaining tokens
        try:
            token_b, token_c = [x for x in filter(
                bool, NotifyBase.split_path(results['fullpath']))][0:2]

        except (ValueError, AttributeError, IndexError):
            # We're done
            return None

        channels = [x for x in filter(
            bool, NotifyBase.split_path(results['fullpath']))][2:]

        results['token_a'] = token_a
        results['token_b'] = token_b
        results['token_c'] = token_c
        results['channels'] = channels

        return results
","@@ -292,7 +292,7 @@ class NotifySlack(NotifyBase):
 
         # Apply our settings now
 
-        # The first token is stored in the hostnamee
+        # The first token is stored in the hostname
         token_a = results['host']
 
         # Now fetch the remaining tokens
",add comment,0.0,0,0
0c0449fc70c462609e2ee6975bed5d3cefb98a6c,fixed commented typo,NotifyTelegram.py,"# -*- coding: utf-8 -*-
#
# Telegram Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.telegram.org
# You need to create a bot and acquire it's Token Identifier (bot_token)
#
# Basically you need to create a chat with a user called the 'BotFather'
# and type: /newbot
#
# Then follow through the wizard, it will provide you an api key
# that looks like this:123456789:alphanumeri_characters
#
# For each chat_id a bot joins will have a chat_id associated with it.
# You will need this value as well to send the notification.
#
# Log into the webpage version of the site if you like by accessing:
#    https://web.telegram.org
#
# You can't check out to see if your entry is working using:
#    https://api.telegram.org/botAPI_KEY/getMe
#
#    Pay attention to the word 'bot' that must be present infront of your
#    api key that the BotFather gave you.
#
#  For example, a url might look like this:
#    https://api.telegram.org/bot123456789:alphanumeri_characters/getMe
#
import requests
import re

from json import loads
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyFormat
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
# allow the word 'bot' infront
VALIDATE_BOT_TOKEN = re.compile(
    r'^(bot)?(?P<key>[0-9]+:[a-z0-9_-]+)/*$',
    re.IGNORECASE,
)

# Chat ID is required
# If the Chat ID is positive, then it's addressed to a single person
# If the Chat ID is negative, then it's targeting a group
IS_CHAT_ID_RE = re.compile(
    r'^(@*(?P<idno>-?[0-9]{1,32})|(?P<name>[a-z_-][a-z0-9_-]+))$',
    re.IGNORECASE,
)

# Used to break path apart into list of chat identifiers
CHAT_ID_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')


class NotifyTelegram(NotifyBase):
    """"""
    A wrapper for Telegram Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'tgram'

    # Telegram uses the http protocol with JSON requests
    notify_url = 'https://api.telegram.org/bot'

    def __init__(self, bot_token, chat_ids, notify_format=NotifyFormat.HTML,
                 **kwargs):
        """"""
        Initialize Telegram Object
        """"""
        super(NotifyTelegram, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            notify_format=notify_format,
            **kwargs)

        try:
            self.bot_token = bot_token.strip()

        except AttributeError:
            # Token was None
            self.logger.warning('No Bot Token was specified.')
            raise TypeError('No Bot Token was specified.')

        result = VALIDATE_BOT_TOKEN.match(self.bot_token)
        if not result:
            raise TypeError(
                'The Bot Token specified (%s) is invalid.' % bot_token,
            )

        # Store our Bot Token
        self.bot_token = result.group('key')

        if compat_is_basestring(chat_ids):
            self.chat_ids = [x for x in filter(bool, CHAT_ID_LIST_DELIM.split(
                chat_ids,
            ))]

        elif isinstance(chat_ids, (set, tuple, list)):
            self.chat_ids = list(chat_ids)

        else:
            self.chat_ids = list()

        if self.user:
            # Treat this as a channel too
            self.chat_ids.append(self.user)

        if len(self.chat_ids) == 0:
            self.logger.warning('No chat_id(s) were specified.')
            raise TypeError('No chat_id(s) were specified.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Telegram Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        has_error = False

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'sendMessage'
        )

        payload = {}

        if self.notify_format == NotifyFormat.HTML:
            # HTML
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (title, body)

        else:
            # Text
            # payload['parse_mode'] = 'Markdown'
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (
                NotifyBase.escape_html(title),
                NotifyBase.escape_html(body),
            )

        # Create a copy of the chat_ids list
        chat_ids = list(self.chat_ids)
        while len(chat_ids):
            chat_id = chat_ids.pop(0)
            chat_id = IS_CHAT_ID_RE.match(chat_id)
            if not chat_id:
                self.logger.warning(
                    ""The specified chat_id '%s' is invalid; skipping."" % (
                        chat_id,
                    )
                )
                has_error = True
                continue

            if chat_id.group('name') is not None:
                # Name
                payload['chat_id'] = '@%s' % chat_id.group('name')

            else:
                # ID
                payload['chat_id'] = chat_id.group('idno')

            self.logger.debug('Telegram POST URL: %s' % url)
            self.logger.debug('Telegram POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Telegram Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )

                if r.status_code != requests.codes.ok:
                    # We had a problem

                    try:
                        # Try to get the error message if we can:
                        error_msg = loads(r.text)['description']

                    except:
                        error_msg = None

                    try:
                        if error_msg:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: (%s) %s.' % (
                                    payload['chat_id'],
                                    r.status_code, error_msg))

                        else:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: %s (error=%s).' % (
                                    payload['chat_id'],
                                    HTTP_ERROR_MAP[r.status_code],
                                    r.status_code))

                    except KeyError:
                        self.logger.warning(
                            'Failed to send Telegram:%s '
                            'notification (error=%s).' % (
                                payload['chat_id'], r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Flag our error
                    has_error = True

            except requests.RequestException as e:
                self.logger.warning(
                    'A Connection error occured sending Telegram:%s ' % (
                        payload['chat_id']) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            finally:
                if len(chat_ids):
                    # Prevent thrashing requests
                    self.throttle()

        return not has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        # This is a dirty hack; but it's the only work around to
        # tgram:// messages since the bot_token has a colon in it.
        # It invalidates an normal URL.

        # This hack searches for this bogus URL and corrects it
        # so we can properly load it further down. The other
        # alternative is to ask users to actually change the colon
        # into a slash (which will work too), but it's more likely
        # to cause confusion... So this is the next best thing
        try:
            tgram = re.match(
                r'(?P<protocol>%s://)(bot)?(?P<prefix>([a-z0-9_-]+)'
                r'(:[a-z0-9_-]+)?@)?(?P<btoken_a>[0-9]+):+'
                r'(?P<remaining>.*)$' % NotifyTelegram.secure_protocol,
                url, re.I)

        except (TypeError, AttributeError):
            # url is bad; force tgram to be None
            tgram = None

        if not tgram:
            # Content is simply not parseable
            return None

        if tgram.group('prefix'):
            # Try again
            results = NotifyBase.parse_url(
                '%s%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('prefix'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        else:
            # Try again
            results = NotifyBase.parse_url(
                '%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        # The first token is stored in the hostnamee
        bot_token_a = results['host']

        # Now fetch the remaining tokens
        bot_token_b = [x for x in filter(
            bool, NotifyBase.split_path(results['fullpath']))][0]

        bot_token = '%s:%s' % (bot_token_a, bot_token_b)

        chat_ids = ','.join(
            [x for x in filter(
                bool, NotifyBase.split_path(results['fullpath']))][1:])

        # Store our bot token
        results['bot_token'] = bot_token

        # Store our chat ids
        results['chat_ids'] = chat_ids

        return results
","# -*- coding: utf-8 -*-
#
# Telegram Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# To use this plugin, you need to first access https://api.telegram.org
# You need to create a bot and acquire it's Token Identifier (bot_token)
#
# Basically you need to create a chat with a user called the 'BotFather'
# and type: /newbot
#
# Then follow through the wizard, it will provide you an api key
# that looks like this:123456789:alphanumeri_characters
#
# For each chat_id a bot joins will have a chat_id associated with it.
# You will need this value as well to send the notification.
#
# Log into the webpage version of the site if you like by accessing:
#    https://web.telegram.org
#
# You can't check out to see if your entry is working using:
#    https://api.telegram.org/botAPI_KEY/getMe
#
#    Pay attention to the word 'bot' that must be present infront of your
#    api key that the BotFather gave you.
#
#  For example, a url might look like this:
#    https://api.telegram.org/bot123456789:alphanumeri_characters/getMe
#
import requests
import re

from json import loads
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyFormat
from ..common import NotifyImageSize
from ..utils import compat_is_basestring

# Token required as part of the API request
# allow the word 'bot' infront
VALIDATE_BOT_TOKEN = re.compile(
    r'^(bot)?(?P<key>[0-9]+:[a-z0-9_-]+)/*$',
    re.IGNORECASE,
)

# Chat ID is required
# If the Chat ID is positive, then it's addressed to a single person
# If the Chat ID is negative, then it's targeting a group
IS_CHAT_ID_RE = re.compile(
    r'^(@*(?P<idno>-?[0-9]{1,32})|(?P<name>[a-z_-][a-z0-9_-]+))$',
    re.IGNORECASE,
)

# Used to break path apart into list of chat identifiers
CHAT_ID_LIST_DELIM = re.compile(r'[ \t\r\n,#\\/]+')


class NotifyTelegram(NotifyBase):
    """"""
    A wrapper for Telegram Notifications
    """"""

    # The default secure protocol
    secure_protocol = 'tgram'

    # Telegram uses the http protocol with JSON requests
    notify_url = 'https://api.telegram.org/bot'

    def __init__(self, bot_token, chat_ids, notify_format=NotifyFormat.HTML,
                 **kwargs):
        """"""
        Initialize Telegram Object
        """"""
        super(NotifyTelegram, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            notify_format=notify_format,
            **kwargs)

        try:
            self.bot_token = bot_token.strip()

        except AttributeError:
            # Token was None
            self.logger.warning('No Bot Token was specified.')
            raise TypeError('No Bot Token was specified.')

        result = VALIDATE_BOT_TOKEN.match(self.bot_token)
        if not result:
            raise TypeError(
                'The Bot Token specified (%s) is invalid.' % bot_token,
            )

        # Store our Bot Token
        self.bot_token = result.group('key')

        if compat_is_basestring(chat_ids):
            self.chat_ids = [x for x in filter(bool, CHAT_ID_LIST_DELIM.split(
                chat_ids,
            ))]

        elif isinstance(chat_ids, (set, tuple, list)):
            self.chat_ids = list(chat_ids)

        else:
            self.chat_ids = list()

        if self.user:
            # Treat this as a channel too
            self.chat_ids.append(self.user)

        if len(self.chat_ids) == 0:
            self.logger.warning('No chat_id(s) were specified.')
            raise TypeError('No chat_id(s) were specified.')

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Telegram Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # error tracking (used for function return)
        has_error = False

        url = '%s%s/%s' % (
            self.notify_url,
            self.bot_token,
            'sendMessage'
        )

        payload = {}

        if self.notify_format == NotifyFormat.HTML:
            # HTML
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (title, body)

        else:
            # Text
            # payload['parse_mode'] = 'Markdown'
            payload['parse_mode'] = 'HTML'
            payload['text'] = '<b>%s</b>\r\n%s' % (
                NotifyBase.escape_html(title),
                NotifyBase.escape_html(body),
            )

        # Create a copy of the chat_ids list
        chat_ids = list(self.chat_ids)
        while len(chat_ids):
            chat_id = chat_ids.pop(0)
            chat_id = IS_CHAT_ID_RE.match(chat_id)
            if not chat_id:
                self.logger.warning(
                    ""The specified chat_id '%s' is invalid; skipping."" % (
                        chat_id,
                    )
                )
                has_error = True
                continue

            if chat_id.group('name') is not None:
                # Name
                payload['chat_id'] = '@%s' % chat_id.group('name')

            else:
                # ID
                payload['chat_id'] = chat_id.group('idno')

            self.logger.debug('Telegram POST URL: %s' % url)
            self.logger.debug('Telegram POST URL: %s (cert_verify=%r)' % (
                url, self.verify_certificate,
            ))
            self.logger.debug('Telegram Payload: %s' % str(payload))

            try:
                r = requests.post(
                    url,
                    data=dumps(payload),
                    headers=headers,
                    verify=self.verify_certificate,
                )

                if r.status_code != requests.codes.ok:
                    # We had a problem

                    try:
                        # Try to get the error message if we can:
                        error_msg = loads(r.text)['description']

                    except:
                        error_msg = None

                    try:
                        if error_msg:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: (%s) %s.' % (
                                    payload['chat_id'],
                                    r.status_code, error_msg))

                        else:
                            self.logger.warning(
                                'Failed to send Telegram:%s '
                                'notification: %s (error=%s).' % (
                                    payload['chat_id'],
                                    HTTP_ERROR_MAP[r.status_code],
                                    r.status_code))

                    except KeyError:
                        self.logger.warning(
                            'Failed to send Telegram:%s '
                            'notification (error=%s).' % (
                                payload['chat_id'], r.status_code))

                    # self.logger.debug('Response Details: %s' % r.raw.read())

                    # Flag our error
                    has_error = True

            except requests.RequestException as e:
                self.logger.warning(
                    'A Connection error occured sending Telegram:%s ' % (
                        payload['chat_id']) + 'notification.'
                )
                self.logger.debug('Socket Exception: %s' % str(e))
                has_error = True

            finally:
                if len(chat_ids):
                    # Prevent thrashing requests
                    self.throttle()

        return not has_error

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        # This is a dirty hack; but it's the only work around to
        # tgram:// messages since the bot_token has a colon in it.
        # It invalidates an normal URL.

        # This hack searches for this bogus URL and corrects it
        # so we can properly load it further down. The other
        # alternative is to ask users to actually change the colon
        # into a slash (which will work too), but it's more likely
        # to cause confusion... So this is the next best thing
        try:
            tgram = re.match(
                r'(?P<protocol>%s://)(bot)?(?P<prefix>([a-z0-9_-]+)'
                r'(:[a-z0-9_-]+)?@)?(?P<btoken_a>[0-9]+):+'
                r'(?P<remaining>.*)$' % NotifyTelegram.secure_protocol,
                url, re.I)

        except (TypeError, AttributeError):
            # url is bad; force tgram to be None
            tgram = None

        if not tgram:
            # Content is simply not parseable
            return None

        if tgram.group('prefix'):
            # Try again
            results = NotifyBase.parse_url(
                '%s%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('prefix'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        else:
            # Try again
            results = NotifyBase.parse_url(
                '%s%s/%s' % (
                    tgram.group('protocol'),
                    tgram.group('btoken_a'),
                    tgram.group('remaining'),
                ),
            )

        # The first token is stored in the hostname
        bot_token_a = results['host']

        # Now fetch the remaining tokens
        bot_token_b = [x for x in filter(
            bool, NotifyBase.split_path(results['fullpath']))][0]

        bot_token = '%s:%s' % (bot_token_a, bot_token_b)

        chat_ids = ','.join(
            [x for x in filter(
                bool, NotifyBase.split_path(results['fullpath']))][1:])

        # Store our bot token
        results['bot_token'] = bot_token

        # Store our chat ids
        results['chat_ids'] = chat_ids

        return results
","@@ -303,7 +303,7 @@ class NotifyTelegram(NotifyBase):
                 ),
             )
 
-        # The first token is stored in the hostnamee
+        # The first token is stored in the hostname
         bot_token_a = results['host']
 
         # Now fetch the remaining tokens
",update notify.py,0.0,0,0
0c0449fc70c462609e2ee6975bed5d3cefb98a6c,fixed commented typo,NotifyTwitter.py,"# -*- coding: utf-8 -*-
#
# Twitter Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from . import tweepy
from ..NotifyBase import NotifyBase

# Direct Messages have not image support
TWITTER_IMAGE_XY = None


class NotifyTwitter(NotifyBase):
    """"""
    A wrapper to Twitter Notifications

    """"""

    # The default secure protocol
    secure_protocol = 'tweet'

    def __init__(self, ckey, csecret, akey, asecret, **kwargs):
        """"""
        Initialize Twitter Object

        Tweets are restriced to 140 (soon to be 240), but DM messages
        do not have any restriction on them
        """"""
        super(NotifyTwitter, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            image_size=TWITTER_IMAGE_XY, **kwargs)

        if not ckey:
            raise TypeError(
                'An invalid Consumer API Key was specified.'
            )

        if not csecret:
            raise TypeError(
                'An invalid Consumer Secret API Key was specified.'
            )

        if not akey:
            raise TypeError(
                'An invalid Acess Token API Key was specified.'
            )

        if not asecret:
            raise TypeError(
                'An invalid Acess Token Secret API Key was specified.'
            )

        if not self.user:
            raise TypeError(
                'No user was specified.'
            )

        # Store our data
        self.ckey = ckey
        self.csecret = csecret
        self.akey = akey
        self.asecret = asecret

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Twitter Notification
        """"""

        try:
            # Attempt to Establish a connection to Twitter
            self.auth = tweepy.OAuthHandler(self.ckey, self.csecret)

            # Apply our Access Tokens
            self.auth.set_access_token(self.akey, self.asecret)

        except Exception:
            self.logger.warning(
                'Twitter authentication failed; '
                'please verify your configuration.'
            )
            return False

        text = '%s\r\n%s' % (title, body)
        try:
            # Get our API
            api = tweepy.API(self.auth)

            # Send our Direct Message
            api.send_direct_message(self.user, text=text)

        except Exception as e:
            self.logger.warning(
                'A Connection error occured sending Twitter '
                'direct message to %s.' % self.user)
            self.logger.debug('Twitter Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostnamee
        consumer_key = results['host']

        # Now fetch the remaining tokens
        try:
            consumer_secret, access_token_key, access_token_secret = \
                [x for x in filter(bool, NotifyBase.split_path(
                    results['fullpath']))][0:3]

        except (ValueError, AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            consumer_secret = None
            access_token_key = None
            access_token_secret = None

        results['ckey'] = consumer_key
        results['csecret'] = consumer_secret
        results['akey'] = access_token_key
        results['asecret'] = access_token_secret

        return results
","# -*- coding: utf-8 -*-
#
# Twitter Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from . import tweepy
from ..NotifyBase import NotifyBase

# Direct Messages have not image support
TWITTER_IMAGE_XY = None


class NotifyTwitter(NotifyBase):
    """"""
    A wrapper to Twitter Notifications

    """"""

    # The default secure protocol
    secure_protocol = 'tweet'

    def __init__(self, ckey, csecret, akey, asecret, **kwargs):
        """"""
        Initialize Twitter Object

        Tweets are restriced to 140 (soon to be 240), but DM messages
        do not have any restriction on them
        """"""
        super(NotifyTwitter, self).__init__(
            title_maxlen=250, body_maxlen=4096,
            image_size=TWITTER_IMAGE_XY, **kwargs)

        if not ckey:
            raise TypeError(
                'An invalid Consumer API Key was specified.'
            )

        if not csecret:
            raise TypeError(
                'An invalid Consumer Secret API Key was specified.'
            )

        if not akey:
            raise TypeError(
                'An invalid Acess Token API Key was specified.'
            )

        if not asecret:
            raise TypeError(
                'An invalid Acess Token Secret API Key was specified.'
            )

        if not self.user:
            raise TypeError(
                'No user was specified.'
            )

        # Store our data
        self.ckey = ckey
        self.csecret = csecret
        self.akey = akey
        self.asecret = asecret

        return

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform Twitter Notification
        """"""

        try:
            # Attempt to Establish a connection to Twitter
            self.auth = tweepy.OAuthHandler(self.ckey, self.csecret)

            # Apply our Access Tokens
            self.auth.set_access_token(self.akey, self.asecret)

        except Exception:
            self.logger.warning(
                'Twitter authentication failed; '
                'please verify your configuration.'
            )
            return False

        text = '%s\r\n%s' % (title, body)
        try:
            # Get our API
            api = tweepy.API(self.auth)

            # Send our Direct Message
            api.send_direct_message(self.user, text=text)

        except Exception as e:
            self.logger.warning(
                'A Connection error occured sending Twitter '
                'direct message to %s.' % self.user)
            self.logger.debug('Twitter Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # The first token is stored in the hostname
        consumer_key = results['host']

        # Now fetch the remaining tokens
        try:
            consumer_secret, access_token_key, access_token_secret = \
                [x for x in filter(bool, NotifyBase.split_path(
                    results['fullpath']))][0:3]

        except (ValueError, AttributeError, IndexError):
            # Force some bad values that will get caught
            # in parsing later
            consumer_secret = None
            access_token_key = None
            access_token_secret = None

        results['ckey'] = consumer_key
        results['csecret'] = consumer_secret
        results['akey'] = access_token_key
        results['asecret'] = access_token_secret

        return results
","@@ -129,7 +129,7 @@ class NotifyTwitter(NotifyBase):
 
         # Apply our settings now
 
-        # The first token is stored in the hostnamee
+        # The first token is stored in the hostname
         consumer_key = results['host']
 
         # Now fetch the remaining tokens
",add comment,0.0,0,0
17438fa22b824118c2650e0430679c3477fdc1c8,cli logging bugfix,notify.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Apprise notify CLI tool
#
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import click
import logging
import sys

from apprise import NotifyType
import apprise

# Logging
logger = logging.getLogger('apprise.plugins.NotifyBase')

# Defines our click context settings adding -h to the additional options that
# can be specified to get the help menu to come up
CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])


def print_help_msg(command):
    """"""
    Prints help message when -h or --help is specified.

    """"""
    with click.Context(command) as ctx:
        click.echo(command.get_help(ctx))


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--title', '-t', default=None, type=str,
              help='Specify the message title.')
@click.option('--body', '-b', default=None, type=str,
              help='Specify the message body.')
@click.option('--notification-type', '-n', default=NotifyType.INFO, type=str,
              metavar='TYPE', help='Specify the message type (default=info).')
@click.option('--theme', '-T', default='default', type=str,
              help='Specify the default theme.')
@click.option('-v', '--verbose', count=True)
@click.argument('urls', nargs=-1,
                metavar='SERVER_URL [SERVER_URL2 [SERVER_URL3]]',)
def _main(title, body, urls, notification_type, theme, verbose):
    """"""
    Send a notification to all of the specified servers identified by their
    URLs the content provided within the title, body and notification-type.

    """"""

    # Logging
    ch = logging.StreamHandler(sys.stdout)
    if verbose > 2:
        logger.setLevel(logging.DEBUG)

    elif verbose == 1:
        logger.setLevel(logging.INFO)

    else:
        logger.setLevel(logging.NONE)

    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if not urls:
        logger.error('You must specify at least one server URL.')
        print_help_msg(_main)
        return 1

    # Prepare our asset
    asset = apprise.AppriseAsset(theme=theme)

    # Create our object
    a = apprise.Apprise(asset=asset)

    # Load our inventory up
    for url in urls:
        a.add(url)

    if body is None:
        # if no body was specified, then read from STDIN
        body = click.get_text_stream('stdin').read()

    # now print it out
    if a.notify(title=title, body=body, notify_type=notification_type):
        return 0
    return 1


if __name__ == '__main__':
    exit(_main())
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Apprise notify CLI tool
#
#
# Apprise Core
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with apprise.  If not, see <http://www.gnu.org/licenses/>.

import click
import logging
import sys

from apprise import NotifyType
import apprise

# Logging
logger = logging.getLogger('apprise.plugins.NotifyBase')

# Defines our click context settings adding -h to the additional options that
# can be specified to get the help menu to come up
CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])


def print_help_msg(command):
    """"""
    Prints help message when -h or --help is specified.

    """"""
    with click.Context(command) as ctx:
        click.echo(command.get_help(ctx))


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--title', '-t', default=None, type=str,
              help='Specify the message title.')
@click.option('--body', '-b', default=None, type=str,
              help='Specify the message body.')
@click.option('--notification-type', '-n', default=NotifyType.INFO, type=str,
              metavar='TYPE', help='Specify the message type (default=info).')
@click.option('--theme', '-T', default='default', type=str,
              help='Specify the default theme.')
@click.option('-v', '--verbose', count=True)
@click.argument('urls', nargs=-1,
                metavar='SERVER_URL [SERVER_URL2 [SERVER_URL3]]',)
def _main(title, body, urls, notification_type, theme, verbose):
    """"""
    Send a notification to all of the specified servers identified by their
    URLs the content provided within the title, body and notification-type.

    """"""

    # Logging
    ch = logging.StreamHandler(sys.stdout)
    if verbose > 2:
        logger.setLevel(logging.DEBUG)

    elif verbose == 1:
        logger.setLevel(logging.INFO)

    else:
        logger.setLevel(logging.ERROR)

    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if not urls:
        logger.error('You must specify at least one server URL.')
        print_help_msg(_main)
        return 1

    # Prepare our asset
    asset = apprise.AppriseAsset(theme=theme)

    # Create our object
    a = apprise.Apprise(asset=asset)

    # Load our inventory up
    for url in urls:
        a.add(url)

    if body is None:
        # if no body was specified, then read from STDIN
        body = click.get_text_stream('stdin').read()

    # now print it out
    if a.notify(title=title, body=body, notify_type=notification_type):
        return 0
    return 1


if __name__ == '__main__':
    exit(_main())
","@@ -75,7 +75,7 @@ def _main(title, body, urls, notification_type, theme, verbose):
         logger.setLevel(logging.INFO)
 
     else:
-        logger.setLevel(logging.NONE)
+        logger.setLevel(logging.ERROR)
 
     formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
     ch.setFormatter(formatter)
",add missing logging level,0.0,0,0
afddd9e89736699184a66ec9f2bc2c020d3c7e32,Added IFTTT support; fixes #7,NotifyIFTTT.py,,"# -*- coding: utf-8 -*-
#
# IFTTT (If-This-Then-That)
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# For this plugin to work, you need to add the Maker applet to your profile
# Simply visit https://ifttt.com/search and search for 'Webhooks'
# Or if you're signed in, click here: https://ifttt.com/maker_webhooks
# and click 'Connect'
#
# You'll want to visit the settings of this Applet and pay attention to the
# URL. For example, it might look like this:
#               https://maker.ifttt.com/use/a3nHB7gA9TfBQSqJAHklod
#
# In the above example a3nHB7gA9TfBQSqJAHklod becomes your {apikey}
# You will need this to make this notification work correctly
#
# For each event you create you will assign it a name (this will be known as
# the {event} when building your URL.
import requests

from json import dumps
from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP


class NotifyIFTTT(NotifyBase):
    """"""
    A wrapper for IFTTT Notifications

    """"""

    # Even though you'll add 'Ingredients' as {{ Value1 }} to your Applets,
    # you must use their lowercase value in the HTTP POST.
    ifttt_default_key_prefix = 'value'

    # The default IFTTT Key to use when mapping the title text to the IFTTT
    # event. The idea here is if someone wants to over-ride the default and
    # change it to another Ingredient Name (in 2018, you were limited to have
    # value1, value2, and value3).
    ifttt_default_title_key = 'value1'

    # The default IFTTT Key to use when mapping the body text to the IFTTT
    # event. The idea here is if someone wants to over-ride the default and
    # change it to another Ingredient Name (in 2018, you were limited to have
    # value1, value2, and value3).
    ifttt_default_body_key = 'value2'

    # The default IFTTT Key to use when mapping the body text to the IFTTT
    # event. The idea here is if someone wants to over-ride the default and
    # change it to another Ingredient Name (in 2018, you were limited to have
    # value1, value2, and value3).
    ifttt_default_type_key = 'value3'

    # The default protocol
    protocol = 'ifttt'

    # IFTTT uses the http protocol with JSON requests
    notify_url = 'https://maker.ifttt.com/trigger/{event}/with/key/{apikey}'

    def __init__(self, apikey, event, event_args=None, **kwargs):
        """"""
        Initialize IFTTT Object

        """"""
        super(NotifyIFTTT, self).__init__(
            title_maxlen=250, body_maxlen=32768, **kwargs)

        if not apikey:
            raise TypeError('You must specify the Webhooks apikey.')

        if not event:
            raise TypeError('You must specify the Event you wish to trigger.')

        # Store our APIKey
        self.apikey = apikey

        # Store our Event we wish to trigger
        self.event = event

        if isinstance(event_args, dict):
            # Make a copy of the arguments so that they can't change
            # outside of this plugin
            self.event_args = event_args.copy()

        else:
            # Force a dictionary
            self.event_args = dict()

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform IFTTT Notification
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json',
        }

        # prepare JSON Object
        payload = {
            self.ifttt_default_title_key: title,
            self.ifttt_default_body_key: body,
            self.ifttt_default_type_key: notify_type,
        }

        # Update our payload using any other event_args specified
        payload.update(self.event_args)

        # Eliminate empty fields; users wishing to cancel the use of the
        # self.ifttt_default_ entries can preset these keys to being
        # empty so that they get caught here and removed.
        payload = {x: y for x, y in payload.items() if y}

        # URL to transmit content via
        url = self.notify_url.format(
            apikey=self.apikey,
            event=self.event,
        )

        self.logger.debug('IFTTT POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('IFTTT Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=dumps(payload),
                headers=headers,
                verify=self.verify_certificate,
            )
            self.logger.debug(
                u""IFTTT HTTP response status: %r"" % r.status_code)
            self.logger.debug(
                u""IFTTT HTTP response headers: %r"" % r.headers)
            self.logger.debug(
                u""IFTTT HTTP response body: %r"" % r.content)

            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send IFTTT:%s '
                        'notification: %s (error=%s).' % (
                            self.event,
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send IFTTT:%s '
                        'notification (error=%s).' % (
                            self.event,
                            r.status_code))

                # self.logger.debug('Response Details: %s' % r.content)
                return False

            else:
                self.logger.info(
                    'Sent IFTTT notification to Event %s.' % self.event)

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending IFTTT:%s ' % (
                    self.event) + 'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Our Event
        results['event'] = results['host']

        # Our API Key
        results['apikey'] = results['user']

        # Store ValueX entries based on each entry past the host
        results['event_args'] = {
            '{0}{1}'.format(NotifyIFTTT.ifttt_default_key_prefix, n + 1):
            NotifyBase.unquote(x)
            for n, x in enumerate(
                NotifyBase.split_path(results['fullpath'])) if x}

        # Allow users to set key=val parameters to specify more types
        # of payload options
        results['event_args'].update(
            {k: NotifyBase.unquote(v)
                for k, v in results['qsd'].items()})

        return results
","@@ -0,0 +1,218 @@
+# -*- coding: utf-8 -*-
+#
+# IFTTT (If-This-Then-That)
+#
+# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
+#
+# This file is part of apprise.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU Lesser General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License for more details.
+#
+# For this plugin to work, you need to add the Maker applet to your profile
+# Simply visit https://ifttt.com/search and search for 'Webhooks'
+# Or if you're signed in, click here: https://ifttt.com/maker_webhooks
+# and click 'Connect'
+#
+# You'll want to visit the settings of this Applet and pay attention to the
+# URL. For example, it might look like this:
+#               https://maker.ifttt.com/use/a3nHB7gA9TfBQSqJAHklod
+#
+# In the above example a3nHB7gA9TfBQSqJAHklod becomes your {apikey}
+# You will need this to make this notification work correctly
+#
+# For each event you create you will assign it a name (this will be known as
+# the {event} when building your URL.
+import requests
+
+from json import dumps
+from .NotifyBase import NotifyBase
+from .NotifyBase import HTTP_ERROR_MAP
+
+
+class NotifyIFTTT(NotifyBase):
+    """"""
+    A wrapper for IFTTT Notifications
+
+    """"""
+
+    # Even though you'll add 'Ingredients' as {{ Value1 }} to your Applets,
+    # you must use their lowercase value in the HTTP POST.
+    ifttt_default_key_prefix = 'value'
+
+    # The default IFTTT Key to use when mapping the title text to the IFTTT
+    # event. The idea here is if someone wants to over-ride the default and
+    # change it to another Ingredient Name (in 2018, you were limited to have
+    # value1, value2, and value3).
+    ifttt_default_title_key = 'value1'
+
+    # The default IFTTT Key to use when mapping the body text to the IFTTT
+    # event. The idea here is if someone wants to over-ride the default and
+    # change it to another Ingredient Name (in 2018, you were limited to have
+    # value1, value2, and value3).
+    ifttt_default_body_key = 'value2'
+
+    # The default IFTTT Key to use when mapping the body text to the IFTTT
+    # event. The idea here is if someone wants to over-ride the default and
+    # change it to another Ingredient Name (in 2018, you were limited to have
+    # value1, value2, and value3).
+    ifttt_default_type_key = 'value3'
+
+    # The default protocol
+    protocol = 'ifttt'
+
+    # IFTTT uses the http protocol with JSON requests
+    notify_url = 'https://maker.ifttt.com/trigger/{event}/with/key/{apikey}'
+
+    def __init__(self, apikey, event, event_args=None, **kwargs):
+        """"""
+        Initialize IFTTT Object
+
+        """"""
+        super(NotifyIFTTT, self).__init__(
+            title_maxlen=250, body_maxlen=32768, **kwargs)
+
+        if not apikey:
+            raise TypeError('You must specify the Webhooks apikey.')
+
+        if not event:
+            raise TypeError('You must specify the Event you wish to trigger.')
+
+        # Store our APIKey
+        self.apikey = apikey
+
+        # Store our Event we wish to trigger
+        self.event = event
+
+        if isinstance(event_args, dict):
+            # Make a copy of the arguments so that they can't change
+            # outside of this plugin
+            self.event_args = event_args.copy()
+
+        else:
+            # Force a dictionary
+            self.event_args = dict()
+
+    def notify(self, title, body, notify_type, **kwargs):
+        """"""
+        Perform IFTTT Notification
+        """"""
+
+        headers = {
+            'User-Agent': self.app_id,
+            'Content-Type': 'application/json',
+        }
+
+        # prepare JSON Object
+        payload = {
+            self.ifttt_default_title_key: title,
+            self.ifttt_default_body_key: body,
+            self.ifttt_default_type_key: notify_type,
+        }
+
+        # Update our payload using any other event_args specified
+        payload.update(self.event_args)
+
+        # Eliminate empty fields; users wishing to cancel the use of the
+        # self.ifttt_default_ entries can preset these keys to being
+        # empty so that they get caught here and removed.
+        payload = {x: y for x, y in payload.items() if y}
+
+        # URL to transmit content via
+        url = self.notify_url.format(
+            apikey=self.apikey,
+            event=self.event,
+        )
+
+        self.logger.debug('IFTTT POST URL: %s (cert_verify=%r)' % (
+            url, self.verify_certificate,
+        ))
+        self.logger.debug('IFTTT Payload: %s' % str(payload))
+        try:
+            r = requests.post(
+                url,
+                data=dumps(payload),
+                headers=headers,
+                verify=self.verify_certificate,
+            )
+            self.logger.debug(
+                u""IFTTT HTTP response status: %r"" % r.status_code)
+            self.logger.debug(
+                u""IFTTT HTTP response headers: %r"" % r.headers)
+            self.logger.debug(
+                u""IFTTT HTTP response body: %r"" % r.content)
+
+            if r.status_code != requests.codes.ok:
+                # We had a problem
+                try:
+                    self.logger.warning(
+                        'Failed to send IFTTT:%s '
+                        'notification: %s (error=%s).' % (
+                            self.event,
+                            HTTP_ERROR_MAP[r.status_code],
+                            r.status_code))
+
+                except KeyError:
+                    self.logger.warning(
+                        'Failed to send IFTTT:%s '
+                        'notification (error=%s).' % (
+                            self.event,
+                            r.status_code))
+
+                # self.logger.debug('Response Details: %s' % r.content)
+                return False
+
+            else:
+                self.logger.info(
+                    'Sent IFTTT notification to Event %s.' % self.event)
+
+        except requests.RequestException as e:
+            self.logger.warning(
+                'A Connection error occured sending IFTTT:%s ' % (
+                    self.event) + 'notification.'
+            )
+            self.logger.debug('Socket Exception: %s' % str(e))
+            return False
+
+        return True
+
+    @staticmethod
+    def parse_url(url):
+        """"""
+        Parses the URL and returns enough arguments that can allow
+        us to substantiate this object.
+
+        """"""
+        results = NotifyBase.parse_url(url)
+
+        if not results:
+            # We're done early as we couldn't load the results
+            return results
+
+        # Our Event
+        results['event'] = results['host']
+
+        # Our API Key
+        results['apikey'] = results['user']
+
+        # Store ValueX entries based on each entry past the host
+        results['event_args'] = {
+            '{0}{1}'.format(NotifyIFTTT.ifttt_default_key_prefix, n + 1):
+            NotifyBase.unquote(x)
+            for n, x in enumerate(
+                NotifyBase.split_path(results['fullpath'])) if x}
+
+        # Allow users to set key=val parameters to specify more types
+        # of payload options
+        results['event_args'].update(
+            {k: NotifyBase.unquote(v)
+                for k, v in results['qsd'].items()})
+
+        return results
",add missing documentation to ifttt,69.43,22,218
afddd9e89736699184a66ec9f2bc2c020d3c7e32,Added IFTTT support; fixes #7,__init__.py,"# -*- coding: utf-8 -*-
#
# Our service wrappers
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# Used for Testing; specifically test_email_plugin.py needs access
# to the modules WEBBASE_LOOKUP_TABLE and WebBaseLogin objects
from . import NotifyEmail as NotifyEmailBase

from .NotifyBoxcar import NotifyBoxcar
from .NotifyDiscord import NotifyDiscord
from .NotifyEmail import NotifyEmail
from .NotifyEmby import NotifyEmby
from .NotifyFaast import NotifyFaast
from .NotifyGrowl.NotifyGrowl import NotifyGrowl
from .NotifyJoin import NotifyJoin
from .NotifyJSON import NotifyJSON
from .NotifyMatterMost import NotifyMatterMost
from .NotifyMyAndroid import NotifyMyAndroid
from .NotifyProwl import NotifyProwl
from .NotifyPushalot import NotifyPushalot
from .NotifyPushBullet import NotifyPushBullet
from .NotifyPushjet.NotifyPushjet import NotifyPushjet
from .NotifyPushover import NotifyPushover
from .NotifyRocketChat import NotifyRocketChat
from .NotifySlack import NotifySlack
from .NotifyStride import NotifyStride
from .NotifyTelegram import NotifyTelegram
from .NotifyToasty import NotifyToasty
from .NotifyTwitter.NotifyTwitter import NotifyTwitter
from .NotifyXBMC import NotifyXBMC
from .NotifyXML import NotifyXML

from .NotifyPushjet import pushjet
from .NotifyGrowl import gntp
from .NotifyTwitter import tweepy

from ..common import NotifyImageSize
from ..common import NOTIFY_IMAGE_SIZES
from ..common import NotifyType
from ..common import NOTIFY_TYPES

__all__ = [
    # Notification Services
    'NotifyBoxcar', 'NotifyEmail', 'NotifyEmby', 'NotifyDiscord',
    'NotifyFaast', 'NotifyGrowl', 'NotifyJoin', 'NotifyJSON',
    'NotifyMatterMost', 'NotifyMyAndroid', 'NotifyProwl', 'NotifyPushalot',
    'NotifyPushBullet', 'NotifyPushjet', 'NotifyPushover', 'NotifyRocketChat',
    'NotifySlack', 'NotifyStride', 'NotifyToasty', 'NotifyTwitter',
    'NotifyTelegram', 'NotifyXBMC', 'NotifyXML',

    # Reference
    'NotifyImageSize', 'NOTIFY_IMAGE_SIZES', 'NotifyType', 'NOTIFY_TYPES',

    # NotifyEmail Base References (used for Testing)
    'NotifyEmailBase',

    # gntp (used for NotifyGrowl Testing)
    'gntp',

    # pushjet (used for NotifyPushjet Testing)
    'pushjet',

    # tweepy (used for NotifyTwitter Testing)
    'tweepy',
]
","# -*- coding: utf-8 -*-
#
# Our service wrappers
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# Used for Testing; specifically test_email_plugin.py needs access
# to the modules WEBBASE_LOOKUP_TABLE and WebBaseLogin objects
from . import NotifyEmail as NotifyEmailBase

from .NotifyBoxcar import NotifyBoxcar
from .NotifyDiscord import NotifyDiscord
from .NotifyEmail import NotifyEmail
from .NotifyEmby import NotifyEmby
from .NotifyFaast import NotifyFaast
from .NotifyGrowl.NotifyGrowl import NotifyGrowl
from .NotifyIFTTT import NotifyIFTTT
from .NotifyJoin import NotifyJoin
from .NotifyJSON import NotifyJSON
from .NotifyMatterMost import NotifyMatterMost
from .NotifyMyAndroid import NotifyMyAndroid
from .NotifyProwl import NotifyProwl
from .NotifyPushalot import NotifyPushalot
from .NotifyPushBullet import NotifyPushBullet
from .NotifyPushjet.NotifyPushjet import NotifyPushjet
from .NotifyPushover import NotifyPushover
from .NotifyRocketChat import NotifyRocketChat
from .NotifySlack import NotifySlack
from .NotifyStride import NotifyStride
from .NotifyTelegram import NotifyTelegram
from .NotifyToasty import NotifyToasty
from .NotifyTwitter.NotifyTwitter import NotifyTwitter
from .NotifyXBMC import NotifyXBMC
from .NotifyXML import NotifyXML

from .NotifyPushjet import pushjet
from .NotifyGrowl import gntp
from .NotifyTwitter import tweepy

from ..common import NotifyImageSize
from ..common import NOTIFY_IMAGE_SIZES
from ..common import NotifyType
from ..common import NOTIFY_TYPES

__all__ = [
    # Notification Services
    'NotifyBoxcar', 'NotifyEmail', 'NotifyEmby', 'NotifyDiscord',
    'NotifyFaast', 'NotifyGrowl', 'NotifyIFTTT', 'NotifyJoin', 'NotifyJSON',
    'NotifyMatterMost', 'NotifyMyAndroid', 'NotifyProwl', 'NotifyPushalot',
    'NotifyPushBullet', 'NotifyPushjet', 'NotifyPushover', 'NotifyRocketChat',
    'NotifySlack', 'NotifyStride', 'NotifyToasty', 'NotifyTwitter',
    'NotifyTelegram', 'NotifyXBMC', 'NotifyXML',

    # Reference
    'NotifyImageSize', 'NOTIFY_IMAGE_SIZES', 'NotifyType', 'NOTIFY_TYPES',

    # NotifyEmail Base References (used for Testing)
    'NotifyEmailBase',

    # gntp (used for NotifyGrowl Testing)
    'gntp',

    # pushjet (used for NotifyPushjet Testing)
    'pushjet',

    # tweepy (used for NotifyTwitter Testing)
    'tweepy',
]
","@@ -26,6 +26,7 @@ from .NotifyEmail import NotifyEmail
 from .NotifyEmby import NotifyEmby
 from .NotifyFaast import NotifyFaast
 from .NotifyGrowl.NotifyGrowl import NotifyGrowl
+from .NotifyIFTTT import NotifyIFTTT
 from .NotifyJoin import NotifyJoin
 from .NotifyJSON import NotifyJSON
 from .NotifyMatterMost import NotifyMatterMost
@@ -56,7 +57,7 @@ from ..common import NOTIFY_TYPES
 __all__ = [
     # Notification Services
     'NotifyBoxcar', 'NotifyEmail', 'NotifyEmby', 'NotifyDiscord',
-    'NotifyFaast', 'NotifyGrowl', 'NotifyJoin', 'NotifyJSON',
+    'NotifyFaast', 'NotifyGrowl', 'NotifyIFTTT', 'NotifyJoin', 'NotifyJSON',
     'NotifyMatterMost', 'NotifyMyAndroid', 'NotifyProwl', 'NotifyPushalot',
     'NotifyPushBullet', 'NotifyPushjet', 'NotifyPushover', 'NotifyRocketChat',
     'NotifySlack', 'NotifyStride', 'NotifyToasty', 'NotifyTwitter',
",add missing package imports,0.0,0,1
afddd9e89736699184a66ec9f2bc2c020d3c7e32,Added IFTTT support; fixes #7,test_rest_plugins.py,"# -*- coding: utf-8 -*-
#
# REST Based Plugins - Unit Tests
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
from apprise import AppriseAsset
from apprise.utils import compat_is_basestring
from json import dumps
import uuid
import requests
import mock

# Some exception handling we'll use
REQUEST_EXCEPTIONS = (
    requests.ConnectionError(
        0, 'requests.ConnectionError() not handled'),
    requests.RequestException(
        0, 'requests.RequestException() not handled'),
    requests.HTTPError(
        0, 'requests.HTTPError() not handled'),
    requests.ReadTimeout(
        0, 'requests.ReadTimeout() not handled'),
    requests.TooManyRedirects(
        0, 'requests.TooManyRedirects() not handled'),
)

TEST_URLS = (
    ##################################
    # NotifyBoxcar
    ##################################
    ('boxcar://', {
        'instance': None,
    }),
    # No secret specified
    ('boxcar://%s' % ('a' * 64), {
        'instance': None,
    }),
    # An invalid access and secret key specified
    ('boxcar://access.key/secret.key/', {
        # Thrown because there were no recipients specified
        'instance': TypeError,
    }),
    # Provide both an access and a secret
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # Test without image set
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
        # don't include an image by default
        'include_image': False,
    }),
    # our access, secret and device are all 64 characters
    # which is what we're doing here
    ('boxcar://%s/%s/@tag1/tag2///%s/' % (
        'a' * 64, 'b' * 64, 'd' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # An invalid tag
    ('boxcar://%s/%s/@%s' % ('a' * 64, 'b' * 64, 't' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    ('boxcar://:@/', {
        'instance': None,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyDiscord
    ##################################
    ('discord://', {
        'instance': None,
    }),
    # No webhook_token specified
    ('discord://%s' % ('i' * 24), {
        'instance': TypeError,
    }),
    # Provide both an webhook id and a webhook token
    ('discord://%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Provide a temporary username
    ('discord://l2g@%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Enable other options
    ('discord://%s/%s?footer=Yes&thumbnail=Yes' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    ('discord://%s/%s?avatar=No&footer=No' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Test without image set
    ('discord://%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
        # don't include an image by default
        'include_image': False,
    }),
    # An invalid url
    ('discord://:@/', {
        'instance': None,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyEmby
    ##################################
    # Insecure Request; no hostname specified
    ('emby://', {
        'instance': None,
    }),
    # Secure Emby Request; no hostname specified
    ('embys://', {
        'instance': None,
    }),
    # No user specified
    ('emby://localhost', {
        # Missing a username
        'instance': TypeError,
    }),
    ('emby://:@/', {
        'instance': None,
    }),
    # Valid Authentication
    ('emby://l2g@localhost', {
        'instance': plugins.NotifyEmby,
        # our response will be False because our authentication can't be
        # tested very well using this matrix.  It will resume in
        # in test_notify_emby_plugin()
        'response': False,
    }),
    ('embys://l2g:password@localhost', {
        'instance': plugins.NotifyEmby,
        # our response will be False because our authentication can't be
        # tested very well using this matrix.  It will resume in
        # in test_notify_emby_plugin()
        'response': False,
    }),
    # The rest of the emby tests are in test_notify_emby_plugin()

    ##################################
    # NotifyFaast
    ##################################
    ('faast://', {
        'instance': None,
    }),
    # Auth Token specified
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # don't include an image by default
        'include_image': False,
    }),
    ('faast://:@/', {
        'instance': None,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyStride
    ##################################
    # no auth_key specified
    ('stride://', {
        'instance': None,
    }),
    # No token_a specified
    ('stride://auth_key', {
        # Missing a token
        'instance': TypeError,
    }),
    # No token_b specified
    ('stride://auth_key/{0}'.format(
        str(uuid.uuid4())), {
        'instance': TypeError,
    }),
    # invalid uuid entries
    ('stride://auth_key/{0}/{1}'.format(
        'invalid-uuid', str(uuid.uuid4())), {
        'instance': TypeError,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), 'invalid-uuid'), {
        'instance': TypeError,
    }),
    # A valid url
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
    }),
    # A very invalid URL
    ('stride://:@/', {
        'instance': None,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyJoin
    ##################################
    ('join://', {
        'instance': None,
    }),
    # APIkey; no device
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
    }),
    # Invalid APIKey
    ('join://%s' % ('a' * 24), {
        # Missing a channel
        'instance': TypeError,
    }),
    # APIKey + device
    ('join://%s/%s' % ('a' * 32, 'd' * 32), {
        'instance': plugins.NotifyJoin,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + 2 devices
    ('join://%s/%s/%s' % ('a' * 32, 'd' * 32, 'e' * 32), {
        'instance': plugins.NotifyJoin,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + 1 device and 1 group
    ('join://%s/%s/%s' % ('a' * 32, 'd' * 32, 'group.chrome'), {
        'instance': plugins.NotifyJoin,
    }),
    # APIKey + bad device
    ('join://%s/%s' % ('a' * 32, 'd' * 10), {
        'instance': plugins.NotifyJoin,
    }),
    # APIKey + bad url
    ('join://:@/', {
        'instance': None,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyJSON
    ##################################
    ('json://', {
        'instance': None,
    }),
    ('jsons://', {
        'instance': None,
    }),
    ('json://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost:8080/path/', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://:@/', {
        'instance': None,
    }),
    ('json://user:pass@localhost:8081', {
        'instance': plugins.NotifyJSON,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('json://user:pass@localhost:8082', {
        'instance': plugins.NotifyJSON,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('json://user:pass@localhost:8083', {
        'instance': plugins.NotifyJSON,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('kodi://', {
        'instance': None,
    }),
    ('kodis://', {
        'instance': None,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost:8080/path/', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('kodis://localhost:443', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('kodi://:@/', {
        'instance': None,
    }),
    ('kodi://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('kodi://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('kodi://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMatterMost
    ##################################
    ('mmost://', {
        'instance': None,
    }),
    ('mmosts://', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://user@localhost/3ccdd113474722377935511fc85d3dd4?channel=test', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:8080/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:0/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:invalid-port/3ccdd113474722377935511fc85d3dd4', {
        'instance': None,
    }),
    ('mmosts://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmosts://localhost', {
        # Thrown because there was no webhook id specified
        'instance': TypeError,
    }),
    ('mmost://localhost/bad-web-hook', {
        # Thrown because the webhook is not in a valid format
        'instance': TypeError,
    }),
    ('mmost://:@/', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMyAndroid
    ##################################
    ('nma://', {
        'instance': None,
    }),
    # APIkey; no device
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Invalid APIKey
    ('nma://%s' % ('a' * 24), {
        'instance': TypeError,
    }),
    # APIKey
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + priority setting
    ('nma://%s?priority=high' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + invalid priority setting
    ('nma://%s?priority=invalid' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + priority setting (empty)
    ('nma://%s?priority=' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + Invalid DevAPI Key
    ('nma://%s/%s' % ('a' * 48, 'b' * 24), {
        'instance': TypeError,
    }),
    # APIKey + DevAPI Key
    ('nma://%s/%s' % ('a' * 48, 'b' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing valid format
    ('nma://%s?format=text' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing valid format
    ('nma://%s?format=html' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing invalid format (fall's back to html)
    ('nma://%s?format=invalid' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing empty format (falls back to html)
    ('nma://%s?format=' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + with image
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # bad url
    ('nma://:@/', {
        'instance': None,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyProwl
    ##################################
    ('prowl://', {
        'instance': None,
    }),
    # APIkey; no device
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # Invalid APIKey
    ('prowl://%s' % ('a' * 24), {
        'instance': TypeError,
    }),
    # APIKey
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + priority setting
    ('prowl://%s?priority=high' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + invalid priority setting
    ('prowl://%s?priority=invalid' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + priority setting (empty)
    ('prowl://%s?priority=' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + Invalid Provider Key
    ('prowl://%s/%s' % ('a' * 40, 'b' * 24), {
        'instance': TypeError,
    }),
    # APIKey + No Provider Key (empty)
    ('prowl://%s///' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + Provider Key
    ('prowl://%s/%s' % ('a' * 40, 'b' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + with image
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # bad url
    ('prowl://:@/', {
        'instance': None,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushalot
    ##################################
    ('palot://', {
        'instance': None,
    }),
    # AuthToken
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
    }),
    # AuthToken, no image
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # don't include an image by default
        'include_image': False,
    }),
    # Invalid AuthToken
    ('palot://%s' % ('a' * 24), {
        # Missing a channel
        'instance': TypeError,
    }),
    # AuthToken + bad url
    ('palot://:@/', {
        'instance': None,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushBullet
    ##################################
    ('pbul://', {
        'instance': None,
    }),
    # APIkey
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + channel
    ('pbul://%s/#channel/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 channels
    ('pbul://%s/#channel1/#channel2' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + device
    ('pbul://%s/device/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 devices
    ('pbul://%s/device1/device2/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + email
    ('pbul://%s/user@example.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 emails
    ('pbul://%s/user@example.com/abc@def.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + Combo
    ('pbul://%s/device/#channel/user@example.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + bad url
    ('pbul://:@/', {
        'instance': None,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushover
    ##################################
    ('pover://', {
        'instance': None,
    }),
    # APIkey; no user
    ('pover://%s' % ('a' * 30), {
        'instance': TypeError,
    }),
    # APIkey; invalid user
    ('pover://%s@%s' % ('u' * 20, 'a' * 30), {
        'instance': TypeError,
    }),
    # Invalid APIKey; valid User
    ('pover://%s@%s' % ('u' * 30, 'a' * 24), {
        'instance': TypeError,
    }),
    # APIKey + Valid User
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + Valid User + 1 Device
    ('pover://%s@%s/DEVICE' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + Valid User + 2 Devices
    ('pover://%s@%s/DEVICE1/DEVICE2/' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + Valid User + invalid device
    ('pover://%s@%s/%s/' % ('u' * 30, 'a' * 30, 'd' * 30), {
        'instance': plugins.NotifyPushover,
        # Notify will return False since there is a bad device in our list
        'response': False,
    }),
    # APIKey + Valid User + device + invalid device
    ('pover://%s@%s/DEVICE1/%s/' % ('u' * 30, 'a' * 30, 'd' * 30), {
        'instance': plugins.NotifyPushover,
        # Notify will return False since there is a bad device in our list
        'response': False,
    }),
    # APIKey + priority setting
    ('pover://%s@%s?priority=high' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + invalid priority setting
    ('pover://%s@%s?priority=invalid' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + priority setting (empty)
    ('pover://%s@%s?priority=' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # bad url
    ('pover://:@/', {
        'instance': None,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyRocketChat
    ##################################
    ('rocket://', {
        'instance': None,
    }),
    ('rockets://', {
        'instance': None,
    }),
    # No username or pass
    ('rocket://localhost', {
        'instance': TypeError,
    }),
    # No room or channel
    ('rocket://user:pass@localhost', {
        'instance': TypeError,
    }),
    # No valid rooms or channels
    ('rocket://user:pass@localhost/#/!/@', {
        'instance': TypeError,
    }),
    # A room and port identifier
    ('rocket://user:pass@localhost:8080/room/', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # A channel
    ('rockets://user:pass@localhost/#channel', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # Several channels
    ('rocket://user:pass@localhost/#channel1/#channel2/', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # Several Rooms
    ('rocket://user:pass@localhost/room1/room2', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # A room and channel
    ('rocket://user:pass@localhost/room/#channel', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    ('rocket://:@/', {
        'instance': None,
    }),
    # A room and channel
    ('rockets://user:pass@localhost/rooma/#channela', {
        # The response text is expected to be the following on a success
        'requests_response_code': requests.codes.ok,
        'requests_response_text': {
            # return something other then a success message type
            'status': 'failure',
        },
        # Exception is thrown in this case
        'instance': plugins.NotifyRocketChat,
        # Notifications will fail in this event
        'response': False,
    }),
    ('rocket://user:pass@localhost:8081/room1/room2', {
        'instance': plugins.NotifyRocketChat,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('rocket://user:pass@localhost:8082/#channel', {
        'instance': plugins.NotifyRocketChat,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('rocket://user:pass@localhost:8083/#chan1/#chan2/room', {
        'instance': plugins.NotifyRocketChat,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifySlack
    ##################################
    ('slack://', {
        'instance': None,
    }),
    ('slack://:@/', {
        'instance': None,
    }),
    ('slack://T1JJ3T3L2', {
        # Just Token 1 provided
        'instance': None,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#hmm/#-invalid-', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#channel', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
        # don't include an image by default
        'include_image': False,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/+id/%20/@id/', {
        # + encoded id,
        # @ userid
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#nuxref', {
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ', {
        # Missing a channel
        'instance': TypeError,
    }),
    ('slack://username@INVALID/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#cool', {
        # invalid 1st Token
        'instance': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/INVALID/TIiajkdnlazkcOXrIdevi7FQ/#great', {
        # invalid 2rd Token
        'instance': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/INVALID/#channel', {
        # invalid 3rd Token
        'instance': TypeError,
    }),
    ('slack://l2g@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#usenet', {
        'instance': plugins.NotifySlack,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('slack://respect@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#a', {
        'instance': plugins.NotifySlack,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('slack://notify@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#b', {
        'instance': plugins.NotifySlack,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyTelegram
    ##################################
    ('tgram://', {
        'instance': None,
    }),
    # Simple Message
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message (no images)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Simple Message with multiple chat names
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message with an invalid chat ID
    ('tgram://123456789:abcdefg_hijklmnop/%$/', {
        'instance': plugins.NotifyTelegram,
        # Notify will fail
        'response': False,
    }),
    # Simple Message with multiple chat ids
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/23423/-30/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message with multiple chat ids (no images)
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/23423/-30/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Support bot keyword prefix
    ('tgram://bottest@123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing image
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing invalid format (fall's back to html)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?format=invalid', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing empty format (falls back to html)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?format=', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message without image
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Invalid Bot Token
    ('tgram://alpha:abcdefg_hijklmnop/lead2gold/', {
        'instance': None,
    }),
    # AuthToken + bad url
    ('tgram://:@/', {
        'instance': None,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # force a failure without an image specified
        'include_image': False,
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
        # force a failure with multiple chat_ids
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
        # force a failure without an image specified
        'include_image': False,
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up without
        # having an image included
        'include_image': False,
        'response': False,
        'requests_response_code': 999,
    }),
    # Test with image set
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up without
        # having an image included
        'include_image': True,
        'response': False,
        'requests_response_code': 999,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them without images set
        'include_image': True,
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyToasty (SuperToasty)
    ##################################
    ('toasty://', {
        'instance': None,
    }),
    # No username specified but contains a device
    ('toasty://%s' % ('d' * 32), {
        'instance': TypeError,
    }),
    # User + 1 device
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
    }),
    # User + 3 devices
    ('toasty://user@device0/device1/device2/', {
        'instance': plugins.NotifyToasty,
        # don't include an image by default
        'include_image': False,
    }),
    # bad url
    ('toasty://:@/', {
        'instance': None,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('xbmc://', {
        'instance': None,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('xbmc://:@/', {
        'instance': None,
    }),
    ('xbmc://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xbmc://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xbmc://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyXML
    ##################################
    ('xml://', {
        'instance': None,
    }),
    ('xmls://', {
        'instance': None,
    }),
    ('xml://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost:8080/path/', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://:@/', {
        'instance': None,
    }),
    ('xml://user:pass@localhost:8081', {
        'instance': plugins.NotifyXML,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xml://user:pass@localhost:8082', {
        'instance': plugins.NotifyXML,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xml://user:pass@localhost:8083', {
        'instance': plugins.NotifyXML,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_rest_plugins(mock_post, mock_get):
    """"""
    API: REST Based Plugins()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:
        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        # Allow us to force the server response code to be something other then
        # the defaults
        requests_response_code = meta.get(
            'requests_response_code',
            requests.codes.ok if response else requests.codes.not_found,
        )

        # Allow us to force the server response text to be something other then
        # the defaults
        requests_response_text = meta.get('requests_response_text')
        if not compat_is_basestring(requests_response_text):
            # Convert to string
            requests_response_text = dumps(requests_response_text)

        # Allow notification type override, otherwise default to INFO
        notify_type = meta.get('notify_type', NotifyType.INFO)

        # Whether or not we should include an image with our request; unless
        # otherwise specified, we assume that images are to be included
        include_image = meta.get('include_image', True)
        if include_image:
            # a default asset
            asset = AppriseAsset()

        else:
            # Disable images
            asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

        test_requests_exceptions = meta.get(
            'test_requests_exceptions', False)

        # A request
        robj = mock.Mock()
        setattr(robj, 'raw', mock.Mock())
        # Allow raw.read() calls
        robj.raw.read.return_value = ''
        robj.text = ''
        robj.content = ''
        mock_get.return_value = robj
        mock_post.return_value = robj

        if test_requests_exceptions is False:
            # Handle our default response
            mock_post.return_value.status_code = requests_response_code
            mock_get.return_value.status_code = requests_response_code

            # Handle our default text response
            mock_get.return_value.text = requests_response_text
            mock_post.return_value.text = requests_response_text

            # Ensure there is no side effect set
            mock_post.side_effect = None
            mock_get.side_effect = None

        else:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_requests_exceptions = REQUEST_EXCEPTIONS

        try:
            obj = Apprise.instantiate(
                url, asset=asset, suppress_exceptions=False)

            if obj is None:
                # We're done (assuming this is what we were expecting)
                assert instance is None
                continue

            assert(isinstance(obj, instance))

            # Disable throttling to speed up unit tests
            obj.throttle_attempt = 0

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_requests_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=notify_type) == response

                else:
                    for _exception in REQUEST_EXCEPTIONS:
                        mock_post.side_effect = _exception
                        mock_get.side_effect = _exception

                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                print('%s AssertionError' % url)
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(instance is not None)
            assert(isinstance(e, instance))


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_boxcar_plugin(mock_post, mock_get):
    """"""
    API: NotifyBoxcar() Extra Checks

    """"""
    # Generate some generic message types
    device = 'A' * 64
    tag = '@B' * 63

    access = '-' * 64
    secret = '_' * 64

    # Initializes the plugin with recipients set to None
    plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)

    # Initializes the plugin with a valid access, but invalid access key
    try:
        plugins.NotifyBoxcar(access=None, secret=secret, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret key
    try:
        plugins.NotifyBoxcar(access=access, secret='invalid', recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid key
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret
    try:
        plugins.NotifyBoxcar(access=access, secret=None, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with recipients list
    # the below also tests our the variation of recipient types
    plugins.NotifyBoxcar(
        access=access, secret=secret, recipients=[device, tag])

    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.created
    mock_get.return_value.status_code = requests.codes.created

    # Test notifications without a body or a title
    p = plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)

    # Disable throttling to speed up unit tests
    p.throttle_attempt = 0

    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_discord_plugin(mock_post, mock_get):
    """"""
    API: NotifyDiscord() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    webhook_id = 'A' * 24
    webhook_token = 'B' * 64

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # Empty Channel list
    try:
        plugins.NotifyDiscord(webhook_id=None, webhook_token=webhook_token)
        assert(False)

    except TypeError:
        # we'll thrown because no webhook_id was specified
        assert(True)

    obj = plugins.NotifyDiscord(
        webhook_id=webhook_id,
        webhook_token=webhook_token,
        footer=True, thumbnail=False)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call includes an image with it's payload:
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True

    # Toggle our logo availability
    obj.asset.image_url_logo = None
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_login(mock_post, mock_get):
    """"""
    API: NotifyEmby.login()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        assert obj.login() is False

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    assert obj.login() is False

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    assert obj.login() is False

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost:%d' % (
        # Increment our port so it will always be something different than
        # the default
        plugins.NotifyEmby.emby_default_port + 1))
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.port == (plugins.NotifyEmby.emby_default_port + 1)

    # The login will fail because '' is not a parseable JSON response
    assert obj.login() is False

    # Disable the port completely
    obj.port = None
    assert obj.login() is False

    # Default port assigments
    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.port == plugins.NotifyEmby.emby_default_port

    # The login will (still) fail because '' is not a parseable JSON response
    assert obj.login() is False

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = dumps({
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # The login will fail because the 'User' or 'Id' field wasn't parsed
    assert obj.login() is False

    # Our text content (we intentionally reverse the 2 locations
    # that store the same thing; we do this so we can test which
    # one it defaults to if both are present
    mock_post.return_value.content = dumps({
        u'User': {
            u'Id': u'abcd123',
        },
        u'Id': u'123abc',
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # Login
    assert obj.login() is True
    assert obj.user_id == '123abc'
    assert obj.access_token == '0000-0000-0000-0000'

    # We're going to log in a second time which checks that we logout
    # first before logging in again. But this time we'll scrap the
    # 'Id' area and use the one found in the User area if detected
    mock_post.return_value.content = dumps({
        u'User': {
            u'Id': u'abcd123',
        },
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Login
    assert obj.login() is True
    assert obj.user_id == 'abcd123'
    assert obj.access_token == '0000-0000-0000-0000'


@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('apprise.plugins.NotifyEmby.logout')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_sessions(mock_post, mock_get, mock_logout,
                                     mock_login):
    """"""
    API: NotifyEmby.sessions()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True
    mock_logout.return_value = True

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        sessions = obj.sessions()
        assert isinstance(sessions, dict) is True
        assert len(sessions) == 0

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None

    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    # Let's get some results
    mock_post.return_value.content = dumps([
        {
            u'Id': u'abc123',
        },
        {
            u'Id': u'def456',
        },
        {
            u'InvalidEntry': None,
        },
    ])
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    sessions = obj.sessions(user_controlled=True)
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 2

    # Test it without setting user-controlled sessions
    sessions = obj.sessions(user_controlled=False)
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 2

    # Triggers an authentication failure
    obj.user_id = None
    mock_login.return_value = False
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0


@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_logout(mock_post, mock_get, mock_login):
    """"""
    API: NotifyEmby.sessions()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        obj.logout()
        obj.access_token = 'abc'
        obj.user_id = '123'

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    obj.logout()
    obj.access_token = 'abc'
    obj.user_id = '123'

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    obj.logout()
    obj.access_token = 'abc'
    obj.user_id = '123'

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None
    obj.logout()


@mock.patch('apprise.plugins.NotifyEmby.sessions')
@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('apprise.plugins.NotifyEmby.logout')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_notify(mock_post, mock_get, mock_logout,
                                   mock_login, mock_sessions):
    """"""
    API: NotifyEmby.notify()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True
    mock_logout.return_value = True
    mock_sessions.return_value = {'abcd': {}}

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost?modal=False')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.notify('title', 'body', 'info') is True
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test Modal support
    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost?modal=True')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.notify('title', 'body', 'info') is True
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        assert obj.notify('title', 'body', 'info') is False

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    assert obj.notify('title', 'body', 'info') is False

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    assert obj.notify('title', 'body', 'info') is False

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None
    assert obj.notify('title', 'body', 'info') is True

    # An Empty return set (no query is made, but notification will still
    # succeed
    mock_sessions.return_value = {}
    assert obj.notify('title', 'body', 'info') is True


def test_notify_stride_plugin():
    """"""
    API: NotifyStride() Extra Checks

    """"""
    try:
        # Initializes the plugin with devices set to a string
        plugins.NotifyStride(
            auth_token=None,
            cloud_id=str(uuid.uuid4()),
            convo_id=str(uuid.uuid4()),
        )
        # The code shouldn't make it here, we should throw an exception
        # on the previous line
        assert False

    except TypeError:
        assert True

    try:
        # Initializes the plugin with devices set to a string
        plugins.NotifyStride(
            auth_token='key',
            cloud_id=str(uuid.uuid4()),
            convo_id=None,
        )
        # The code shouldn't make it here, we should throw an exception
        # on the previous line
        assert False

    except TypeError:
        assert True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_join_plugin(mock_post, mock_get):
    """"""
    API: NotifyJoin() Extra Checks

    """"""
    # Generate some generic message types
    device = 'A' * 32
    group = 'group.chrome'
    apikey = 'a' * 32

    # Initializes the plugin with devices set to a string
    plugins.NotifyJoin(apikey=apikey, devices=group)

    # Initializes the plugin with devices set to None
    plugins.NotifyJoin(apikey=apikey, devices=None)

    # Initializes the plugin with devices set to a set
    p = plugins.NotifyJoin(apikey=apikey, devices=[group, device])

    # Prepare our mock responses
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.created
    mock_get.return_value.status_code = requests.codes.created

    # Disable throttling to speed up unit tests
    p.throttle_attempt = 0

    # Test notifications without a body or a title; nothing to send
    # so we return False
    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is False


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_slack_plugin(mock_post, mock_get):
    """"""
    API: NotifySlack() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    token_a = 'A' * 9
    token_b = 'B' * 9
    token_c = 'c' * 24

    # Support strings
    channels = 'chan1,#chan2,+id,@user,,,'

    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels)
    assert(len(obj.channels) == 4)

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # Empty Channel list
    try:
        plugins.NotifySlack(
            token_a=token_a, token_b=token_b, token_c=token_c,
            channels=None)
        assert(False)

    except TypeError:
        # we'll thrown because an empty list of channels was provided
        assert(True)

    # Test include_image
    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels,
        include_image=True)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call includes an image with it's payload:
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_pushbullet_plugin(mock_post, mock_get):
    """"""
    API: NotifyPushBullet() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    accesstoken = 'a' * 32

    # Support strings
    recipients = '#chan1,#chan2,device,user@example.com,,,'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    obj = plugins.NotifyPushBullet(
        accesstoken=accesstoken, recipients=recipients)
    assert(isinstance(obj, plugins.NotifyPushBullet))
    assert(len(obj.recipients) == 4)

    obj = plugins.NotifyPushBullet(accesstoken=accesstoken)
    assert(isinstance(obj, plugins.NotifyPushBullet))
    # Default is to send to all devices, so there will be a
    # recipient here
    assert(len(obj.recipients) == 1)

    obj = plugins.NotifyPushBullet(accesstoken=accesstoken, recipients=set())
    assert(isinstance(obj, plugins.NotifyPushBullet))
    # Default is to send to all devices, so there will be a
    # recipient here
    assert(len(obj.recipients) == 1)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyPushBullet.parse_url(None) is None)
    assert(plugins.NotifyPushBullet.parse_url('') is None)
    assert(plugins.NotifyPushBullet.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_pushover_plugin(mock_post, mock_get):
    """"""
    API: NotifyPushover() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    token = 'a' * 30
    user = 'u' * 30

    invalid_device = 'd' * 35

    # Support strings
    devices = 'device1,device2,,,,%s' % invalid_device

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    try:
        obj = plugins.NotifyPushover(user=user, token=None)
        # No token specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyPushover(user=user, token=token, devices=devices)
    assert(isinstance(obj, plugins.NotifyPushover))
    assert(len(obj.devices) == 3)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call fails because there is 1 invalid device
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is False

    obj = plugins.NotifyPushover(user=user, token=token)
    assert(isinstance(obj, plugins.NotifyPushover))
    # Default is to send to all devices, so there will be a
    # device defined here
    assert(len(obj.devices) == 1)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call succeeds because all of the devices are valid
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True

    obj = plugins.NotifyPushover(user=user, token=token, devices=set())
    assert(isinstance(obj, plugins.NotifyPushover))
    # Default is to send to all devices, so there will be a
    # device defined here
    assert(len(obj.devices) == 1)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyPushover.parse_url(None) is None)
    assert(plugins.NotifyPushover.parse_url('') is None)
    assert(plugins.NotifyPushover.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_rocketchat_plugin(mock_post, mock_get):
    """"""
    API: NotifyRocketChat() Extra Checks

    """"""
    # Chat ID
    recipients = 'l2g, lead2gold, #channel, #channel2'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = ''
    mock_get.return_value.text = ''

    try:
        obj = plugins.NotifyRocketChat(recipients=None)
        # invalid recipients list (None)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    try:
        obj = plugins.NotifyRocketChat(recipients=object())
        # invalid recipients list (object)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    try:
        obj = plugins.NotifyRocketChat(recipients=set())
        # invalid recipient list/set (no entries)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    obj = plugins.NotifyRocketChat(recipients=recipients)
    assert(isinstance(obj, plugins.NotifyRocketChat))
    assert(len(obj.channels) == 2)
    assert(len(obj.rooms) == 2)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    #
    # Logout
    #
    assert obj.logout() is True

    # Support the handling of an empty and invalid URL strings
    assert plugins.NotifyRocketChat.parse_url(None) is None
    assert plugins.NotifyRocketChat.parse_url('') is None
    assert plugins.NotifyRocketChat.parse_url(42) is None

    # Prepare Mock to fail
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    mock_post.return_value.text = ''
    mock_get.return_value.text = ''

    #
    # Send Notification
    #
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    #
    # Logout
    #
    assert obj.logout() is False

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999

    #
    # Send Notification
    #
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    #
    # Logout
    #
    assert obj.logout() is False

    mock_post.return_value.text = ''
    # Generate exceptions
    mock_get.side_effect = requests.ConnectionError(
        0, 'requests.ConnectionError() not handled')
    mock_post.side_effect = mock_get.side_effect
    mock_get.return_value.text = ''
    mock_post.return_value.text = ''

    #
    # Send Notification
    #
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    # Attempt the check again but fake a successful login
    obj.login = mock.Mock()
    obj.login.return_value = True
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    #
    # Logout
    #
    assert obj.logout() is False


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_toasty_plugin(mock_post, mock_get):
    """"""
    API: NotifyToasty() Extra Checks

    """"""

    # Support strings
    devices = 'device1,device2,,,,'

    # User
    user = 'l2g'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    try:
        obj = plugins.NotifyToasty(user=user, devices=None)
        # No devices specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyToasty(user=user, devices=set())
        # No devices specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyToasty(user=user, devices=devices)
    assert(isinstance(obj, plugins.NotifyToasty))
    assert(len(obj.devices) == 2)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyToasty.parse_url(None) is None)
    assert(plugins.NotifyToasty.parse_url('') is None)
    assert(plugins.NotifyToasty.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_telegram_plugin(mock_post, mock_get):
    """"""
    API: NotifyTelegram() Extra Checks

    """"""
    # Bot Token
    bot_token = '123456789:abcdefg_hijklmnop'
    invalid_bot_token = 'abcd:123'

    # Chat ID
    chat_ids = 'l2g, lead2gold'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_get.return_value.content = '{}'
    mock_post.return_value.content = '{}'

    try:
        obj = plugins.NotifyTelegram(bot_token=None, chat_ids=chat_ids)
        # invalid bot token (None)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(
            bot_token=invalid_bot_token, chat_ids=chat_ids)
        # invalid bot token
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact an invalid token was
        # specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=set())
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=chat_ids)
    assert(isinstance(obj, plugins.NotifyTelegram))
    assert(len(obj.chat_ids) == 2)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyTelegram.parse_url(None) is None)
    assert(plugins.NotifyTelegram.parse_url('') is None)
    assert(plugins.NotifyTelegram.parse_url(42) is None)

    # Prepare Mock to fail
    response = mock.Mock()
    response.status_code = requests.codes.internal_server_error

    # a error response
    response.text = dumps({
        'description': 'test',
    })
    mock_get.return_value = response
    mock_post.return_value = response

    # No image asset
    nimg_obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=chat_ids)
    nimg_obj.asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

    # Disable throttling to speed up unit tests
    nimg_obj.throttle_attempt = 0
    obj.throttle_attempt = 0

    # This tests erroneous messages involving multiple chat ids
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # This tests erroneous messages involving a single chat id
    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids='l2g')
    nimg_obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids='l2g')
    nimg_obj.asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # Bot Token Detection
    # Just to make it clear to people reading this code and trying to learn
    # what is going on.  Apprise tries to detect the bot owner if you don't
    # specify a user to message.  The idea is to just default to messaging
    # the bot owner himself (it makes it easier for people).  So we're testing
    # the creating of a Telegram Notification without providing a chat ID.
    # We're testing the error handling of this bot detection section of the
    # code
    mock_post.return_value.content = dumps({
        ""ok"": True,
        ""result"": [{
            ""update_id"": 645421321,
            ""message"": {
                ""message_id"": 1,
                ""from"": {
                    ""id"": 532389719,
                    ""is_bot"": False,
                    ""first_name"": ""Chris"",
                    ""language_code"": ""en-US""
                },
                ""chat"": {
                    ""id"": 532389719,
                    ""first_name"": ""Chris"",
                    ""type"": ""private""
                },
                ""date"": 1519694394,
                ""text"": ""/start"",
                ""entities"": [{
                    ""offset"": 0,
                    ""length"": 6,
                    ""type"": ""bot_command"",
                }],
            }},
        ],
    })
    mock_post.return_value.status_code = requests.codes.ok

    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
    assert(len(obj.chat_ids) == 1)
    assert(obj.chat_ids[0] == '532389719')

    # Do the test again, but without the expected (parsed response)
    mock_post.return_value.content = dumps({
        ""ok"": True,
        ""result"": [{
            ""message"": {
                ""text"": ""/ignored.entry"",
            }},
        ],
    })
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Test our bot detection with a internal server error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Test our bot detection with an unmappable html error
    mock_post.return_value.status_code = 999
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Do it again but this time provide a failure message
    mock_post.return_value.content = dumps({'description': 'Failure Message'})
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Do it again but this time provide a failure message and perform a
    # notification without a bot detection by providing at least 1 chat id
    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=['@abcd'])
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # iterate over our exceptions and test them
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        try:
            obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
            # No chat_ids specified
            assert(False)

        except TypeError:
            # Exception should be thrown about the fact no token was specified
            assert(True)
","# -*- coding: utf-8 -*-
#
# REST Based Plugins - Unit Tests
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
from apprise import AppriseAsset
from apprise.utils import compat_is_basestring
from json import dumps
import uuid
import requests
import mock

# Some exception handling we'll use
REQUEST_EXCEPTIONS = (
    requests.ConnectionError(
        0, 'requests.ConnectionError() not handled'),
    requests.RequestException(
        0, 'requests.RequestException() not handled'),
    requests.HTTPError(
        0, 'requests.HTTPError() not handled'),
    requests.ReadTimeout(
        0, 'requests.ReadTimeout() not handled'),
    requests.TooManyRedirects(
        0, 'requests.TooManyRedirects() not handled'),
)

TEST_URLS = (
    ##################################
    # NotifyBoxcar
    ##################################
    ('boxcar://', {
        'instance': None,
    }),
    # No secret specified
    ('boxcar://%s' % ('a' * 64), {
        'instance': None,
    }),
    # An invalid access and secret key specified
    ('boxcar://access.key/secret.key/', {
        # Thrown because there were no recipients specified
        'instance': TypeError,
    }),
    # Provide both an access and a secret
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # Test without image set
    ('boxcar://%s/%s' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
        # don't include an image by default
        'include_image': False,
    }),
    # our access, secret and device are all 64 characters
    # which is what we're doing here
    ('boxcar://%s/%s/@tag1/tag2///%s/' % (
        'a' * 64, 'b' * 64, 'd' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    # An invalid tag
    ('boxcar://%s/%s/@%s' % ('a' * 64, 'b' * 64, 't' * 64), {
        'instance': plugins.NotifyBoxcar,
        'requests_response_code': requests.codes.created,
    }),
    ('boxcar://:@/', {
        'instance': None,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('boxcar://%s/%s/' % ('a' * 64, 'b' * 64), {
        'instance': plugins.NotifyBoxcar,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyDiscord
    ##################################
    ('discord://', {
        'instance': None,
    }),
    # No webhook_token specified
    ('discord://%s' % ('i' * 24), {
        'instance': TypeError,
    }),
    # Provide both an webhook id and a webhook token
    ('discord://%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Provide a temporary username
    ('discord://l2g@%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Enable other options
    ('discord://%s/%s?footer=Yes&thumbnail=Yes' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    ('discord://%s/%s?avatar=No&footer=No' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
    }),
    # Test without image set
    ('discord://%s/%s' % ('i' * 24, 't' * 64), {
        'instance': plugins.NotifyDiscord,
        'requests_response_code': requests.codes.no_content,
        # don't include an image by default
        'include_image': False,
    }),
    # An invalid url
    ('discord://:@/', {
        'instance': None,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('discord://%s/%s/' % ('a' * 24, 'b' * 64), {
        'instance': plugins.NotifyDiscord,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyEmby
    ##################################
    # Insecure Request; no hostname specified
    ('emby://', {
        'instance': None,
    }),
    # Secure Emby Request; no hostname specified
    ('embys://', {
        'instance': None,
    }),
    # No user specified
    ('emby://localhost', {
        # Missing a username
        'instance': TypeError,
    }),
    ('emby://:@/', {
        'instance': None,
    }),
    # Valid Authentication
    ('emby://l2g@localhost', {
        'instance': plugins.NotifyEmby,
        # our response will be False because our authentication can't be
        # tested very well using this matrix.  It will resume in
        # in test_notify_emby_plugin()
        'response': False,
    }),
    ('embys://l2g:password@localhost', {
        'instance': plugins.NotifyEmby,
        # our response will be False because our authentication can't be
        # tested very well using this matrix.  It will resume in
        # in test_notify_emby_plugin()
        'response': False,
    }),
    # The rest of the emby tests are in test_notify_emby_plugin()

    ##################################
    # NotifyFaast
    ##################################
    ('faast://', {
        'instance': None,
    }),
    # Auth Token specified
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # don't include an image by default
        'include_image': False,
    }),
    ('faast://:@/', {
        'instance': None,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('faast://%s' % ('a' * 32), {
        'instance': plugins.NotifyFaast,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyStride
    ##################################
    # no auth_key specified
    ('stride://', {
        'instance': None,
    }),
    # No token_a specified
    ('stride://auth_key', {
        # Missing a token
        'instance': TypeError,
    }),
    # No token_b specified
    ('stride://auth_key/{0}'.format(
        str(uuid.uuid4())), {
        'instance': TypeError,
    }),
    # invalid uuid entries
    ('stride://auth_key/{0}/{1}'.format(
        'invalid-uuid', str(uuid.uuid4())), {
        'instance': TypeError,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), 'invalid-uuid'), {
        'instance': TypeError,
    }),
    # A valid url
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
    }),
    # A very invalid URL
    ('stride://:@/', {
        'instance': None,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('stride://auth_key/{0}/{1}'.format(
        str(uuid.uuid4()), str(uuid.uuid4())), {
        'instance': plugins.NotifyStride,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyIFTTT - If This Than That
    ##################################
    ('ifttt://', {
        'instance': None,
    }),
    # No User
    ('ifttt://EventID/', {
        'instance': TypeError,
    }),
    # Value1 gets assigned Entry1
    # Title = <assigned title>
    # Body = <assigned body>
    ('ifttt://WebHookID@EventID/Entry1/', {
        'instance': plugins.NotifyIFTTT,
    }),
    # Value1, Value2, and Value2, the below assigns:
    #   Value1 = Entry1
    #   Value2 = AnotherEntry
    #   Value3 = ThirdValue
    #   Title = <assigned title>
    #   Body = <assigned body>
    ('ifttt://WebHookID@EventID/Entry1/AnotherEntry/ThirdValue', {
        'instance': plugins.NotifyIFTTT,
    }),
    # Mix and match content, the below assigns:
    #   Value1 = FirstValue
    #   AnotherKey = Hello
    #   Value5 = test
    #   Title = <assigned title>
    #   Body = <assigned body>
    ('ifttt://WebHookID@EventID/FirstValue/?AnotherKey=Hello&Value5=test', {
        'instance': plugins.NotifyIFTTT,
    }),
    # This would assign:
    #   Value1 = FirstValue
    #   Title = <blank> - disable the one passed by the notify call
    #   Body = <blank> - disable the one passed by the notify call
    # The idea here is maybe you just want to use the apprise IFTTTT hook
    # to trigger something and not nessisarily pass text along to it
    ('ifttt://WebHookID@EventID/FirstValue/?Title=&Body=', {
        'instance': plugins.NotifyIFTTT,
    }),
    ('ifttt://:@/', {
        'instance': None,
    }),
    # Test website connection failures
    ('ifttt://WebHookID@EventID', {
        'instance': plugins.NotifyIFTTT,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('ifttt://WebHookID@EventID', {
        'instance': plugins.NotifyIFTTT,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('ifttt://WebHookID@EventID', {
        'instance': plugins.NotifyIFTTT,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyJoin
    ##################################
    ('join://', {
        'instance': None,
    }),
    # APIkey; no device
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
    }),
    # Invalid APIKey
    ('join://%s' % ('a' * 24), {
        # Missing a channel
        'instance': TypeError,
    }),
    # APIKey + device
    ('join://%s/%s' % ('a' * 32, 'd' * 32), {
        'instance': plugins.NotifyJoin,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + 2 devices
    ('join://%s/%s/%s' % ('a' * 32, 'd' * 32, 'e' * 32), {
        'instance': plugins.NotifyJoin,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + 1 device and 1 group
    ('join://%s/%s/%s' % ('a' * 32, 'd' * 32, 'group.chrome'), {
        'instance': plugins.NotifyJoin,
    }),
    # APIKey + bad device
    ('join://%s/%s' % ('a' * 32, 'd' * 10), {
        'instance': plugins.NotifyJoin,
    }),
    # APIKey + bad url
    ('join://:@/', {
        'instance': None,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('join://%s' % ('a' * 32), {
        'instance': plugins.NotifyJoin,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyJSON
    ##################################
    ('json://', {
        'instance': None,
    }),
    ('jsons://', {
        'instance': None,
    }),
    ('json://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://localhost:8080/path/', {
        'instance': plugins.NotifyJSON,
    }),
    ('jsons://user:pass@localhost:8080', {
        'instance': plugins.NotifyJSON,
    }),
    ('json://:@/', {
        'instance': None,
    }),
    ('json://user:pass@localhost:8081', {
        'instance': plugins.NotifyJSON,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('json://user:pass@localhost:8082', {
        'instance': plugins.NotifyJSON,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('json://user:pass@localhost:8083', {
        'instance': plugins.NotifyJSON,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('kodi://', {
        'instance': None,
    }),
    ('kodis://', {
        'instance': None,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://localhost:8080/path/', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodis://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('kodi://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('kodis://localhost:443', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('kodi://:@/', {
        'instance': None,
    }),
    ('kodi://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('kodi://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('kodi://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMatterMost
    ##################################
    ('mmost://', {
        'instance': None,
    }),
    ('mmosts://', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://user@localhost/3ccdd113474722377935511fc85d3dd4?channel=test', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:8080/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:0/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmost://localhost:invalid-port/3ccdd113474722377935511fc85d3dd4', {
        'instance': None,
    }),
    ('mmosts://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
    }),
    ('mmosts://localhost', {
        # Thrown because there was no webhook id specified
        'instance': TypeError,
    }),
    ('mmost://localhost/bad-web-hook', {
        # Thrown because the webhook is not in a valid format
        'instance': TypeError,
    }),
    ('mmost://:@/', {
        'instance': None,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('mmost://localhost/3ccdd113474722377935511fc85d3dd4', {
        'instance': plugins.NotifyMatterMost,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyMyAndroid
    ##################################
    ('nma://', {
        'instance': None,
    }),
    # APIkey; no device
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Invalid APIKey
    ('nma://%s' % ('a' * 24), {
        'instance': TypeError,
    }),
    # APIKey
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + priority setting
    ('nma://%s?priority=high' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + invalid priority setting
    ('nma://%s?priority=invalid' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + priority setting (empty)
    ('nma://%s?priority=' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + Invalid DevAPI Key
    ('nma://%s/%s' % ('a' * 48, 'b' * 24), {
        'instance': TypeError,
    }),
    # APIKey + DevAPI Key
    ('nma://%s/%s' % ('a' * 48, 'b' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing valid format
    ('nma://%s?format=text' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing valid format
    ('nma://%s?format=html' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing invalid format (fall's back to html)
    ('nma://%s?format=invalid' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # Testing empty format (falls back to html)
    ('nma://%s?format=' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # APIKey + with image
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
    }),
    # bad url
    ('nma://:@/', {
        'instance': None,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('nma://%s' % ('a' * 48), {
        'instance': plugins.NotifyMyAndroid,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyProwl
    ##################################
    ('prowl://', {
        'instance': None,
    }),
    # APIkey; no device
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # Invalid APIKey
    ('prowl://%s' % ('a' * 24), {
        'instance': TypeError,
    }),
    # APIKey
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + priority setting
    ('prowl://%s?priority=high' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + invalid priority setting
    ('prowl://%s?priority=invalid' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + priority setting (empty)
    ('prowl://%s?priority=' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + Invalid Provider Key
    ('prowl://%s/%s' % ('a' * 40, 'b' * 24), {
        'instance': TypeError,
    }),
    # APIKey + No Provider Key (empty)
    ('prowl://%s///' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + Provider Key
    ('prowl://%s/%s' % ('a' * 40, 'b' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # APIKey + with image
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
    }),
    # bad url
    ('prowl://:@/', {
        'instance': None,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('prowl://%s' % ('a' * 40), {
        'instance': plugins.NotifyProwl,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushalot
    ##################################
    ('palot://', {
        'instance': None,
    }),
    # AuthToken
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
    }),
    # AuthToken, no image
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # don't include an image by default
        'include_image': False,
    }),
    # Invalid AuthToken
    ('palot://%s' % ('a' * 24), {
        # Missing a channel
        'instance': TypeError,
    }),
    # AuthToken + bad url
    ('palot://:@/', {
        'instance': None,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('palot://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushalot,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushBullet
    ##################################
    ('pbul://', {
        'instance': None,
    }),
    # APIkey
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + channel
    ('pbul://%s/#channel/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 channels
    ('pbul://%s/#channel1/#channel2' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + device
    ('pbul://%s/device/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 devices
    ('pbul://%s/device1/device2/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + email
    ('pbul://%s/user@example.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + 2 emails
    ('pbul://%s/user@example.com/abc@def.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + Combo
    ('pbul://%s/device/#channel/user@example.com/' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
    }),
    # APIKey + bad url
    ('pbul://:@/', {
        'instance': None,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('pbul://%s' % ('a' * 32), {
        'instance': plugins.NotifyPushBullet,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyPushover
    ##################################
    ('pover://', {
        'instance': None,
    }),
    # APIkey; no user
    ('pover://%s' % ('a' * 30), {
        'instance': TypeError,
    }),
    # APIkey; invalid user
    ('pover://%s@%s' % ('u' * 20, 'a' * 30), {
        'instance': TypeError,
    }),
    # Invalid APIKey; valid User
    ('pover://%s@%s' % ('u' * 30, 'a' * 24), {
        'instance': TypeError,
    }),
    # APIKey + Valid User
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # don't include an image by default
        'include_image': False,
    }),
    # APIKey + Valid User + 1 Device
    ('pover://%s@%s/DEVICE' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + Valid User + 2 Devices
    ('pover://%s@%s/DEVICE1/DEVICE2/' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + Valid User + invalid device
    ('pover://%s@%s/%s/' % ('u' * 30, 'a' * 30, 'd' * 30), {
        'instance': plugins.NotifyPushover,
        # Notify will return False since there is a bad device in our list
        'response': False,
    }),
    # APIKey + Valid User + device + invalid device
    ('pover://%s@%s/DEVICE1/%s/' % ('u' * 30, 'a' * 30, 'd' * 30), {
        'instance': plugins.NotifyPushover,
        # Notify will return False since there is a bad device in our list
        'response': False,
    }),
    # APIKey + priority setting
    ('pover://%s@%s?priority=high' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + invalid priority setting
    ('pover://%s@%s?priority=invalid' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # APIKey + priority setting (empty)
    ('pover://%s@%s?priority=' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
    }),
    # bad url
    ('pover://:@/', {
        'instance': None,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('pover://%s@%s' % ('u' * 30, 'a' * 30), {
        'instance': plugins.NotifyPushover,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyRocketChat
    ##################################
    ('rocket://', {
        'instance': None,
    }),
    ('rockets://', {
        'instance': None,
    }),
    # No username or pass
    ('rocket://localhost', {
        'instance': TypeError,
    }),
    # No room or channel
    ('rocket://user:pass@localhost', {
        'instance': TypeError,
    }),
    # No valid rooms or channels
    ('rocket://user:pass@localhost/#/!/@', {
        'instance': TypeError,
    }),
    # A room and port identifier
    ('rocket://user:pass@localhost:8080/room/', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # A channel
    ('rockets://user:pass@localhost/#channel', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # Several channels
    ('rocket://user:pass@localhost/#channel1/#channel2/', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # Several Rooms
    ('rocket://user:pass@localhost/room1/room2', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    # A room and channel
    ('rocket://user:pass@localhost/room/#channel', {
        'instance': plugins.NotifyRocketChat,
        # The response text is expected to be the following on a success
        'requests_response_text': {
            'status': 'success',
            'data': {
                'authToken': 'abcd',
                'userId': 'user',
            },
        },
    }),
    ('rocket://:@/', {
        'instance': None,
    }),
    # A room and channel
    ('rockets://user:pass@localhost/rooma/#channela', {
        # The response text is expected to be the following on a success
        'requests_response_code': requests.codes.ok,
        'requests_response_text': {
            # return something other then a success message type
            'status': 'failure',
        },
        # Exception is thrown in this case
        'instance': plugins.NotifyRocketChat,
        # Notifications will fail in this event
        'response': False,
    }),
    ('rocket://user:pass@localhost:8081/room1/room2', {
        'instance': plugins.NotifyRocketChat,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('rocket://user:pass@localhost:8082/#channel', {
        'instance': plugins.NotifyRocketChat,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('rocket://user:pass@localhost:8083/#chan1/#chan2/room', {
        'instance': plugins.NotifyRocketChat,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifySlack
    ##################################
    ('slack://', {
        'instance': None,
    }),
    ('slack://:@/', {
        'instance': None,
    }),
    ('slack://T1JJ3T3L2', {
        # Just Token 1 provided
        'instance': None,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#hmm/#-invalid-', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#channel', {
        # No username specified; this is still okay as we sub in
        # default; The one invalid channel is skipped when sending a message
        'instance': plugins.NotifySlack,
        # don't include an image by default
        'include_image': False,
    }),
    ('slack://T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/+id/%20/@id/', {
        # + encoded id,
        # @ userid
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#nuxref', {
        'instance': plugins.NotifySlack,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ', {
        # Missing a channel
        'instance': TypeError,
    }),
    ('slack://username@INVALID/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#cool', {
        # invalid 1st Token
        'instance': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/INVALID/TIiajkdnlazkcOXrIdevi7FQ/#great', {
        # invalid 2rd Token
        'instance': TypeError,
    }),
    ('slack://username@T1JJ3T3L2/A1BRTD4JD/INVALID/#channel', {
        # invalid 3rd Token
        'instance': TypeError,
    }),
    ('slack://l2g@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#usenet', {
        'instance': plugins.NotifySlack,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('slack://respect@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#a', {
        'instance': plugins.NotifySlack,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('slack://notify@T1JJ3T3L2/A1BRTD4JD/TIiajkdnlazkcOXrIdevi7FQ/#b', {
        'instance': plugins.NotifySlack,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyTelegram
    ##################################
    ('tgram://', {
        'instance': None,
    }),
    # Simple Message
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message (no images)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Simple Message with multiple chat names
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message with an invalid chat ID
    ('tgram://123456789:abcdefg_hijklmnop/%$/', {
        'instance': plugins.NotifyTelegram,
        # Notify will fail
        'response': False,
    }),
    # Simple Message with multiple chat ids
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/23423/-30/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message with multiple chat ids (no images)
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/23423/-30/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Support bot keyword prefix
    ('tgram://bottest@123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing image
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing invalid format (fall's back to html)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?format=invalid', {
        'instance': plugins.NotifyTelegram,
    }),
    # Testing empty format (falls back to html)
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?format=', {
        'instance': plugins.NotifyTelegram,
    }),
    # Simple Message without image
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # don't include an image by default
        'include_image': False,
    }),
    # Invalid Bot Token
    ('tgram://alpha:abcdefg_hijklmnop/lead2gold/', {
        'instance': None,
    }),
    # AuthToken + bad url
    ('tgram://:@/', {
        'instance': None,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # force a failure without an image specified
        'include_image': False,
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
        # force a failure with multiple chat_ids
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/id1/id2/', {
        'instance': plugins.NotifyTelegram,
        # force a failure without an image specified
        'include_image': False,
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up without
        # having an image included
        'include_image': False,
        'response': False,
        'requests_response_code': 999,
    }),
    # Test with image set
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # throw a bizzare code forcing us to fail to look it up without
        # having an image included
        'include_image': True,
        'response': False,
        'requests_response_code': 999,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/', {
        'instance': plugins.NotifyTelegram,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
    ('tgram://123456789:abcdefg_hijklmnop/lead2gold/?image=Yes', {
        'instance': plugins.NotifyTelegram,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them without images set
        'include_image': True,
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyToasty (SuperToasty)
    ##################################
    ('toasty://', {
        'instance': None,
    }),
    # No username specified but contains a device
    ('toasty://%s' % ('d' * 32), {
        'instance': TypeError,
    }),
    # User + 1 device
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
    }),
    # User + 3 devices
    ('toasty://user@device0/device1/device2/', {
        'instance': plugins.NotifyToasty,
        # don't include an image by default
        'include_image': False,
    }),
    # bad url
    ('toasty://:@/', {
        'instance': None,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('toasty://user@device', {
        'instance': plugins.NotifyToasty,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyKODI
    ##################################
    ('xbmc://', {
        'instance': None,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://user:pass@localhost:8080', {
        'instance': plugins.NotifyXBMC,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # don't include an image by default
        'include_image': False,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.WARNING,
    }),
    ('xbmc://localhost', {
        'instance': plugins.NotifyXBMC,
        # Experement with different notification types
        'notify_type': NotifyType.FAILURE,
    }),
    ('xbmc://:@/', {
        'instance': None,
    }),
    ('xbmc://user:pass@localhost:8081', {
        'instance': plugins.NotifyXBMC,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xbmc://user:pass@localhost:8082', {
        'instance': plugins.NotifyXBMC,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xbmc://user:pass@localhost:8083', {
        'instance': plugins.NotifyXBMC,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),

    ##################################
    # NotifyXML
    ##################################
    ('xml://', {
        'instance': None,
    }),
    ('xmls://', {
        'instance': None,
    }),
    ('xml://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://localhost:8080/path/', {
        'instance': plugins.NotifyXML,
    }),
    ('xmls://user:pass@localhost:8080', {
        'instance': plugins.NotifyXML,
    }),
    ('xml://:@/', {
        'instance': None,
    }),
    ('xml://user:pass@localhost:8081', {
        'instance': plugins.NotifyXML,
        # force a failure
        'response': False,
        'requests_response_code': requests.codes.internal_server_error,
    }),
    ('xml://user:pass@localhost:8082', {
        'instance': plugins.NotifyXML,
        # throw a bizzare code forcing us to fail to look it up
        'response': False,
        'requests_response_code': 999,
    }),
    ('xml://user:pass@localhost:8083', {
        'instance': plugins.NotifyXML,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_requests_exceptions': True,
    }),
)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_rest_plugins(mock_post, mock_get):
    """"""
    API: REST Based Plugins()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:
        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        # Allow us to force the server response code to be something other then
        # the defaults
        requests_response_code = meta.get(
            'requests_response_code',
            requests.codes.ok if response else requests.codes.not_found,
        )

        # Allow us to force the server response text to be something other then
        # the defaults
        requests_response_text = meta.get('requests_response_text')
        if not compat_is_basestring(requests_response_text):
            # Convert to string
            requests_response_text = dumps(requests_response_text)

        # Allow notification type override, otherwise default to INFO
        notify_type = meta.get('notify_type', NotifyType.INFO)

        # Whether or not we should include an image with our request; unless
        # otherwise specified, we assume that images are to be included
        include_image = meta.get('include_image', True)
        if include_image:
            # a default asset
            asset = AppriseAsset()

        else:
            # Disable images
            asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

        test_requests_exceptions = meta.get(
            'test_requests_exceptions', False)

        # A request
        robj = mock.Mock()
        setattr(robj, 'raw', mock.Mock())
        # Allow raw.read() calls
        robj.raw.read.return_value = ''
        robj.text = ''
        robj.content = ''
        mock_get.return_value = robj
        mock_post.return_value = robj

        if test_requests_exceptions is False:
            # Handle our default response
            mock_post.return_value.status_code = requests_response_code
            mock_get.return_value.status_code = requests_response_code

            # Handle our default text response
            mock_get.return_value.text = requests_response_text
            mock_post.return_value.text = requests_response_text

            # Ensure there is no side effect set
            mock_post.side_effect = None
            mock_get.side_effect = None

        else:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_requests_exceptions = REQUEST_EXCEPTIONS

        try:
            obj = Apprise.instantiate(
                url, asset=asset, suppress_exceptions=False)

            if obj is None:
                # We're done (assuming this is what we were expecting)
                assert instance is None
                continue

            assert(isinstance(obj, instance))

            # Disable throttling to speed up unit tests
            obj.throttle_attempt = 0

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_requests_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=notify_type) == response

                else:
                    for _exception in REQUEST_EXCEPTIONS:
                        mock_post.side_effect = _exception
                        mock_get.side_effect = _exception

                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                print('%s AssertionError' % url)
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(instance is not None)
            assert(isinstance(e, instance))


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_boxcar_plugin(mock_post, mock_get):
    """"""
    API: NotifyBoxcar() Extra Checks

    """"""
    # Generate some generic message types
    device = 'A' * 64
    tag = '@B' * 63

    access = '-' * 64
    secret = '_' * 64

    # Initializes the plugin with recipients set to None
    plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)

    # Initializes the plugin with a valid access, but invalid access key
    try:
        plugins.NotifyBoxcar(access=None, secret=secret, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret key
    try:
        plugins.NotifyBoxcar(access=access, secret='invalid', recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid key
        assert(True)

    # Initializes the plugin with a valid access, but invalid secret
    try:
        plugins.NotifyBoxcar(access=access, secret=None, recipients=None)
        assert(False)

    except TypeError:
        # We should throw an exception for knowingly having an invalid
        assert(True)

    # Initializes the plugin with recipients list
    # the below also tests our the variation of recipient types
    plugins.NotifyBoxcar(
        access=access, secret=secret, recipients=[device, tag])

    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.created
    mock_get.return_value.status_code = requests.codes.created

    # Test notifications without a body or a title
    p = plugins.NotifyBoxcar(access=access, secret=secret, recipients=None)

    # Disable throttling to speed up unit tests
    p.throttle_attempt = 0

    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_discord_plugin(mock_post, mock_get):
    """"""
    API: NotifyDiscord() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    webhook_id = 'A' * 24
    webhook_token = 'B' * 64

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # Empty Channel list
    try:
        plugins.NotifyDiscord(webhook_id=None, webhook_token=webhook_token)
        assert(False)

    except TypeError:
        # we'll thrown because no webhook_id was specified
        assert(True)

    obj = plugins.NotifyDiscord(
        webhook_id=webhook_id,
        webhook_token=webhook_token,
        footer=True, thumbnail=False)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call includes an image with it's payload:
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True

    # Toggle our logo availability
    obj.asset.image_url_logo = None
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_login(mock_post, mock_get):
    """"""
    API: NotifyEmby.login()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        assert obj.login() is False

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    assert obj.login() is False

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    assert obj.login() is False

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost:%d' % (
        # Increment our port so it will always be something different than
        # the default
        plugins.NotifyEmby.emby_default_port + 1))
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.port == (plugins.NotifyEmby.emby_default_port + 1)

    # The login will fail because '' is not a parseable JSON response
    assert obj.login() is False

    # Disable the port completely
    obj.port = None
    assert obj.login() is False

    # Default port assigments
    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.port == plugins.NotifyEmby.emby_default_port

    # The login will (still) fail because '' is not a parseable JSON response
    assert obj.login() is False

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = dumps({
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # The login will fail because the 'User' or 'Id' field wasn't parsed
    assert obj.login() is False

    # Our text content (we intentionally reverse the 2 locations
    # that store the same thing; we do this so we can test which
    # one it defaults to if both are present
    mock_post.return_value.content = dumps({
        u'User': {
            u'Id': u'abcd123',
        },
        u'Id': u'123abc',
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)

    # Login
    assert obj.login() is True
    assert obj.user_id == '123abc'
    assert obj.access_token == '0000-0000-0000-0000'

    # We're going to log in a second time which checks that we logout
    # first before logging in again. But this time we'll scrap the
    # 'Id' area and use the one found in the User area if detected
    mock_post.return_value.content = dumps({
        u'User': {
            u'Id': u'abcd123',
        },
        u'AccessToken': u'0000-0000-0000-0000',
    })
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Login
    assert obj.login() is True
    assert obj.user_id == 'abcd123'
    assert obj.access_token == '0000-0000-0000-0000'


@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('apprise.plugins.NotifyEmby.logout')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_sessions(mock_post, mock_get, mock_logout,
                                     mock_login):
    """"""
    API: NotifyEmby.sessions()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True
    mock_logout.return_value = True

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        sessions = obj.sessions()
        assert isinstance(sessions, dict) is True
        assert len(sessions) == 0

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None

    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0

    # Let's get some results
    mock_post.return_value.content = dumps([
        {
            u'Id': u'abc123',
        },
        {
            u'Id': u'def456',
        },
        {
            u'InvalidEntry': None,
        },
    ])
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    sessions = obj.sessions(user_controlled=True)
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 2

    # Test it without setting user-controlled sessions
    sessions = obj.sessions(user_controlled=False)
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 2

    # Triggers an authentication failure
    obj.user_id = None
    mock_login.return_value = False
    sessions = obj.sessions()
    assert isinstance(sessions, dict) is True
    assert len(sessions) == 0


@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_logout(mock_post, mock_get, mock_login):
    """"""
    API: NotifyEmby.sessions()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost')
    assert isinstance(obj, plugins.NotifyEmby)
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        obj.logout()
        obj.access_token = 'abc'
        obj.user_id = '123'

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    obj.logout()
    obj.access_token = 'abc'
    obj.user_id = '123'

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    obj.logout()
    obj.access_token = 'abc'
    obj.user_id = '123'

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None
    obj.logout()


@mock.patch('apprise.plugins.NotifyEmby.sessions')
@mock.patch('apprise.plugins.NotifyEmby.login')
@mock.patch('apprise.plugins.NotifyEmby.logout')
@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_emby_plugin_notify(mock_post, mock_get, mock_logout,
                                   mock_login, mock_sessions):
    """"""
    API: NotifyEmby.notify()

    """"""

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # This is done so we don't obstruct our access_token and user_id values
    mock_login.return_value = True
    mock_logout.return_value = True
    mock_sessions.return_value = {'abcd': {}}

    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost?modal=False')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.notify('title', 'body', 'info') is True
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test Modal support
    obj = Apprise.instantiate('emby://l2g:l2gpass@localhost?modal=True')
    assert isinstance(obj, plugins.NotifyEmby)
    assert obj.notify('title', 'body', 'info') is True
    obj.access_token = 'abc'
    obj.user_id = '123'

    # Test our exception handling
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        mock_get.side_effect = _exception
        # We'll fail to log in each time
        assert obj.notify('title', 'body', 'info') is False

    # Disable Exceptions
    mock_post.side_effect = None
    mock_get.side_effect = None

    # Our login flat out fails if we don't have proper parseable content
    mock_post.return_value.content = u''
    mock_post.return_value.text = ''
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999
    assert obj.notify('title', 'body', 'info') is False

    # General Internal Server Error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    assert obj.notify('title', 'body', 'info') is False

    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = str(mock_post.return_value.content)
    mock_get.return_value.content = mock_post.return_value.content
    mock_get.return_value.text = mock_post.return_value.text

    # Disable the port completely
    obj.port = None
    assert obj.notify('title', 'body', 'info') is True

    # An Empty return set (no query is made, but notification will still
    # succeed
    mock_sessions.return_value = {}
    assert obj.notify('title', 'body', 'info') is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_ifttt_plugin(mock_post, mock_get):
    """"""
    API: NotifyIFTTT() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    apikey = 'webhookid'
    event = 'event'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_get.return_value.content = '{}'
    mock_post.return_value.content = '{}'

    try:
        obj = plugins.NotifyIFTTT(apikey=apikey, event=None, event_args=None)
        # No token specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyIFTTT(apikey=apikey, event=event, event_args=None)
    assert(isinstance(obj, plugins.NotifyIFTTT))
    assert(len(obj.event_args) == 0)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True


def test_notify_stride_plugin():
    """"""
    API: NotifyStride() Extra Checks

    """"""
    try:
        # Initializes the plugin with devices set to a string
        plugins.NotifyStride(
            auth_token=None,
            cloud_id=str(uuid.uuid4()),
            convo_id=str(uuid.uuid4()),
        )
        # The code shouldn't make it here, we should throw an exception
        # on the previous line
        assert False

    except TypeError:
        assert True

    try:
        # Initializes the plugin with devices set to a string
        plugins.NotifyStride(
            auth_token='key',
            cloud_id=str(uuid.uuid4()),
            convo_id=None,
        )
        # The code shouldn't make it here, we should throw an exception
        # on the previous line
        assert False

    except TypeError:
        assert True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_join_plugin(mock_post, mock_get):
    """"""
    API: NotifyJoin() Extra Checks

    """"""
    # Generate some generic message types
    device = 'A' * 32
    group = 'group.chrome'
    apikey = 'a' * 32

    # Initializes the plugin with devices set to a string
    plugins.NotifyJoin(apikey=apikey, devices=group)

    # Initializes the plugin with devices set to None
    plugins.NotifyJoin(apikey=apikey, devices=None)

    # Initializes the plugin with devices set to a set
    p = plugins.NotifyJoin(apikey=apikey, devices=[group, device])

    # Prepare our mock responses
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.created
    mock_get.return_value.status_code = requests.codes.created

    # Disable throttling to speed up unit tests
    p.throttle_attempt = 0

    # Test notifications without a body or a title; nothing to send
    # so we return False
    p.notify(body=None, title=None, notify_type=NotifyType.INFO) is False


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_slack_plugin(mock_post, mock_get):
    """"""
    API: NotifySlack() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    token_a = 'A' * 9
    token_b = 'B' * 9
    token_c = 'c' * 24

    # Support strings
    channels = 'chan1,#chan2,+id,@user,,,'

    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels)
    assert(len(obj.channels) == 4)

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    # Empty Channel list
    try:
        plugins.NotifySlack(
            token_a=token_a, token_b=token_b, token_c=token_c,
            channels=None)
        assert(False)

    except TypeError:
        # we'll thrown because an empty list of channels was provided
        assert(True)

    # Test include_image
    obj = plugins.NotifySlack(
        token_a=token_a, token_b=token_b, token_c=token_c, channels=channels,
        include_image=True)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call includes an image with it's payload:
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_pushbullet_plugin(mock_post, mock_get):
    """"""
    API: NotifyPushBullet() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    accesstoken = 'a' * 32

    # Support strings
    recipients = '#chan1,#chan2,device,user@example.com,,,'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    obj = plugins.NotifyPushBullet(
        accesstoken=accesstoken, recipients=recipients)
    assert(isinstance(obj, plugins.NotifyPushBullet))
    assert(len(obj.recipients) == 4)

    obj = plugins.NotifyPushBullet(accesstoken=accesstoken)
    assert(isinstance(obj, plugins.NotifyPushBullet))
    # Default is to send to all devices, so there will be a
    # recipient here
    assert(len(obj.recipients) == 1)

    obj = plugins.NotifyPushBullet(accesstoken=accesstoken, recipients=set())
    assert(isinstance(obj, plugins.NotifyPushBullet))
    # Default is to send to all devices, so there will be a
    # recipient here
    assert(len(obj.recipients) == 1)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyPushBullet.parse_url(None) is None)
    assert(plugins.NotifyPushBullet.parse_url('') is None)
    assert(plugins.NotifyPushBullet.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_pushover_plugin(mock_post, mock_get):
    """"""
    API: NotifyPushover() Extra Checks

    """"""

    # Initialize some generic (but valid) tokens
    token = 'a' * 30
    user = 'u' * 30

    invalid_device = 'd' * 35

    # Support strings
    devices = 'device1,device2,,,,%s' % invalid_device

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    try:
        obj = plugins.NotifyPushover(user=user, token=None)
        # No token specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyPushover(user=user, token=token, devices=devices)
    assert(isinstance(obj, plugins.NotifyPushover))
    assert(len(obj.devices) == 3)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call fails because there is 1 invalid device
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is False

    obj = plugins.NotifyPushover(user=user, token=token)
    assert(isinstance(obj, plugins.NotifyPushover))
    # Default is to send to all devices, so there will be a
    # device defined here
    assert(len(obj.devices) == 1)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    # This call succeeds because all of the devices are valid
    assert obj.notify(title='title', body='body',
                      notify_type=NotifyType.INFO) is True

    obj = plugins.NotifyPushover(user=user, token=token, devices=set())
    assert(isinstance(obj, plugins.NotifyPushover))
    # Default is to send to all devices, so there will be a
    # device defined here
    assert(len(obj.devices) == 1)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyPushover.parse_url(None) is None)
    assert(plugins.NotifyPushover.parse_url('') is None)
    assert(plugins.NotifyPushover.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_rocketchat_plugin(mock_post, mock_get):
    """"""
    API: NotifyRocketChat() Extra Checks

    """"""
    # Chat ID
    recipients = 'l2g, lead2gold, #channel, #channel2'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_post.return_value.text = ''
    mock_get.return_value.text = ''

    try:
        obj = plugins.NotifyRocketChat(recipients=None)
        # invalid recipients list (None)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    try:
        obj = plugins.NotifyRocketChat(recipients=object())
        # invalid recipients list (object)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    try:
        obj = plugins.NotifyRocketChat(recipients=set())
        # invalid recipient list/set (no entries)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no recipients were
        # specified
        assert(True)

    obj = plugins.NotifyRocketChat(recipients=recipients)
    assert(isinstance(obj, plugins.NotifyRocketChat))
    assert(len(obj.channels) == 2)
    assert(len(obj.rooms) == 2)

    # Disable throttling to speed up unit tests
    obj.throttle_attempt = 0

    #
    # Logout
    #
    assert obj.logout() is True

    # Support the handling of an empty and invalid URL strings
    assert plugins.NotifyRocketChat.parse_url(None) is None
    assert plugins.NotifyRocketChat.parse_url('') is None
    assert plugins.NotifyRocketChat.parse_url(42) is None

    # Prepare Mock to fail
    mock_post.return_value.status_code = requests.codes.internal_server_error
    mock_get.return_value.status_code = requests.codes.internal_server_error
    mock_post.return_value.text = ''
    mock_get.return_value.text = ''

    #
    # Send Notification
    #
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    #
    # Logout
    #
    assert obj.logout() is False

    # KeyError handling
    mock_post.return_value.status_code = 999
    mock_get.return_value.status_code = 999

    #
    # Send Notification
    #
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    #
    # Logout
    #
    assert obj.logout() is False

    mock_post.return_value.text = ''
    # Generate exceptions
    mock_get.side_effect = requests.ConnectionError(
        0, 'requests.ConnectionError() not handled')
    mock_post.side_effect = mock_get.side_effect
    mock_get.return_value.text = ''
    mock_post.return_value.text = ''

    #
    # Send Notification
    #
    assert obj.send_notification(
        payload='test', notify_type=NotifyType.INFO) is False

    # Attempt the check again but fake a successful login
    obj.login = mock.Mock()
    obj.login.return_value = True
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    #
    # Logout
    #
    assert obj.logout() is False


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_toasty_plugin(mock_post, mock_get):
    """"""
    API: NotifyToasty() Extra Checks

    """"""

    # Support strings
    devices = 'device1,device2,,,,'

    # User
    user = 'l2g'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok

    try:
        obj = plugins.NotifyToasty(user=user, devices=None)
        # No devices specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyToasty(user=user, devices=set())
        # No devices specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyToasty(user=user, devices=devices)
    assert(isinstance(obj, plugins.NotifyToasty))
    assert(len(obj.devices) == 2)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyToasty.parse_url(None) is None)
    assert(plugins.NotifyToasty.parse_url('') is None)
    assert(plugins.NotifyToasty.parse_url(42) is None)


@mock.patch('requests.get')
@mock.patch('requests.post')
def test_notify_telegram_plugin(mock_post, mock_get):
    """"""
    API: NotifyTelegram() Extra Checks

    """"""
    # Bot Token
    bot_token = '123456789:abcdefg_hijklmnop'
    invalid_bot_token = 'abcd:123'

    # Chat ID
    chat_ids = 'l2g, lead2gold'

    # Prepare Mock
    mock_get.return_value = requests.Request()
    mock_post.return_value = requests.Request()
    mock_post.return_value.status_code = requests.codes.ok
    mock_get.return_value.status_code = requests.codes.ok
    mock_get.return_value.content = '{}'
    mock_post.return_value.content = '{}'

    try:
        obj = plugins.NotifyTelegram(bot_token=None, chat_ids=chat_ids)
        # invalid bot token (None)
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(
            bot_token=invalid_bot_token, chat_ids=chat_ids)
        # invalid bot token
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact an invalid token was
        # specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=set())
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=chat_ids)
    assert(isinstance(obj, plugins.NotifyTelegram))
    assert(len(obj.chat_ids) == 2)

    # Support the handling of an empty and invalid URL strings
    assert(plugins.NotifyTelegram.parse_url(None) is None)
    assert(plugins.NotifyTelegram.parse_url('') is None)
    assert(plugins.NotifyTelegram.parse_url(42) is None)

    # Prepare Mock to fail
    response = mock.Mock()
    response.status_code = requests.codes.internal_server_error

    # a error response
    response.text = dumps({
        'description': 'test',
    })
    mock_get.return_value = response
    mock_post.return_value = response

    # No image asset
    nimg_obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=chat_ids)
    nimg_obj.asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

    # Disable throttling to speed up unit tests
    nimg_obj.throttle_attempt = 0
    obj.throttle_attempt = 0

    # This tests erroneous messages involving multiple chat ids
    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # This tests erroneous messages involving a single chat id
    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids='l2g')
    nimg_obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids='l2g')
    nimg_obj.asset = AppriseAsset(image_path_mask=False, image_url_mask=False)

    assert obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # Bot Token Detection
    # Just to make it clear to people reading this code and trying to learn
    # what is going on.  Apprise tries to detect the bot owner if you don't
    # specify a user to message.  The idea is to just default to messaging
    # the bot owner himself (it makes it easier for people).  So we're testing
    # the creating of a Telegram Notification without providing a chat ID.
    # We're testing the error handling of this bot detection section of the
    # code
    mock_post.return_value.content = dumps({
        ""ok"": True,
        ""result"": [{
            ""update_id"": 645421321,
            ""message"": {
                ""message_id"": 1,
                ""from"": {
                    ""id"": 532389719,
                    ""is_bot"": False,
                    ""first_name"": ""Chris"",
                    ""language_code"": ""en-US""
                },
                ""chat"": {
                    ""id"": 532389719,
                    ""first_name"": ""Chris"",
                    ""type"": ""private""
                },
                ""date"": 1519694394,
                ""text"": ""/start"",
                ""entities"": [{
                    ""offset"": 0,
                    ""length"": 6,
                    ""type"": ""bot_command"",
                }],
            }},
        ],
    })
    mock_post.return_value.status_code = requests.codes.ok

    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
    assert(len(obj.chat_ids) == 1)
    assert(obj.chat_ids[0] == '532389719')

    # Do the test again, but without the expected (parsed response)
    mock_post.return_value.content = dumps({
        ""ok"": True,
        ""result"": [{
            ""message"": {
                ""text"": ""/ignored.entry"",
            }},
        ],
    })
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Test our bot detection with a internal server error
    mock_post.return_value.status_code = requests.codes.internal_server_error
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Test our bot detection with an unmappable html error
    mock_post.return_value.status_code = 999
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Do it again but this time provide a failure message
    mock_post.return_value.content = dumps({'description': 'Failure Message'})
    try:
        obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
        # No chat_ids specified
        assert(False)

    except TypeError:
        # Exception should be thrown about the fact no token was specified
        assert(True)

    # Do it again but this time provide a failure message and perform a
    # notification without a bot detection by providing at least 1 chat id
    obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=['@abcd'])
    assert nimg_obj.notify(
        title='title', body='body', notify_type=NotifyType.INFO) is False

    # iterate over our exceptions and test them
    for _exception in REQUEST_EXCEPTIONS:
        mock_post.side_effect = _exception
        try:
            obj = plugins.NotifyTelegram(bot_token=bot_token, chat_ids=None)
            # No chat_ids specified
            assert(False)

        except TypeError:
            # Exception should be thrown about the fact no token was specified
            assert(True)
","@@ -291,6 +291,72 @@ TEST_URLS = (
         'test_requests_exceptions': True,
     }),
 
+    ##################################
+    # NotifyIFTTT - If This Than That
+    ##################################
+    ('ifttt://', {
+        'instance': None,
+    }),
+    # No User
+    ('ifttt://EventID/', {
+        'instance': TypeError,
+    }),
+    # Value1 gets assigned Entry1
+    # Title = <assigned title>
+    # Body = <assigned body>
+    ('ifttt://WebHookID@EventID/Entry1/', {
+        'instance': plugins.NotifyIFTTT,
+    }),
+    # Value1, Value2, and Value2, the below assigns:
+    #   Value1 = Entry1
+    #   Value2 = AnotherEntry
+    #   Value3 = ThirdValue
+    #   Title = <assigned title>
+    #   Body = <assigned body>
+    ('ifttt://WebHookID@EventID/Entry1/AnotherEntry/ThirdValue', {
+        'instance': plugins.NotifyIFTTT,
+    }),
+    # Mix and match content, the below assigns:
+    #   Value1 = FirstValue
+    #   AnotherKey = Hello
+    #   Value5 = test
+    #   Title = <assigned title>
+    #   Body = <assigned body>
+    ('ifttt://WebHookID@EventID/FirstValue/?AnotherKey=Hello&Value5=test', {
+        'instance': plugins.NotifyIFTTT,
+    }),
+    # This would assign:
+    #   Value1 = FirstValue
+    #   Title = <blank> - disable the one passed by the notify call
+    #   Body = <blank> - disable the one passed by the notify call
+    # The idea here is maybe you just want to use the apprise IFTTTT hook
+    # to trigger something and not nessisarily pass text along to it
+    ('ifttt://WebHookID@EventID/FirstValue/?Title=&Body=', {
+        'instance': plugins.NotifyIFTTT,
+    }),
+    ('ifttt://:@/', {
+        'instance': None,
+    }),
+    # Test website connection failures
+    ('ifttt://WebHookID@EventID', {
+        'instance': plugins.NotifyIFTTT,
+        # force a failure
+        'response': False,
+        'requests_response_code': requests.codes.internal_server_error,
+    }),
+    ('ifttt://WebHookID@EventID', {
+        'instance': plugins.NotifyIFTTT,
+        # throw a bizzare code forcing us to fail to look it up
+        'response': False,
+        'requests_response_code': 999,
+    }),
+    ('ifttt://WebHookID@EventID', {
+        'instance': plugins.NotifyIFTTT,
+        # Throws a series of connection and transfer exceptions when this flag
+        # is set and tests that we gracfully handle them
+        'test_requests_exceptions': True,
+    }),
+
     ##################################
     # NotifyJoin
     ##################################
@@ -1960,6 +2026,46 @@ def test_notify_emby_plugin_notify(mock_post, mock_get, mock_logout,
     assert obj.notify('title', 'body', 'info') is True
 
 
+@mock.patch('requests.get')
+@mock.patch('requests.post')
+def test_notify_ifttt_plugin(mock_post, mock_get):
+    """"""
+    API: NotifyIFTTT() Extra Checks
+
+    """"""
+
+    # Initialize some generic (but valid) tokens
+    apikey = 'webhookid'
+    event = 'event'
+
+    # Prepare Mock
+    mock_get.return_value = requests.Request()
+    mock_post.return_value = requests.Request()
+    mock_post.return_value.status_code = requests.codes.ok
+    mock_get.return_value.status_code = requests.codes.ok
+    mock_get.return_value.content = '{}'
+    mock_post.return_value.content = '{}'
+
+    try:
+        obj = plugins.NotifyIFTTT(apikey=apikey, event=None, event_args=None)
+        # No token specified
+        assert(False)
+
+    except TypeError:
+        # Exception should be thrown about the fact no token was specified
+        assert(True)
+
+    obj = plugins.NotifyIFTTT(apikey=apikey, event=event, event_args=None)
+    assert(isinstance(obj, plugins.NotifyIFTTT))
+    assert(len(obj.event_args) == 0)
+
+    # Disable throttling to speed up unit tests
+    obj.throttle_attempt = 0
+
+    assert obj.notify(title='title', body='body',
+                      notify_type=NotifyType.INFO) is True
+
+
 def test_notify_stride_plugin():
     """"""
     API: NotifyStride() Extra Checks
",add examples to apprise ifttttt hook,-1.03,7,106
cc6151909ed5fc666ccecffbf1978b5d18d84bf1,fixed KODI notification bug,NotifyXBMC.py,"# -*- coding: utf-8 -*-
#
# XBMC/KODI Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize

# Image Support (128x128)
XBMC_IMAGE_XY = NotifyImageSize.XY_128


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    xbmc_default_port = 8080

    # XBMC default protocol version (v2)
    xbmc_remote_protocol = 2

    # KODI default protocol version (v6)
    kodi_remote_protocol = 6

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XBMC_IMAGE_XY, **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Default protocol
        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '6.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url
            if notify_type is NotifyType.FAILURE:
                payload['type'] = 'error'

            elif notify_type is NotifyType.WARNING:
                payload['type'] = 'warning'

            else:
                payload['type'] = 'info'

        return (headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url

        return (headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC/KODI Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == self.xbmc_remote_protocol:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # KODI v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if self.port:
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)
        if not results:
            # We're done early
            return results

        # We want to set our protocol depending on whether we're using XBMC
        # or KODI
        if results.get('schema', '').startswith('xbmc'):
            # XBMC Support
            results['protocol'] = NotifyXBMC.xbmc_remote_protocol

            # Assign Default XBMC Port
            if not results['port']:
                results['port'] = NotifyXBMC.xbmc_default_port

        else:
            # KODI Support
            results['protocol'] = NotifyXBMC.kodi_remote_protocol

        return results
","# -*- coding: utf-8 -*-
#
# XBMC/KODI Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize

# Image Support (128x128)
XBMC_IMAGE_XY = NotifyImageSize.XY_128


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    xbmc_default_port = 8080

    # XBMC default protocol version (v2)
    xbmc_remote_protocol = 2

    # KODI default protocol version (v6)
    kodi_remote_protocol = 6

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(
            title_maxlen=250, body_maxlen=32768,
            image_size=XBMC_IMAGE_XY, **kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Default protocol
        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url
            if notify_type is NotifyType.FAILURE:
                payload['type'] = 'error'

            elif notify_type is NotifyType.WARNING:
                payload['type'] = 'warning'

            else:
                payload['type'] = 'info'

        return (headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url

        return (headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC/KODI Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == self.xbmc_remote_protocol:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # KODI v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if self.port:
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)
        if not results:
            # We're done early
            return results

        # We want to set our protocol depending on whether we're using XBMC
        # or KODI
        if results.get('schema', '').startswith('xbmc'):
            # XBMC Support
            results['protocol'] = NotifyXBMC.xbmc_remote_protocol

            # Assign Default XBMC Port
            if not results['port']:
                results['port'] = NotifyXBMC.xbmc_default_port

        else:
            # KODI Support
            results['protocol'] = NotifyXBMC.kodi_remote_protocol

        return results
","@@ -80,7 +80,7 @@ class NotifyXBMC(NotifyBase):
 
         # prepare JSON Object
         payload = {
-            'jsonrpc': '6.0',
+            'jsonrpc': '2.0',
             'method': 'GUI.ShowNotification',
             'params': {
                 'title': title,
",add missing comment,0.0,0,0
ae2f11f27e109f6e055da20238bd465281a1431e,fixes icon display on kodi v6 and v2 protocol; refs #13,NotifyXBMC.py,"# -*- coding: utf-8 -*-
#
# XBMC/KODI Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    xbmc_default_port = 8080

    # Allows the user to specify the NotifyImageSize object
    image_size = NotifyImageSize.XY_128

    # XBMC default protocol version (v2)
    xbmc_remote_protocol = 2

    # KODI default protocol version (v6)
    kodi_remote_protocol = 6

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(**kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Default protocol
        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url
            if notify_type is NotifyType.FAILURE:
                payload['type'] = 'error'

            elif notify_type is NotifyType.WARNING:
                payload['type'] = 'warning'

            else:
                payload['type'] = 'info'

        return (headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['image'] = image_url

        return (headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC/KODI Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == self.xbmc_remote_protocol:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # KODI v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if self.port:
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)
        if not results:
            # We're done early
            return results

        # We want to set our protocol depending on whether we're using XBMC
        # or KODI
        if results.get('schema', '').startswith('xbmc'):
            # XBMC Support
            results['protocol'] = NotifyXBMC.xbmc_remote_protocol

            # Assign Default XBMC Port
            if not results['port']:
                results['port'] = NotifyXBMC.xbmc_default_port

        else:
            # KODI Support
            results['protocol'] = NotifyXBMC.kodi_remote_protocol

        return results
","# -*- coding: utf-8 -*-
#
# XBMC/KODI Notify Wrapper
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import dumps

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..common import NotifyType
from ..common import NotifyImageSize


class NotifyXBMC(NotifyBase):
    """"""
    A wrapper for XBMC/KODI Notifications
    """"""

    # The default protocols
    protocol = ('xbmc', 'kodi')

    # The default secure protocols
    secure_protocol = ('xbmc', 'kodis')

    # XBMC uses the http protocol with JSON requests
    xbmc_default_port = 8080

    # Allows the user to specify the NotifyImageSize object
    image_size = NotifyImageSize.XY_128

    # XBMC default protocol version (v2)
    xbmc_remote_protocol = 2

    # KODI default protocol version (v6)
    kodi_remote_protocol = 6

    def __init__(self, **kwargs):
        """"""
        Initialize XBMC/KODI Object
        """"""
        super(NotifyXBMC, self).__init__(**kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Prepare the default header
        self.headers = {
            'User-Agent': self.app_id,
            'Content-Type': 'application/json'
        }

        # Default protocol
        self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)

    def _payload_60(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for KODI API v6.0

        Returns (headers, payload)
        """"""

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['params']['image'] = image_url
            if notify_type is NotifyType.FAILURE:
                payload['type'] = 'error'

            elif notify_type is NotifyType.WARNING:
                payload['type'] = 'warning'

            else:
                payload['type'] = 'info'

        return (self.headers, dumps(payload))

    def _payload_20(self, title, body, notify_type, **kwargs):
        """"""
        Builds payload for XBMC API v2.0

        Returns (headers, payload)
        """"""

        # prepare JSON Object
        payload = {
            'jsonrpc': '2.0',
            'method': 'GUI.ShowNotification',
            'params': {
                'title': title,
                'message': body,
                # displaytime is defined in microseconds
                'displaytime': 12000,
            },
            'id': 1,
        }

        image_url = self.image_url(notify_type)
        if image_url:
            payload['params']['image'] = image_url

        return (self.headers, dumps(payload))

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        Perform XBMC/KODI Notification
        """"""

        # Limit results to just the first 2 line otherwise
        # there is just to much content to display
        body = re.split('[\r\n]+', body)
        body[0] = body[0].strip('#').strip()
        body = '\r\n'.join(body[0:2])

        if self.protocol == self.xbmc_remote_protocol:
            # XBMC v2.0
            (headers, payload) = self._payload_20(
                title, body, notify_type, **kwargs)

        else:
            # KODI v6.0
            (headers, payload) = self._payload_60(
                title, body, notify_type, **kwargs)

        auth = None
        if self.user:
            auth = (self.user, self.password)

        url = '%s://%s' % (self.schema, self.host)
        if self.port:
            url += ':%d' % self.port

        url += '/jsonrpc'

        self.logger.debug('XBMC/KODI POST URL: %s (cert_verify=%r)' % (
            url, self.verify_certificate,
        ))
        self.logger.debug('XBMC/KODI Payload: %s' % str(payload))
        try:
            r = requests.post(
                url,
                data=payload,
                headers=headers,
                auth=auth,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification:'
                        '%s (error=%s).' % (
                            HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send XBMC/KODI notification '
                        '(error=%s).' % r.status_code)

                # Return; we're done
                return False

            else:
                self.logger.info('Sent XBMC/KODI notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending XBMC/KODI '
                'notification.'
            )
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)
        if not results:
            # We're done early
            return results

        # We want to set our protocol depending on whether we're using XBMC
        # or KODI
        if results.get('schema', '').startswith('xbmc'):
            # XBMC Support
            results['protocol'] = NotifyXBMC.xbmc_remote_protocol

            # Assign Default XBMC Port
            if not results['port']:
                results['port'] = NotifyXBMC.xbmc_default_port

        else:
            # KODI Support
            results['protocol'] = NotifyXBMC.kodi_remote_protocol

        return results
","@@ -61,6 +61,12 @@ class NotifyXBMC(NotifyBase):
         else:
             self.schema = 'http'
 
+        # Prepare the default header
+        self.headers = {
+            'User-Agent': self.app_id,
+            'Content-Type': 'application/json'
+        }
+
         # Default protocol
         self.protocol = kwargs.get('protocol', self.xbmc_remote_protocol)
 
@@ -71,11 +77,6 @@ class NotifyXBMC(NotifyBase):
         Returns (headers, payload)
         """"""
 
-        headers = {
-            'User-Agent': self.app_id,
-            'Content-Type': 'application/json'
-        }
-
         # prepare JSON Object
         payload = {
             'jsonrpc': '2.0',
@@ -91,7 +92,7 @@ class NotifyXBMC(NotifyBase):
 
         image_url = self.image_url(notify_type)
         if image_url:
-            payload['image'] = image_url
+            payload['params']['image'] = image_url
             if notify_type is NotifyType.FAILURE:
                 payload['type'] = 'error'
 
@@ -101,7 +102,7 @@ class NotifyXBMC(NotifyBase):
             else:
                 payload['type'] = 'info'
 
-        return (headers, dumps(payload))
+        return (self.headers, dumps(payload))
 
     def _payload_20(self, title, body, notify_type, **kwargs):
         """"""
@@ -110,11 +111,6 @@ class NotifyXBMC(NotifyBase):
         Returns (headers, payload)
         """"""
 
-        headers = {
-            'User-Agent': self.app_id,
-            'Content-Type': 'application/json'
-        }
-
         # prepare JSON Object
         payload = {
             'jsonrpc': '2.0',
@@ -130,9 +126,9 @@ class NotifyXBMC(NotifyBase):
 
         image_url = self.image_url(notify_type)
         if image_url:
-            payload['image'] = image_url
+            payload['params']['image'] = image_url
 
-        return (headers, dumps(payload))
+        return (self.headers, dumps(payload))
 
     def notify(self, title, body, notify_type, **kwargs):
         """"""
",add missing classes,0.32,0,-4
6177e6553fdc2fcd9c3361a4e72b586f34aacadf,EmailPlugin now better supports to= variable; fixes #11,NotifyEmail.py,"# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, to, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Store To Addr
        self.to_addr = to

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        match = NotifyBase.is_email(self.from_addr)
        if not match:
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        # Using the match, we want to extract the user id and domain
        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.to_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        else:
            # get 'To' email address
            to_addr = '%s@%s' % (
                re.split(
                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )

        # Attempt to detect 'from' email address
        from_addr = to_addr
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])
            if not NotifyBase.is_email(from_addr):
                # Lets be clever and attempt to make the from
                # address an email based on the to address
                from_addr = '%s@%s' % (
                    re.split('[\s@]+', from_addr)[0],
                    re.split('[\s@]+', to_addr)[-1],
                )

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)
        self.to_addr = kwargs.get('to', self.from_addr)

        if not NotifyBase.is_email(self.from_addr):
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        # Attempt to detect 'from' email address
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])

        else:
            # get 'To' email address
            from_addr = '%s@%s' % (
                re.split(
                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )
            # Lets be clever and attempt to make the from
            # address an email based on the to address
            from_addr = '%s@%s' % (
                re.split('[\s@]+', from_addr)[0],
                re.split('[\s@]+', from_addr)[-1],
            )

        # Attempt to detect 'to' email address
        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        if not to_addr:
            # Send to ourselves if not otherwise specified to do so
            to_addr = from_addr

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","@@ -128,15 +128,12 @@ class NotifyEmail(NotifyBase):
     # Default SMTP Timeout (in seconds)
     connect_timeout = 15
 
-    def __init__(self, to, **kwargs):
+    def __init__(self, **kwargs):
         """"""
         Initialize Email Object
         """"""
         super(NotifyEmail, self).__init__(**kwargs)
 
-        # Store To Addr
-        self.to_addr = to
-
         # Handle SMTP vs SMTPS (Secure vs UnSecure)
         if not self.port:
             if self.secure:
@@ -156,22 +153,21 @@ class NotifyEmail(NotifyBase):
         # addresses from the URL provided
         self.from_name = kwargs.get('name', None)
         self.from_addr = kwargs.get('from', None)
+        self.to_addr = kwargs.get('to', self.from_addr)
+
+        if not NotifyBase.is_email(self.from_addr):
+            # Parse Source domain based on from_addr
+            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)
 
         if not NotifyBase.is_email(self.to_addr):
             raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)
 
-        match = NotifyBase.is_email(self.from_addr)
-        if not match:
-            # Parse Source domain based on from_addr
-            raise TypeError('Invalid ~From~ email format: %s' % self.to_addr)
-
         # Now detect the SMTP Server
         self.smtp_host = kwargs.get('smtp_host', '')
 
         # Apply any defaults based on certain known configurations
         self.NotifyEmailDefaults()
 
-        # Using the match, we want to extract the user id and domain
         return
 
     def NotifyEmailDefaults(self):
@@ -190,7 +186,7 @@ class NotifyEmail(NotifyBase):
             self.logger.debug('Scanning %s against %s' % (
                 self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
             ))
-            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.to_addr)
+            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
             if match:
                 self.logger.info(
                     'Applying %s Defaults' %
@@ -325,28 +321,31 @@ class NotifyEmail(NotifyBase):
             if len(format) > 0 and format[0] == 't':
                 results['notify_format'] = NotifyFormat.TEXT
 
-        if 'to' in results['qsd'] and len(results['qsd']['to']):
-            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()
+        # Attempt to detect 'from' email address
+        if 'from' in results['qsd'] and len(results['qsd']['from']):
+            from_addr = NotifyBase.unquote(results['qsd']['from'])
 
         else:
             # get 'To' email address
-            to_addr = '%s@%s' % (
+            from_addr = '%s@%s' % (
                 re.split(
                     '[\s@]+', NotifyBase.unquote(results['user']))[0],
                 results.get('host', '')
             )
+            # Lets be clever and attempt to make the from
+            # address an email based on the to address
+            from_addr = '%s@%s' % (
+                re.split('[\s@]+', from_addr)[0],
+                re.split('[\s@]+', from_addr)[-1],
+            )
 
-        # Attempt to detect 'from' email address
-        from_addr = to_addr
-        if 'from' in results['qsd'] and len(results['qsd']['from']):
-            from_addr = NotifyBase.unquote(results['qsd']['from'])
-            if not NotifyBase.is_email(from_addr):
-                # Lets be clever and attempt to make the from
-                # address an email based on the to address
-                from_addr = '%s@%s' % (
-                    re.split('[\s@]+', from_addr)[0],
-                    re.split('[\s@]+', to_addr)[-1],
-                )
+        # Attempt to detect 'to' email address
+        if 'to' in results['qsd'] and len(results['qsd']['to']):
+            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()
+
+        if not to_addr:
+            # Send to ourselves if not otherwise specified to do so
+            to_addr = from_addr
 
         if 'name' in results['qsd'] and len(results['qsd']['name']):
             # Extract from name to associate with from address
",add more info about the email support,0.08,0,-1
6177e6553fdc2fcd9c3361a4e72b586f34aacadf,EmailPlugin now better supports to= variable; fixes #11,test_email_plugin.py,"# -*- coding: utf-8 -*-
#
# NotifyEmail - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
import smtplib
import mock
import re


TEST_URLS = (
    ##################################
    # NotifyEmail
    ##################################
    ('mailto://', {
        'instance': None,
    }),
    ('mailtos://', {
        'instance': None,
    }),
    ('mailto://:@/', {
        'instance': None
    }),
    # No Username
    ('mailtos://:pass@nuxref.com:567', {
        # Can't prepare a To address using this expression
        'exception': TypeError,
    }),

    # Pre-Configured Email Services
    ('mailto://user:pass@gmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@hotmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@live.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@prontomail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.ca', {
        'instance': plugins.NotifyEmail,
    }),

    # Custom Emails
    ('mailtos://user:pass@nuxref.com:567', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@nuxref.com:567?format=html', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailtos://user:pass@nuxref.com:567?to=l2g@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailtos://user:pass@example.com?smtp=smtp.example.com&timeout=5'
        '&name=l2g&from=noreply@example.com', {
            'instance': plugins.NotifyEmail,
        },
    ),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome', {
            'instance': plugins.NotifyEmail,
        },
    ),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome&format=text', {
            'instance': plugins.NotifyEmail,
        },
    ),
    # No Password
    ('mailtos://user:@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    # Invalid From Address (falls back to using To Address)
    ('mailtos://user:pass@nuxref.com?from=@', {
        'exception': TypeError,
    }),
    # Invalid To Address
    ('mailtos://nuxref.com?user=&pass=.', {
        'exception': TypeError,
    }),
    # Valid URL, but can't structure a proper email
    ('mailtos://nuxref.com?user=%20!&pass=.', {
        'exception': TypeError,
    }),
    # Invalid To Address
    ('mailtos://nuxref.com?to=test', {
        'exception': TypeError,
    }),
    # Can make a To address using what we have (l2g@nuxref.com)
    ('mailtos://nuxref.com?user=l2g&pass=.', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@localhost:2525', {
        'instance': plugins.NotifyEmail,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_smtplib_exceptions': True,
    }),
)


@mock.patch('smtplib.SMTP')
def test_email_plugin(mock_smtp):
    """"""
    API: NotifyEmail Plugin()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        test_smtplib_exceptions = meta.get(
            'test_smtplib_exceptions', False)

        # Our mock of our socket action
        mock_socket = mock.Mock()
        mock_socket.starttls.return_value = True
        mock_socket.login.return_value = True

        # Create a mock SMTP Object
        mock_smtp.return_value = mock_socket

        if test_smtplib_exceptions:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_smtplib_exceptions = (
                smtplib.SMTPHeloError(
                    0, 'smtplib.SMTPHeloError() not handled'),
                smtplib.SMTPException(
                    0, 'smtplib.SMTPException() not handled'),
                RuntimeError(
                    0, 'smtplib.HTTPError() not handled'),
                smtplib.SMTPRecipientsRefused(
                    'smtplib.SMTPRecipientsRefused() not handled'),
                smtplib.SMTPSenderRefused(
                    0, 'smtplib.SMTPSenderRefused() not handled',
                    'addr@example.com'),
                smtplib.SMTPDataError(
                    0, 'smtplib.SMTPDataError() not handled'),
                smtplib.SMTPServerDisconnected(
                    'smtplib.SMTPServerDisconnected() not handled'),
            )

        try:
            obj = Apprise.instantiate(url, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_smtplib_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=NotifyType.INFO) == response

                else:
                    for exception in test_smtplib_exceptions:
                        mock_socket.sendmail.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))


@mock.patch('smtplib.SMTP')
def test_webbase_lookup(mock_smtp):
    """"""
    API: Web Based Lookup Tests

    """"""

    from apprise.plugins import NotifyEmailBase

    # Insert a test email at the head of our table
    NotifyEmailBase.WEBBASE_LOOKUP_TABLE = (
        (
            # Testing URL
            'Testing Lookup',
            re.compile(r'^(?P<id>[^@]+)@(?P<domain>l2g\.com)$', re.I),
            {
                'port': 123,
                'smtp_host': 'smtp.l2g.com',
                'secure': True,
                'login_type': (NotifyEmailBase.WebBaseLogin.USERID, )
            },
        ),
    ) + NotifyEmailBase.WEBBASE_LOOKUP_TABLE

    obj = Apprise.instantiate(
        'mailto://user:pass@l2g.com', suppress_exceptions=True)

    assert(isinstance(obj, plugins.NotifyEmail))
    assert obj.to_addr == 'user@l2g.com'
    assert obj.from_addr == 'user@l2g.com'
    assert obj.password == 'pass'
    assert obj.user == 'user'
    assert obj.secure is True
    assert obj.port == 123
    assert obj.smtp_host == 'smtp.l2g.com'
","# -*- coding: utf-8 -*-
#
# NotifyEmail - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
import smtplib
import mock
import re


TEST_URLS = (
    ##################################
    # NotifyEmail
    ##################################
    ('mailto://', {
        'instance': None,
    }),
    ('mailtos://', {
        'instance': None,
    }),
    ('mailto://:@/', {
        'instance': None
    }),
    # No Username
    ('mailtos://:pass@nuxref.com:567', {
        # Can't prepare a To address using this expression
        'exception': TypeError,
    }),

    # Pre-Configured Email Services
    ('mailto://user:pass@gmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@hotmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@live.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@prontomail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.ca', {
        'instance': plugins.NotifyEmail,
    }),

    # Custom Emails
    ('mailtos://user:pass@nuxref.com:567', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@nuxref.com:567?format=html', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailtos://user:pass@nuxref.com:567?to=l2g@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailtos://user:pass@example.com?smtp=smtp.example.com&timeout=5'
        '&name=l2g&from=noreply@example.com', {
            'instance': plugins.NotifyEmail,
        },
    ),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome', {
            'instance': plugins.NotifyEmail,
        },
    ),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome&format=text', {
            'instance': plugins.NotifyEmail,
        },
    ),
    # No Password
    ('mailtos://user:@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    # Invalid From Address
    ('mailtos://user:pass@nuxref.com?from=@', {
        'exception': TypeError,
    }),
    # Invalid From Address
    ('mailtos://nuxref.com?user=&pass=.', {
        'exception': TypeError,
    }),
    # Invalid To Address
    ('mailtos://user:pass@nuxref.com?to=@', {
        'exception': TypeError,
    }),
    # Valid URL, but can't structure a proper email
    ('mailtos://nuxref.com?user=%20!&pass=.', {
        'exception': TypeError,
    }),
    # Invalid From (and To) Address
    ('mailtos://nuxref.com?to=test', {
        'exception': TypeError,
    }),
    # Can make a To address using what we have (l2g@nuxref.com)
    ('mailtos://nuxref.com?user=l2g&pass=.', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@localhost:2525', {
        'instance': plugins.NotifyEmail,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_smtplib_exceptions': True,
    }),
)


@mock.patch('smtplib.SMTP')
def test_email_plugin(mock_smtp):
    """"""
    API: NotifyEmail Plugin()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        test_smtplib_exceptions = meta.get(
            'test_smtplib_exceptions', False)

        # Our mock of our socket action
        mock_socket = mock.Mock()
        mock_socket.starttls.return_value = True
        mock_socket.login.return_value = True

        # Create a mock SMTP Object
        mock_smtp.return_value = mock_socket

        if test_smtplib_exceptions:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_smtplib_exceptions = (
                smtplib.SMTPHeloError(
                    0, 'smtplib.SMTPHeloError() not handled'),
                smtplib.SMTPException(
                    0, 'smtplib.SMTPException() not handled'),
                RuntimeError(
                    0, 'smtplib.HTTPError() not handled'),
                smtplib.SMTPRecipientsRefused(
                    'smtplib.SMTPRecipientsRefused() not handled'),
                smtplib.SMTPSenderRefused(
                    0, 'smtplib.SMTPSenderRefused() not handled',
                    'addr@example.com'),
                smtplib.SMTPDataError(
                    0, 'smtplib.SMTPDataError() not handled'),
                smtplib.SMTPServerDisconnected(
                    'smtplib.SMTPServerDisconnected() not handled'),
            )

        try:
            obj = Apprise.instantiate(url, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_smtplib_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=NotifyType.INFO) == response

                else:
                    for exception in test_smtplib_exceptions:
                        mock_socket.sendmail.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))


@mock.patch('smtplib.SMTP')
def test_webbase_lookup(mock_smtp):
    """"""
    API: Web Based Lookup Tests

    """"""

    from apprise.plugins import NotifyEmailBase

    # Insert a test email at the head of our table
    NotifyEmailBase.WEBBASE_LOOKUP_TABLE = (
        (
            # Testing URL
            'Testing Lookup',
            re.compile(r'^(?P<id>[^@]+)@(?P<domain>l2g\.com)$', re.I),
            {
                'port': 123,
                'smtp_host': 'smtp.l2g.com',
                'secure': True,
                'login_type': (NotifyEmailBase.WebBaseLogin.USERID, )
            },
        ),
    ) + NotifyEmailBase.WEBBASE_LOOKUP_TABLE

    obj = Apprise.instantiate(
        'mailto://user:pass@l2g.com', suppress_exceptions=True)

    assert(isinstance(obj, plugins.NotifyEmail))
    assert obj.to_addr == 'user@l2g.com'
    assert obj.from_addr == 'user@l2g.com'
    assert obj.password == 'pass'
    assert obj.user == 'user'
    assert obj.secure is True
    assert obj.port == 123
    assert obj.smtp_host == 'smtp.l2g.com'
","@@ -101,19 +101,23 @@ TEST_URLS = (
     ('mailtos://user:@nuxref.com', {
         'instance': plugins.NotifyEmail,
     }),
-    # Invalid From Address (falls back to using To Address)
+    # Invalid From Address
     ('mailtos://user:pass@nuxref.com?from=@', {
         'exception': TypeError,
     }),
-    # Invalid To Address
+    # Invalid From Address
     ('mailtos://nuxref.com?user=&pass=.', {
         'exception': TypeError,
     }),
+    # Invalid To Address
+    ('mailtos://user:pass@nuxref.com?to=@', {
+        'exception': TypeError,
+    }),
     # Valid URL, but can't structure a proper email
     ('mailtos://nuxref.com?user=%20!&pass=.', {
         'exception': TypeError,
     }),
-    # Invalid To Address
+    # Invalid From (and To) Address
     ('mailtos://nuxref.com?to=test', {
         'exception': TypeError,
     }),
",add test urls,-0.02,0,4
dbab994f3707c2ce4ceb9bb57781ad33be35d6c3,pep8 fixes,NotifyEmail.py,"# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)
        self.to_addr = kwargs.get('to', self.from_addr)

        if not NotifyBase.is_email(self.from_addr):
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        # bind the socket variable to the current namespace
        socket = None
        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            if socket is not None: # pragma: no branch
                socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        # Attempt to detect 'from' email address
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])

        else:
            # get 'To' email address
            from_addr = '%s@%s' % (
                re.split(
                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )
            # Lets be clever and attempt to make the from
            # address an email based on the to address
            from_addr = '%s@%s' % (
                re.split('[\s@]+', from_addr)[0],
                re.split('[\s@]+', from_addr)[-1],
            )

        # Attempt to detect 'to' email address
        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        if not to_addr:
            # Send to ourselves if not otherwise specified to do so
            to_addr = from_addr

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(r'^(?P<id>[^@]+)@(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)
        self.to_addr = kwargs.get('to', self.from_addr)

        if not NotifyBase.is_email(self.from_addr):
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)

                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split('[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        # bind the socket variable to the current namespace
        socket = None
        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket = smtplib.SMTP(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure:
                # Handle Secure Connections
                self.logger.debug('Securing connection with TLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            if socket is not None:  # pragma: no branch
                socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        # Attempt to detect 'from' email address
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])

        else:
            # get 'To' email address
            from_addr = '%s@%s' % (
                re.split(
                    '[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )
            # Lets be clever and attempt to make the from
            # address an email based on the to address
            from_addr = '%s@%s' % (
                re.split('[\s@]+', from_addr)[0],
                re.split('[\s@]+', from_addr)[-1],
            )

        # Attempt to detect 'to' email address
        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        if not to_addr:
            # Send to ourselves if not otherwise specified to do so
            to_addr = from_addr

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","@@ -291,7 +291,7 @@ class NotifyEmail(NotifyBase):
 
         finally:
             # Gracefully terminate the connection with the server
-            if socket is not None: # pragma: no branch
+            if socket is not None:  # pragma: no branch
                 socket.quit()
 
         return True
",fix lint,0.0,0,0
dbab994f3707c2ce4ceb9bb57781ad33be35d6c3,pep8 fixes,test_cli.py,"# -*- coding: utf-8 -*-
#
# Apprise CLI Unit Tests
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from __future__ import print_function
from __future__ import unicode_literals
from apprise import cli
from apprise import NotifyBase
from click.testing import CliRunner
from apprise.Apprise import SCHEMA_MAP


def test_apprise_cli():
    """"""
    API: Apprise() CLI

    """"""

    class GoodNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(GoodNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return True

    class BadNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(BadNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return False

    # Set up our notification types
    SCHEMA_MAP['good'] = GoodNotification
    SCHEMA_MAP['bad'] = BadNotification

    runner = CliRunner()
    result = runner.invoke(cli.main)
    # no servers specified; we return 1 (non-zero)
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-v'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-vv'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-vvv'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, [
        '-t', 'test title',
        '-b', 'test body',
        'good://localhost',
    ])
    assert result.exit_code == 0

    result = runner.invoke(cli.main, [
            '-t', 'test title',
            'good://localhost',
        ],
        input='test stdin body\n',
    )
    assert result.exit_code == 0

    result = runner.invoke(cli.main, [
        '-t', 'test title',
        '-b', 'test body',
        'bad://localhost',
    ])
    assert result.exit_code == 1
","# -*- coding: utf-8 -*-
#
# Apprise CLI Unit Tests
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from __future__ import print_function
from __future__ import unicode_literals
from apprise import cli
from apprise import NotifyBase
from click.testing import CliRunner
from apprise.Apprise import SCHEMA_MAP


def test_apprise_cli():
    """"""
    API: Apprise() CLI

    """"""

    class GoodNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(GoodNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return True

    class BadNotification(NotifyBase):
        def __init__(self, **kwargs):
            super(BadNotification, self).__init__()

        def notify(self, **kwargs):
            # Pretend everything is okay
            return False

    # Set up our notification types
    SCHEMA_MAP['good'] = GoodNotification
    SCHEMA_MAP['bad'] = BadNotification

    runner = CliRunner()
    result = runner.invoke(cli.main)
    # no servers specified; we return 1 (non-zero)
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-v'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-vv'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, ['-vvv'])
    assert result.exit_code == 1

    result = runner.invoke(cli.main, [
        '-t', 'test title',
        '-b', 'test body',
        'good://localhost',
    ])
    assert result.exit_code == 0

    result = runner.invoke(cli.main, [
        '-t', 'test title',
        'good://localhost',
    ], input='test stdin body\n')
    assert result.exit_code == 0

    result = runner.invoke(cli.main, [
        '-t', 'test title',
        '-b', 'test body',
        'bad://localhost',
    ])
    assert result.exit_code == 1
","@@ -72,11 +72,9 @@ def test_apprise_cli():
     assert result.exit_code == 0
 
     result = runner.invoke(cli.main, [
-            '-t', 'test title',
-            'good://localhost',
-        ],
-        input='test stdin body\n',
-    )
+        '-t', 'test title',
+        'good://localhost',
+    ], input='test stdin body\n')
     assert result.exit_code == 0
 
     result = runner.invoke(cli.main, [
",fix test_apprise_cli,0.07,0,-2
dbab994f3707c2ce4ceb9bb57781ad33be35d6c3,pep8 fixes,test_email_plugin.py,"# -*- coding: utf-8 -*-
#
# NotifyEmail - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
import smtplib
import mock
import re


TEST_URLS = (
    ##################################
    # NotifyEmail
    ##################################
    ('mailto://', {
        'instance': None,
    }),
    ('mailtos://', {
        'instance': None,
    }),
    ('mailto://:@/', {
        'instance': None
    }),
    # No Username
    ('mailtos://:pass@nuxref.com:567', {
        # Can't prepare a To address using this expression
        'exception': TypeError,
    }),

    # Pre-Configured Email Services
    ('mailto://user:pass@gmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@hotmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@live.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@prontomail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.ca', {
        'instance': plugins.NotifyEmail,
    }),

    # Custom Emails
    ('mailtos://user:pass@nuxref.com:567', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@nuxref.com:567?format=html', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailtos://user:pass@nuxref.com:567?to=l2g@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailtos://user:pass@example.com?smtp=smtp.example.com&timeout=5'
        '&name=l2g&from=noreply@example.com', {
            'instance': plugins.NotifyEmail,
        },
    ),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome', {
            'instance': plugins.NotifyEmail,
        },
    ),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome&format=text', {
            'instance': plugins.NotifyEmail,
        },
    ),
    # No Password
    ('mailtos://user:@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    # Invalid From Address
    ('mailtos://user:pass@nuxref.com?from=@', {
        'exception': TypeError,
    }),
    # Invalid From Address
    ('mailtos://nuxref.com?user=&pass=.', {
        'exception': TypeError,
    }),
    # Invalid To Address
    ('mailtos://user:pass@nuxref.com?to=@', {
        'exception': TypeError,
    }),
    # Valid URL, but can't structure a proper email
    ('mailtos://nuxref.com?user=%20!&pass=.', {
        'exception': TypeError,
    }),
    # Invalid From (and To) Address
    ('mailtos://nuxref.com?to=test', {
        'exception': TypeError,
    }),
    # Can make a To address using what we have (l2g@nuxref.com)
    ('mailtos://nuxref.com?user=l2g&pass=.', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@localhost:2525', {
        'instance': plugins.NotifyEmail,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_smtplib_exceptions': True,
    }),
)


@mock.patch('smtplib.SMTP')
def test_email_plugin(mock_smtp):
    """"""
    API: NotifyEmail Plugin()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        test_smtplib_exceptions = meta.get(
            'test_smtplib_exceptions', False)

        # Our mock of our socket action
        mock_socket = mock.Mock()
        mock_socket.starttls.return_value = True
        mock_socket.login.return_value = True

        # Create a mock SMTP Object
        mock_smtp.return_value = mock_socket

        if test_smtplib_exceptions:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_smtplib_exceptions = (
                smtplib.SMTPHeloError(
                    0, 'smtplib.SMTPHeloError() not handled'),
                smtplib.SMTPException(
                    0, 'smtplib.SMTPException() not handled'),
                RuntimeError(
                    0, 'smtplib.HTTPError() not handled'),
                smtplib.SMTPRecipientsRefused(
                    'smtplib.SMTPRecipientsRefused() not handled'),
                smtplib.SMTPSenderRefused(
                    0, 'smtplib.SMTPSenderRefused() not handled',
                    'addr@example.com'),
                smtplib.SMTPDataError(
                    0, 'smtplib.SMTPDataError() not handled'),
                smtplib.SMTPServerDisconnected(
                    'smtplib.SMTPServerDisconnected() not handled'),
            )

        try:
            obj = Apprise.instantiate(url, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_smtplib_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=NotifyType.INFO) == response

                else:
                    for exception in test_smtplib_exceptions:
                        mock_socket.sendmail.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))


@mock.patch('smtplib.SMTP')
def test_webbase_lookup(mock_smtp):
    """"""
    API: Web Based Lookup Tests

    """"""

    from apprise.plugins import NotifyEmailBase

    # Insert a test email at the head of our table
    NotifyEmailBase.WEBBASE_LOOKUP_TABLE = (
        (
            # Testing URL
            'Testing Lookup',
            re.compile(r'^(?P<id>[^@]+)@(?P<domain>l2g\.com)$', re.I),
            {
                'port': 123,
                'smtp_host': 'smtp.l2g.com',
                'secure': True,
                'login_type': (NotifyEmailBase.WebBaseLogin.USERID, )
            },
        ),
    ) + NotifyEmailBase.WEBBASE_LOOKUP_TABLE

    obj = Apprise.instantiate(
        'mailto://user:pass@l2g.com', suppress_exceptions=True)

    assert(isinstance(obj, plugins.NotifyEmail))
    assert obj.to_addr == 'user@l2g.com'
    assert obj.from_addr == 'user@l2g.com'
    assert obj.password == 'pass'
    assert obj.user == 'user'
    assert obj.secure is True
    assert obj.port == 123
    assert obj.smtp_host == 'smtp.l2g.com'

@mock.patch('smtplib.SMTP')
def test_smtplib_init_fail(mock_smtplib):
    """"""
    API: Test exception handling when calling smtplib.SMTP()

    """"""

    from apprise.plugins import NotifyEmailBase

    obj = Apprise.instantiate(
        'mailto://user:pass@gmail.com', suppress_exceptions=False)
    assert(isinstance(obj, plugins.NotifyEmail))

    # Support Exception handling of smtplib.SMTP
    mock_smtplib.side_effect = TypeError('Test')

    try:
        obj.notify(
            title='test', body='body',
            notify_type=NotifyType.INFO)

        # We should have thrown an exception
        assert False

    except TypeError:
        # Exception thrown as expected
        assert True

    except Exception:
        # Un-Expected
        assert False


@mock.patch('smtplib.SMTP')
def test_smtplib_send_okay(mock_smtplib):
    """"""
    API: Test a successfully sent email

    """"""

    from apprise.plugins import NotifyEmailBase

    obj = Apprise.instantiate(
        'mailto://user:pass@gmail.com', suppress_exceptions=False)
    assert(isinstance(obj, plugins.NotifyEmail))

    # Support an email simulation where we can correctly quit
    mock_smtplib.starttls.return_value = True
    mock_smtplib.login.return_value = True
    mock_smtplib.sendmail.return_value = True
    mock_smtplib.quit.return_value = True

    obj.notify(title='test', body='body', notify_type=NotifyType.INFO)
","# -*- coding: utf-8 -*-
#
# NotifyEmail - Unit Tests
#
# Copyright (C) 2017 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

from apprise import plugins
from apprise import NotifyType
from apprise import Apprise
import smtplib
import mock
import re


TEST_URLS = (
    ##################################
    # NotifyEmail
    ##################################
    ('mailto://', {
        'instance': None,
    }),
    ('mailtos://', {
        'instance': None,
    }),
    ('mailto://:@/', {
        'instance': None
    }),
    # No Username
    ('mailtos://:pass@nuxref.com:567', {
        # Can't prepare a To address using this expression
        'exception': TypeError,
    }),

    # Pre-Configured Email Services
    ('mailto://user:pass@gmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@hotmail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@live.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@prontomail.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.com', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@yahoo.ca', {
        'instance': plugins.NotifyEmail,
    }),

    # Custom Emails
    ('mailtos://user:pass@nuxref.com:567', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@nuxref.com:567?format=html', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailtos://user:pass@nuxref.com:567?to=l2g@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailtos://user:pass@example.com?smtp=smtp.example.com&timeout=5'
        '&name=l2g&from=noreply@example.com', {
            'instance': plugins.NotifyEmail,
        },
    ),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@example.com?timeout=invalid.entry', {
        'instance': plugins.NotifyEmail,
    }),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome', {
            'instance': plugins.NotifyEmail,
        },
    ),
    (
        'mailto://user:pass@example.com:2525?user=l2g@example.com'
        '&pass=l2g@apprise!is!Awesome&format=text', {
            'instance': plugins.NotifyEmail,
        },
    ),
    # No Password
    ('mailtos://user:@nuxref.com', {
        'instance': plugins.NotifyEmail,
    }),
    # Invalid From Address
    ('mailtos://user:pass@nuxref.com?from=@', {
        'exception': TypeError,
    }),
    # Invalid From Address
    ('mailtos://nuxref.com?user=&pass=.', {
        'exception': TypeError,
    }),
    # Invalid To Address
    ('mailtos://user:pass@nuxref.com?to=@', {
        'exception': TypeError,
    }),
    # Valid URL, but can't structure a proper email
    ('mailtos://nuxref.com?user=%20!&pass=.', {
        'exception': TypeError,
    }),
    # Invalid From (and To) Address
    ('mailtos://nuxref.com?to=test', {
        'exception': TypeError,
    }),
    # Can make a To address using what we have (l2g@nuxref.com)
    ('mailtos://nuxref.com?user=l2g&pass=.', {
        'instance': plugins.NotifyEmail,
    }),
    ('mailto://user:pass@localhost:2525', {
        'instance': plugins.NotifyEmail,
        # Throws a series of connection and transfer exceptions when this flag
        # is set and tests that we gracfully handle them
        'test_smtplib_exceptions': True,
    }),
)


@mock.patch('smtplib.SMTP')
def test_email_plugin(mock_smtp):
    """"""
    API: NotifyEmail Plugin()

    """"""

    # iterate over our dictionary and test it out
    for (url, meta) in TEST_URLS:

        # Our expected instance
        instance = meta.get('instance', None)

        # Our expected exception
        exception = meta.get('exception', None)

        # Our expected server objects
        self = meta.get('self', None)

        # Our expected Query response (True, False, or exception type)
        response = meta.get('response', True)

        test_smtplib_exceptions = meta.get(
            'test_smtplib_exceptions', False)

        # Our mock of our socket action
        mock_socket = mock.Mock()
        mock_socket.starttls.return_value = True
        mock_socket.login.return_value = True

        # Create a mock SMTP Object
        mock_smtp.return_value = mock_socket

        if test_smtplib_exceptions:
            # Handle exception testing; first we turn the boolean flag ito
            # a list of exceptions
            test_smtplib_exceptions = (
                smtplib.SMTPHeloError(
                    0, 'smtplib.SMTPHeloError() not handled'),
                smtplib.SMTPException(
                    0, 'smtplib.SMTPException() not handled'),
                RuntimeError(
                    0, 'smtplib.HTTPError() not handled'),
                smtplib.SMTPRecipientsRefused(
                    'smtplib.SMTPRecipientsRefused() not handled'),
                smtplib.SMTPSenderRefused(
                    0, 'smtplib.SMTPSenderRefused() not handled',
                    'addr@example.com'),
                smtplib.SMTPDataError(
                    0, 'smtplib.SMTPDataError() not handled'),
                smtplib.SMTPServerDisconnected(
                    'smtplib.SMTPServerDisconnected() not handled'),
            )

        try:
            obj = Apprise.instantiate(url, suppress_exceptions=False)

            assert(exception is None)

            if obj is None:
                # We're done
                continue

            if instance is None:
                # Expected None but didn't get it
                print('%s instantiated %s' % (url, str(obj)))
                assert(False)

            assert(isinstance(obj, instance))

            if self:
                # Iterate over our expected entries inside of our object
                for key, val in self.items():
                    # Test that our object has the desired key
                    assert(hasattr(key, obj))
                    assert(getattr(key, obj) == val)

            try:
                if test_smtplib_exceptions is False:
                    # check that we're as expected
                    assert obj.notify(
                        title='test', body='body',
                        notify_type=NotifyType.INFO) == response

                else:
                    for exception in test_smtplib_exceptions:
                        mock_socket.sendmail.side_effect = exception
                        try:
                            assert obj.notify(
                                title='test', body='body',
                                notify_type=NotifyType.INFO) is False

                        except AssertionError:
                            # Don't mess with these entries
                            raise

                        except Exception as e:
                            # We can't handle this exception type
                            print('%s / %s' % (url, str(e)))
                            assert False

            except AssertionError:
                # Don't mess with these entries
                raise

            except Exception as e:
                # Check that we were expecting this exception to happen
                assert isinstance(e, response)

        except AssertionError:
            # Don't mess with these entries
            print('%s AssertionError' % url)
            raise

        except Exception as e:
            # Handle our exception
            print('%s / %s' % (url, str(e)))
            assert(exception is not None)
            assert(isinstance(e, exception))


@mock.patch('smtplib.SMTP')
def test_webbase_lookup(mock_smtp):
    """"""
    API: Web Based Lookup Tests

    """"""

    from apprise.plugins import NotifyEmailBase

    # Insert a test email at the head of our table
    NotifyEmailBase.WEBBASE_LOOKUP_TABLE = (
        (
            # Testing URL
            'Testing Lookup',
            re.compile(r'^(?P<id>[^@]+)@(?P<domain>l2g\.com)$', re.I),
            {
                'port': 123,
                'smtp_host': 'smtp.l2g.com',
                'secure': True,
                'login_type': (NotifyEmailBase.WebBaseLogin.USERID, )
            },
        ),
    ) + NotifyEmailBase.WEBBASE_LOOKUP_TABLE

    obj = Apprise.instantiate(
        'mailto://user:pass@l2g.com', suppress_exceptions=True)

    assert(isinstance(obj, plugins.NotifyEmail))
    assert obj.to_addr == 'user@l2g.com'
    assert obj.from_addr == 'user@l2g.com'
    assert obj.password == 'pass'
    assert obj.user == 'user'
    assert obj.secure is True
    assert obj.port == 123
    assert obj.smtp_host == 'smtp.l2g.com'


@mock.patch('smtplib.SMTP')
def test_smtplib_init_fail(mock_smtplib):
    """"""
    API: Test exception handling when calling smtplib.SMTP()

    """"""

    from apprise.plugins import NotifyEmailBase

    obj = Apprise.instantiate(
        'mailto://user:pass@gmail.com', suppress_exceptions=False)
    assert(isinstance(obj, plugins.NotifyEmail))

    # Support Exception handling of smtplib.SMTP
    mock_smtplib.side_effect = TypeError('Test')

    try:
        obj.notify(
            title='test', body='body',
            notify_type=NotifyType.INFO)

        # We should have thrown an exception
        assert False

    except TypeError:
        # Exception thrown as expected
        assert True

    except Exception:
        # Un-Expected
        assert False

    # A handled and expected exception
    mock_smtplib.side_effect = smtplib.SMTPException('Test')
    assert obj.notify(title='test', body='body',
                      notify_type=NotifyType.INFO) is False


@mock.patch('smtplib.SMTP')
def test_smtplib_send_okay(mock_smtplib):
    """"""
    API: Test a successfully sent email

    """"""

    from apprise.plugins import NotifyEmailBase

    obj = Apprise.instantiate(
        'mailto://user:pass@gmail.com', suppress_exceptions=False)
    assert(isinstance(obj, plugins.NotifyEmail))

    # Support an email simulation where we can correctly quit
    mock_smtplib.starttls.return_value = True
    mock_smtplib.login.return_value = True
    mock_smtplib.sendmail.return_value = True
    mock_smtplib.quit.return_value = True

    obj.notify(title='test', body='body', notify_type=NotifyType.INFO)
","@@ -291,6 +291,7 @@ def test_webbase_lookup(mock_smtp):
     assert obj.port == 123
     assert obj.smtp_host == 'smtp.l2g.com'
 
+
 @mock.patch('smtplib.SMTP')
 def test_smtplib_init_fail(mock_smtplib):
     """"""
@@ -323,6 +324,11 @@ def test_smtplib_init_fail(mock_smtplib):
         # Un-Expected
         assert False
 
+    # A handled and expected exception
+    mock_smtplib.side_effect = smtplib.SMTPException('Test')
+    assert obj.notify(title='test', body='body',
+                      notify_type=NotifyType.INFO) is False
+
 
 @mock.patch('smtplib.SMTP')
 def test_smtplib_send_okay(mock_smtplib):
",add a test for smtplib.side_effect,-0.5,1,6
f8370c8624632e1cf9f33b94e0fe83751fa9bb8c,pep8 fixes,NotifyRocketChat.py,"# -*- coding: utf-8 -*-
#
# Notify Rocket.Chat Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import loads

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..utils import compat_is_basestring

IS_CHANNEL = re.compile(r'^#(?P<name>[A-Za-z0-9]+)$')
IS_ROOM_ID = re.compile(r'^(?P<name>[A-Za-z0-9]+)$')

# Extend HTTP Error Messages
RC_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
RC_HTTP_ERROR_MAP.update({
    400: 'Channel/RoomId is wrong format, or missing from server.',
    401: 'Authentication tokens provided is invalid or missing.',
})

# Used to break apart list of potential tags by their delimiter
# into a usable list.
LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyRocketChat(NotifyBase):
    """"""
    A wrapper for Notify Rocket.Chat Notifications
    """"""

    # The default descriptive name associated with the Notification
    service_name = 'Rocket.Chat'

    # The services URL
    service_url = 'https://rocket.chat/'

    # The default protocol
    protocol = 'rocket'

    # The default secure protocol
    secure_protocol = 'rockets'

    # A URL that takes you to the setup/help of the specific protocol
    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_rocketchat'

    # Defines the maximum allowable characters in the title
    title_maxlen = 200

    def __init__(self, recipients=None, **kwargs):
        """"""
        Initialize Notify Rocket.Chat Object
        """"""
        super(NotifyRocketChat, self).__init__(**kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Prepare our URL
        self.api_url = '%s://%s' % (self.schema, self.host)

        if isinstance(self.port, int):
            self.api_url += ':%d' % self.port

        self.api_url += '/api/v1/'

        # Initialize channels list
        self.channels = list()

        # Initialize room list
        self.rooms = list()

        if recipients is None:
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = [x for x in filter(bool, LIST_DELIM.split(
                recipients,
            ))]

        elif not isinstance(recipients, (set, tuple, list)):
            recipients = []

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            result = IS_CHANNEL.match(recipient)
            if result:
                # store valid device
                self.channels.append(result.group('name'))
                continue

            result = IS_ROOM_ID.match(recipient)
            if result:
                # store valid room
                self.rooms.append(result.group('name'))
                continue

            self.logger.warning(
                'Dropped invalid channel/room ' +
                '(%s) specified.' % recipient,
            )

        if len(self.rooms) == 0 and len(self.channels) == 0:
            raise TypeError(
                'No Rocket.Chat room and/or channels specified to notify.'
            )

        # Used to track token headers upon authentication (if successful)
        self.headers = {}

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        wrapper to send_notification since we can alert more then one channel
        """"""

        # Track whether we authenticated okay

        if not self.login():
            return False

        # Prepare our message
        text = '*%s*\r\n%s' % (title.replace('*', '\\*'), body)

        # Initiaize our error tracking
        has_error = False

        # Create a copy of our rooms and channels to notify against
        channels = list(self.channels)
        rooms = list(self.rooms)

        while len(channels) > 0:
            # Get Channel
            channel = channels.pop(0)

            if not self.send_notification(
                    {
                        'text': text,
                        'channel': channel,
                    }, notify_type=notify_type, **kwargs):

                # toggle flag
                has_error = True

            if len(channels) + len(rooms) > 0:
                # Prevent thrashing requests
                self.throttle()

        # Send all our defined room id's
        while len(rooms):
            # Get Room
            room = rooms.pop(0)

            if not self.send_notification(
                    {
                        'text': text,
                        'roomId': room,
                    }, notify_type=notify_type, **kwargs):

                # toggle flag
                has_error = True

            if len(rooms) > 0:
                # Prevent thrashing requests
                self.throttle()

        # logout
        self.logout()

        return not has_error

    def send_notification(self, payload, notify_type, **kwargs):
        """"""
        Perform Notify Rocket.Chat Notification
        """"""

        self.logger.debug('Rocket.Chat POST URL: %s (cert_verify=%r)' % (
            self.api_url + 'chat.postMessage', self.verify_certificate,
        ))
        self.logger.debug('Rocket.Chat Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.api_url + 'chat.postMessage',
                data=payload,
                headers=self.headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Rocket.Chat notification: ' +
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send Rocket.Chat notification ' +
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug('Rocket.Chat Server Response: %s.' % r.text)
                self.logger.info('Sent Rocket.Chat notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending Rocket.Chat ' +
                'notification.')
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    def login(self):
        """"""
        login to our server

        """"""
        payload = {
            'username': self.user,
            'password': self.password,
        }

        try:
            r = requests.post(
                self.api_url + 'login',
                data=payload,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to authenticate with Rocket.Chat server: ' +
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to authenticate with Rocket.Chat server ' +
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug('Rocket.Chat authentication successful')
                response = loads(r.text)
                if response.get('status') != ""success"":
                    self.logger.warning(
                        'Could not authenticate with Rocket.Chat server.')
                    return False

                # Set our headers for further communication
                self.headers['X-Auth-Token'] = response.get(
                    'data', {'authToken': None}).get('authToken')
                self.headers['X-User-Id'] = response.get(
                    'data', {'userId': None}).get('userId')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured authenticating to the ' +
                'Rocket.Chat server.')
            self.logger.debug('Socket Exception: %s' % str(e))
            return False

        return True

    def logout(self):
        """"""
        logout of our server
        """"""
        try:
            r = requests.post(
                self.api_url + 'logout',
                headers=self.headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to log off Rocket.Chat server: ' +
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to log off Rocket.Chat server ' +
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug(
                    'Rocket.Chat log off successful; response %s.' % (
                        r.text))

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured logging off the ' +
                'Rocket.Chat server')
            self.logger.debug('Socket Exception: %s' % str(e))
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        results['recipients'] = NotifyBase.unquote(results['fullpath'])

        return results
","# -*- coding: utf-8 -*-
#
# Notify Rocket.Chat Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re
import requests
from json import loads

from .NotifyBase import NotifyBase
from .NotifyBase import HTTP_ERROR_MAP
from ..utils import compat_is_basestring

IS_CHANNEL = re.compile(r'^#(?P<name>[A-Za-z0-9]+)$')
IS_ROOM_ID = re.compile(r'^(?P<name>[A-Za-z0-9]+)$')

# Extend HTTP Error Messages
RC_HTTP_ERROR_MAP = HTTP_ERROR_MAP.copy()
RC_HTTP_ERROR_MAP.update({
    400: 'Channel/RoomId is wrong format, or missing from server.',
    401: 'Authentication tokens provided is invalid or missing.',
})

# Used to break apart list of potential tags by their delimiter
# into a usable list.
LIST_DELIM = re.compile(r'[ \t\r\n,\\/]+')


class NotifyRocketChat(NotifyBase):
    """"""
    A wrapper for Notify Rocket.Chat Notifications
    """"""

    # The default descriptive name associated with the Notification
    service_name = 'Rocket.Chat'

    # The services URL
    service_url = 'https://rocket.chat/'

    # The default protocol
    protocol = 'rocket'

    # The default secure protocol
    secure_protocol = 'rockets'

    # A URL that takes you to the setup/help of the specific protocol
    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_rocketchat'

    # Defines the maximum allowable characters in the title
    title_maxlen = 200

    def __init__(self, recipients=None, **kwargs):
        """"""
        Initialize Notify Rocket.Chat Object
        """"""
        super(NotifyRocketChat, self).__init__(**kwargs)

        if self.secure:
            self.schema = 'https'

        else:
            self.schema = 'http'

        # Prepare our URL
        self.api_url = '%s://%s' % (self.schema, self.host)

        if isinstance(self.port, int):
            self.api_url += ':%d' % self.port

        self.api_url += '/api/v1/'

        # Initialize channels list
        self.channels = list()

        # Initialize room list
        self.rooms = list()

        if recipients is None:
            recipients = []

        elif compat_is_basestring(recipients):
            recipients = [x for x in filter(bool, LIST_DELIM.split(
                recipients,
            ))]

        elif not isinstance(recipients, (set, tuple, list)):
            recipients = []

        # Validate recipients and drop bad ones:
        for recipient in recipients:
            result = IS_CHANNEL.match(recipient)
            if result:
                # store valid device
                self.channels.append(result.group('name'))
                continue

            result = IS_ROOM_ID.match(recipient)
            if result:
                # store valid room
                self.rooms.append(result.group('name'))
                continue

            self.logger.warning(
                'Dropped invalid channel/room '
                '(%s) specified.' % recipient,
            )

        if len(self.rooms) == 0 and len(self.channels) == 0:
            raise TypeError(
                'No Rocket.Chat room and/or channels specified to notify.'
            )

        # Used to track token headers upon authentication (if successful)
        self.headers = {}

    def notify(self, title, body, notify_type, **kwargs):
        """"""
        wrapper to send_notification since we can alert more then one channel
        """"""

        # Track whether we authenticated okay

        if not self.login():
            return False

        # Prepare our message
        text = '*%s*\r\n%s' % (title.replace('*', '\\*'), body)

        # Initiaize our error tracking
        has_error = False

        # Create a copy of our rooms and channels to notify against
        channels = list(self.channels)
        rooms = list(self.rooms)

        while len(channels) > 0:
            # Get Channel
            channel = channels.pop(0)

            if not self.send_notification(
                    {
                        'text': text,
                        'channel': channel,
                    }, notify_type=notify_type, **kwargs):

                # toggle flag
                has_error = True

            if len(channels) + len(rooms) > 0:
                # Prevent thrashing requests
                self.throttle()

        # Send all our defined room id's
        while len(rooms):
            # Get Room
            room = rooms.pop(0)

            if not self.send_notification(
                    {
                        'text': text,
                        'roomId': room,
                    }, notify_type=notify_type, **kwargs):

                # toggle flag
                has_error = True

            if len(rooms) > 0:
                # Prevent thrashing requests
                self.throttle()

        # logout
        self.logout()

        return not has_error

    def send_notification(self, payload, notify_type, **kwargs):
        """"""
        Perform Notify Rocket.Chat Notification
        """"""

        self.logger.debug('Rocket.Chat POST URL: %s (cert_verify=%r)' % (
            self.api_url + 'chat.postMessage', self.verify_certificate,
        ))
        self.logger.debug('Rocket.Chat Payload: %s' % str(payload))
        try:
            r = requests.post(
                self.api_url + 'chat.postMessage',
                data=payload,
                headers=self.headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to send Rocket.Chat notification: '
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to send Rocket.Chat notification '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug('Rocket.Chat Server Response: %s.' % r.text)
                self.logger.info('Sent Rocket.Chat notification.')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured sending Rocket.Chat '
                'notification.')
            self.logger.debug('Socket Exception: %s' % str(e))

            # Return; we're done
            return False

        return True

    def login(self):
        """"""
        login to our server

        """"""
        payload = {
            'username': self.user,
            'password': self.password,
        }

        try:
            r = requests.post(
                self.api_url + 'login',
                data=payload,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to authenticate with Rocket.Chat server: '
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to authenticate with Rocket.Chat server '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug('Rocket.Chat authentication successful')
                response = loads(r.text)
                if response.get('status') != ""success"":
                    self.logger.warning(
                        'Could not authenticate with Rocket.Chat server.')
                    return False

                # Set our headers for further communication
                self.headers['X-Auth-Token'] = response.get(
                    'data', {'authToken': None}).get('authToken')
                self.headers['X-User-Id'] = response.get(
                    'data', {'userId': None}).get('userId')

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured authenticating to the '
                'Rocket.Chat server.')
            self.logger.debug('Socket Exception: %s' % str(e))
            return False

        return True

    def logout(self):
        """"""
        logout of our server
        """"""
        try:
            r = requests.post(
                self.api_url + 'logout',
                headers=self.headers,
                verify=self.verify_certificate,
            )
            if r.status_code != requests.codes.ok:
                # We had a problem
                try:
                    self.logger.warning(
                        'Failed to log off Rocket.Chat server: '
                        '%s (error=%s).' % (
                            RC_HTTP_ERROR_MAP[r.status_code],
                            r.status_code))

                except KeyError:
                    self.logger.warning(
                        'Failed to log off Rocket.Chat server '
                        '(error=%s).' % (
                            r.status_code))

                # Return; we're done
                return False

            else:
                self.logger.debug(
                    'Rocket.Chat log off successful; response %s.' % (
                        r.text))

        except requests.RequestException as e:
            self.logger.warning(
                'A Connection error occured logging off the '
                'Rocket.Chat server')
            self.logger.debug('Socket Exception: %s' % str(e))
            return False

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now
        results['recipients'] = NotifyBase.unquote(results['fullpath'])

        return results
","@@ -114,7 +114,7 @@ class NotifyRocketChat(NotifyBase):
                 continue
 
             self.logger.warning(
-                'Dropped invalid channel/room ' +
+                'Dropped invalid channel/room '
                 '(%s) specified.' % recipient,
             )
 
@@ -206,14 +206,14 @@ class NotifyRocketChat(NotifyBase):
                 # We had a problem
                 try:
                     self.logger.warning(
-                        'Failed to send Rocket.Chat notification: ' +
+                        'Failed to send Rocket.Chat notification: '
                         '%s (error=%s).' % (
                             RC_HTTP_ERROR_MAP[r.status_code],
                             r.status_code))
 
                 except KeyError:
                     self.logger.warning(
-                        'Failed to send Rocket.Chat notification ' +
+                        'Failed to send Rocket.Chat notification '
                         '(error=%s).' % (
                             r.status_code))
 
@@ -226,7 +226,7 @@ class NotifyRocketChat(NotifyBase):
 
         except requests.RequestException as e:
             self.logger.warning(
-                'A Connection error occured sending Rocket.Chat ' +
+                'A Connection error occured sending Rocket.Chat '
                 'notification.')
             self.logger.debug('Socket Exception: %s' % str(e))
 
@@ -255,14 +255,14 @@ class NotifyRocketChat(NotifyBase):
                 # We had a problem
                 try:
                     self.logger.warning(
-                        'Failed to authenticate with Rocket.Chat server: ' +
+                        'Failed to authenticate with Rocket.Chat server: '
                         '%s (error=%s).' % (
                             RC_HTTP_ERROR_MAP[r.status_code],
                             r.status_code))
 
                 except KeyError:
                     self.logger.warning(
-                        'Failed to authenticate with Rocket.Chat server ' +
+                        'Failed to authenticate with Rocket.Chat server '
                         '(error=%s).' % (
                             r.status_code))
 
@@ -285,7 +285,7 @@ class NotifyRocketChat(NotifyBase):
 
         except requests.RequestException as e:
             self.logger.warning(
-                'A Connection error occured authenticating to the ' +
+                'A Connection error occured authenticating to the '
                 'Rocket.Chat server.')
             self.logger.debug('Socket Exception: %s' % str(e))
             return False
@@ -306,14 +306,14 @@ class NotifyRocketChat(NotifyBase):
                 # We had a problem
                 try:
                     self.logger.warning(
-                        'Failed to log off Rocket.Chat server: ' +
+                        'Failed to log off Rocket.Chat server: '
                         '%s (error=%s).' % (
                             RC_HTTP_ERROR_MAP[r.status_code],
                             r.status_code))
 
                 except KeyError:
                     self.logger.warning(
-                        'Failed to log off Rocket.Chat server ' +
+                        'Failed to log off Rocket.Chat server '
                         '(error=%s).' % (
                             r.status_code))
 
@@ -327,7 +327,7 @@ class NotifyRocketChat(NotifyBase):
 
         except requests.RequestException as e:
             self.logger.warning(
-                'A Connection error occured logging off the ' +
+                'A Connection error occured logging off the '
                 'Rocket.Chat server')
             self.logger.debug('Socket Exception: %s' % str(e))
             return False
",add more info about the rocket.chat server,0.86,0,0
e54e909b29509b8506e8f36a49e81bf520f72484,gntp reference fixed (for Prowl Notifications); refs #37,config.py,"# Copyright: 2013 Paul Traylor
# These sources are released under the terms of the MIT license: see LICENSE

""""""
The gntp.config module is provided as an extended GrowlNotifier object that takes
advantage of the ConfigParser module to allow us to setup some default values
(such as hostname, password, and port) in a more global way to be shared among
programs using gntp
""""""
import logging
import os

from .gntp import notifier
from .gntp import shim

__all__ = [
	'mini',
	'GrowlNotifier'
]

logger = logging.getLogger(__name__)


class GrowlNotifier(gntp.notifier.GrowlNotifier):
	""""""
	ConfigParser enhanced GrowlNotifier object

	For right now, we are only interested in letting users overide certain
	values from ~/.gntp

	::

		[gntp]
		hostname = ?
		password = ?
		port = ?
	""""""
	def __init__(self, *args, **kwargs):
		config = gntp.shim.RawConfigParser({
			'hostname': kwargs.get('hostname', 'localhost'),
			'password': kwargs.get('password'),
			'port': kwargs.get('port', 23053),
		})

		config.read([os.path.expanduser('~/.gntp')])

		# If the file does not exist, then there will be no gntp section defined
		# and the config.get() lines below will get confused. Since we are not
		# saving the config, it should be safe to just add it here so the
		# code below doesn't complain
		if not config.has_section('gntp'):
			logger.info('Error reading ~/.gntp config file')
			config.add_section('gntp')

		kwargs['password'] = config.get('gntp', 'password')
		kwargs['hostname'] = config.get('gntp', 'hostname')
		kwargs['port'] = config.getint('gntp', 'port')

		super(GrowlNotifier, self).__init__(*args, **kwargs)


def mini(description, **kwargs):
	""""""Single notification function

	Simple notification function in one line. Has only one required parameter
	and attempts to use reasonable defaults for everything else
	:param string description: Notification message
	""""""
	kwargs['notifierFactory'] = GrowlNotifier
	gntp.notifier.mini(description, **kwargs)


if __name__ == '__main__':
	# If we're running this module directly we're likely running it as a test
	# so extra debugging is useful
	logging.basicConfig(level=logging.INFO)
	mini('Testing mini notification')
","# Copyright: 2013 Paul Traylor
# These sources are released under the terms of the MIT license: see LICENSE

""""""
The gntp.config module is provided as an extended GrowlNotifier object that takes
advantage of the ConfigParser module to allow us to setup some default values
(such as hostname, password, and port) in a more global way to be shared among
programs using gntp
""""""
import logging
import os

from .gntp import notifier
from .gntp import shim

__all__ = [
	'mini',
	'GrowlNotifier'
]

logger = logging.getLogger(__name__)


class GrowlNotifier(notifier.GrowlNotifier):
	""""""
	ConfigParser enhanced GrowlNotifier object

	For right now, we are only interested in letting users overide certain
	values from ~/.gntp

	::

		[gntp]
		hostname = ?
		password = ?
		port = ?
	""""""
	def __init__(self, *args, **kwargs):
		config = shim.RawConfigParser({
			'hostname': kwargs.get('hostname', 'localhost'),
			'password': kwargs.get('password'),
			'port': kwargs.get('port', 23053),
		})

		config.read([os.path.expanduser('~/.gntp')])

		# If the file does not exist, then there will be no gntp section defined
		# and the config.get() lines below will get confused. Since we are not
		# saving the config, it should be safe to just add it here so the
		# code below doesn't complain
		if not config.has_section('gntp'):
			logger.info('Error reading ~/.gntp config file')
			config.add_section('gntp')

		kwargs['password'] = config.get('gntp', 'password')
		kwargs['hostname'] = config.get('gntp', 'hostname')
		kwargs['port'] = config.getint('gntp', 'port')

		super(GrowlNotifier, self).__init__(*args, **kwargs)


def mini(description, **kwargs):
	""""""Single notification function

	Simple notification function in one line. Has only one required parameter
	and attempts to use reasonable defaults for everything else
	:param string description: Notification message
	""""""
	kwargs['notifierFactory'] = GrowlNotifier
	notifier.mini(description, **kwargs)


if __name__ == '__main__':
	# If we're running this module directly we're likely running it as a test
	# so extra debugging is useful
	logging.basicConfig(level=logging.INFO)
	mini('Testing mini notification')
","@@ -21,7 +21,7 @@ __all__ = [
 logger = logging.getLogger(__name__)
 
 
-class GrowlNotifier(gntp.notifier.GrowlNotifier):
+class GrowlNotifier(notifier.GrowlNotifier):
 	""""""
 	ConfigParser enhanced GrowlNotifier object
 
@@ -36,7 +36,7 @@ class GrowlNotifier(gntp.notifier.GrowlNotifier):
 		port = ?
 	""""""
 	def __init__(self, *args, **kwargs):
-		config = gntp.shim.RawConfigParser({
+		config = shim.RawConfigParser({
 			'hostname': kwargs.get('hostname', 'localhost'),
 			'password': kwargs.get('password'),
 			'port': kwargs.get('port', 23053),
@@ -67,7 +67,7 @@ def mini(description, **kwargs):
 	:param string description: Notification message
 	""""""
 	kwargs['notifierFactory'] = GrowlNotifier
-	gntp.notifier.mini(description, **kwargs)
+	notifier.mini(description, **kwargs)
 
 
 if __name__ == '__main__':
",add missing docstring,0.0,0,0
c56b1203ffee0313d664cef3e31a9033fcef399a,"Use 'plain' instead of 'text' for mime subtype.

Also remove manually set headers as they're not required.

Fixes #41.",NotifyEmail.py,"# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# Secure Email Modes
class SecureMailMode(object):
    SSL = ""ssl""
    STARTTLS = ""starttls""


# Define all of the secure modes (used during validation)
SECURE_MODES = (
    SecureMailMode.SSL,
    SecureMailMode.STARTTLS,
)

# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Fast Mail (Series 1)
    (
        'Fast Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>fastmail\.(com|cn|co\.uk|com\.au|de|es|fm|fr|im|'
            r'in|jp|mx|net|nl|org|se|to|tw|uk|us))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.fastmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Fast Mail (Series 2)
    (
        'Fast Mail Extended Addresses',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>123mail\.org|airpost\.net|eml\.cc|fmail\.co\.uk|'
            r'fmgirl\.com|fmguy\.com|mailbolt\.com|mailcan\.com|'
            r'mailhaven\.com|mailmight\.com|ml1\.net|mm\.st|myfastmail\.com|'
            r'proinbox\.com|promessage\.com|rushpost\.com|sent\.(as|at|com)|'
            r'speedymail\.org|warpmail\.net|xsmail\.com|150mail\.com|'
            r'150ml\.com|16mail\.com|2-mail\.com|4email\.net|50mail\.com|'
            r'allmail\.net|bestmail\.us|cluemail\.com|elitemail\.org|'
            r'emailcorner\.net|emailengine\.(net|org)|emailgroups\.net|'
            r'emailplus\.org|emailuser\.net|f-m\.fm|fast-email\.com|'
            r'fast-mail\.org|fastem\.com|fastemail\.us|fastemailer\.com|'
            r'fastest\.cc|fastimap\.com|fastmailbox\.net|fastmessaging\.com|'
            r'fea\.st|fmailbox\.com|ftml\.net|h-mail\.us|hailmail\.net|'
            r'imap-mail\.com|imap\.cc|imapmail\.org|inoutbox\.com|'
            r'internet-e-mail\.com|internet-mail\.org|internetemails\.net|'
            r'internetmailing\.net|jetemail\.net|justemail\.net|'
            r'letterboxes\.org|mail-central\.com|mail-page\.com|'
            r'mailandftp\.com|mailas\.com|mailc\.net|mailforce\.net|'
            r'mailftp\.com|mailingaddress\.org|mailite\.com|mailnew\.com|'
            r'mailsent\.net|mailservice\.ms|mailup\.net|mailworks\.org|'
            r'mymacmail\.com|nospammail\.net|ownmail\.net|petml\.com|'
            r'postinbox\.com|postpro\.net|realemail\.net|reallyfast\.biz|'
            r'reallyfast\.info|speedpost\.net|ssl-mail\.com|swift-mail\.com|'
            r'the-fastest\.net|the-quickest\.com|theinternetemail\.com|'
            r'veryfast\.biz|veryspeedy\.net|yepmail\.net)$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.fastmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Zoho Mail
    (
        'Zoho Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>zoho\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.zoho.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default descriptive name associated with the Notification
    service_name = 'E-Mail'

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # A URL that takes you to the setup/help of the specific protocol
    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_email'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default Secure Mode
    default_secure_mode = SecureMailMode.STARTTLS

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)
        self.to_addr = kwargs.get('to', self.from_addr)

        if not NotifyBase.is_email(self.from_addr):
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Now detect secure mode
        self.secure_mode = kwargs.get('secure_mode', self.default_secure_mode)

        if self.secure_mode not in SECURE_MODES:
            raise TypeError(
                'Invalid secure mode specified: %s.' % self.secure_mode)

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)
                self.secure_mode = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure_mode', self.secure_mode)
                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split(r'[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')
            email['Content-Type'] = 'text/html'

        else:
            email = MIMEText(body, 'text')
            email['Content-Type'] = 'text/plain'

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        # bind the socket variable to the current namespace
        socket = None
        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket_func = smtplib.SMTP
            if self.secure and self.secure_mode == SecureMailMode.SSL:
                self.logger.debug('Securing connection with SSL...')
                socket_func = smtplib.SMTP_SSL

            socket = socket_func(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure and self.secure_mode == SecureMailMode.STARTTLS:
                # Handle Secure Connections
                self.logger.debug('Securing connection with STARTTLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            if socket is not None:  # pragma: no branch
                socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML
        results['secure_mode'] = NotifyEmail.default_secure_mode

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        # Attempt to detect 'from' email address
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])

        else:
            # get 'To' email address
            from_addr = '%s@%s' % (
                re.split(
                    r'[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )
            # Lets be clever and attempt to make the from
            # address an email based on the to address
            from_addr = '%s@%s' % (
                re.split(r'[\s@]+', from_addr)[0],
                re.split(r'[\s@]+', from_addr)[-1],
            )

        # Attempt to detect 'to' email address
        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        if not to_addr:
            # Send to ourselves if not otherwise specified to do so
            to_addr = from_addr

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        if 'mode' in results['qsd'] and len(results['qsd']['mode']):
            # Extract the secure mode to over-ride the default
            results['secure_mode'] = results['qsd']['mode'].lower()

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","# -*- coding: utf-8 -*-
#
# Email Notify Wrapper
#
# Copyright (C) 2017-2018 Chris Caron <lead2gold@gmail.com>
#
# This file is part of apprise.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

import re

from datetime import datetime
import smtplib
from socket import error as SocketError

from email.mime.text import MIMEText

from .NotifyBase import NotifyBase
from ..common import NotifyFormat


class WebBaseLogin(object):
    """"""
    This class is just used in conjunction of the default emailers
    to best formulate a login to it using the data detected
    """"""
    # User Login must be Email Based
    EMAIL = 'Email'

    # User Login must UserID Based
    USERID = 'UserID'


# Secure Email Modes
class SecureMailMode(object):
    SSL = ""ssl""
    STARTTLS = ""starttls""


# Define all of the secure modes (used during validation)
SECURE_MODES = (
    SecureMailMode.SSL,
    SecureMailMode.STARTTLS,
)

# To attempt to make this script stupid proof, if we detect an email address
# that is part of the this table, we can pre-use a lot more defaults if they
# aren't otherwise specified on the users input.
WEBBASE_LOOKUP_TABLE = (
    # Google GMail
    (
        'Google Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>gmail\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.gmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Pronto Mail
    (
        'Pronto Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>prontomail\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'secure.emailsrvr.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Microsoft Hotmail
    (
        'Microsoft Hotmail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>(hotmail|live)\.com)$', re.I),
        {
            'port': 587,
            'smtp_host': 'smtp.live.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Yahoo Mail
    (
        'Yahoo Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>yahoo\.(ca|com))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.mail.yahoo.com',
            'secure': True,
            'secure_mode': SecureMailMode.STARTTLS,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Fast Mail (Series 1)
    (
        'Fast Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>fastmail\.(com|cn|co\.uk|com\.au|de|es|fm|fr|im|'
            r'in|jp|mx|net|nl|org|se|to|tw|uk|us))$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.fastmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Fast Mail (Series 2)
    (
        'Fast Mail Extended Addresses',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>123mail\.org|airpost\.net|eml\.cc|fmail\.co\.uk|'
            r'fmgirl\.com|fmguy\.com|mailbolt\.com|mailcan\.com|'
            r'mailhaven\.com|mailmight\.com|ml1\.net|mm\.st|myfastmail\.com|'
            r'proinbox\.com|promessage\.com|rushpost\.com|sent\.(as|at|com)|'
            r'speedymail\.org|warpmail\.net|xsmail\.com|150mail\.com|'
            r'150ml\.com|16mail\.com|2-mail\.com|4email\.net|50mail\.com|'
            r'allmail\.net|bestmail\.us|cluemail\.com|elitemail\.org|'
            r'emailcorner\.net|emailengine\.(net|org)|emailgroups\.net|'
            r'emailplus\.org|emailuser\.net|f-m\.fm|fast-email\.com|'
            r'fast-mail\.org|fastem\.com|fastemail\.us|fastemailer\.com|'
            r'fastest\.cc|fastimap\.com|fastmailbox\.net|fastmessaging\.com|'
            r'fea\.st|fmailbox\.com|ftml\.net|h-mail\.us|hailmail\.net|'
            r'imap-mail\.com|imap\.cc|imapmail\.org|inoutbox\.com|'
            r'internet-e-mail\.com|internet-mail\.org|internetemails\.net|'
            r'internetmailing\.net|jetemail\.net|justemail\.net|'
            r'letterboxes\.org|mail-central\.com|mail-page\.com|'
            r'mailandftp\.com|mailas\.com|mailc\.net|mailforce\.net|'
            r'mailftp\.com|mailingaddress\.org|mailite\.com|mailnew\.com|'
            r'mailsent\.net|mailservice\.ms|mailup\.net|mailworks\.org|'
            r'mymacmail\.com|nospammail\.net|ownmail\.net|petml\.com|'
            r'postinbox\.com|postpro\.net|realemail\.net|reallyfast\.biz|'
            r'reallyfast\.info|speedpost\.net|ssl-mail\.com|swift-mail\.com|'
            r'the-fastest\.net|the-quickest\.com|theinternetemail\.com|'
            r'veryfast\.biz|veryspeedy\.net|yepmail\.net)$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.fastmail.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Zoho Mail
    (
        'Zoho Mail',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>zoho\.com)$', re.I),
        {
            'port': 465,
            'smtp_host': 'smtp.zoho.com',
            'secure': True,
            'secure_mode': SecureMailMode.SSL,
            'login_type': (WebBaseLogin.EMAIL, )
        },
    ),

    # Catch All
    (
        'Custom',
        re.compile(
            r'^((?P<label>[^+]+)\+)?(?P<id>[^@]+)@'
            r'(?P<domain>.+)$', re.I),
        {
            # Setting smtp_host to None is a way of
            # auto-detecting it based on other parameters
            # specified.  There is no reason to ever modify
            # this Catch All
            'smtp_host': None,
        },
    ),
)


class NotifyEmail(NotifyBase):
    """"""
    A wrapper to Email Notifications

    """"""

    # The default descriptive name associated with the Notification
    service_name = 'E-Mail'

    # The default simple (insecure) protocol
    protocol = 'mailto'

    # The default secure protocol
    secure_protocol = 'mailtos'

    # A URL that takes you to the setup/help of the specific protocol
    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_email'

    # Default Non-Encryption Port
    default_port = 25

    # Default Secure Port
    default_secure_port = 587

    # Default Secure Mode
    default_secure_mode = SecureMailMode.STARTTLS

    # Default SMTP Timeout (in seconds)
    connect_timeout = 15

    def __init__(self, **kwargs):
        """"""
        Initialize Email Object
        """"""
        super(NotifyEmail, self).__init__(**kwargs)

        # Handle SMTP vs SMTPS (Secure vs UnSecure)
        if not self.port:
            if self.secure:
                self.port = self.default_secure_port

            else:
                self.port = self.default_port

        # Email SMTP Server Timeout
        try:
            self.timeout = int(kwargs.get('timeout', self.connect_timeout))

        except (ValueError, TypeError):
            self.timeout = self.connect_timeout

        # Now we want to construct the To and From email
        # addresses from the URL provided
        self.from_name = kwargs.get('name', None)
        self.from_addr = kwargs.get('from', None)
        self.to_addr = kwargs.get('to', self.from_addr)

        if not NotifyBase.is_email(self.from_addr):
            # Parse Source domain based on from_addr
            raise TypeError('Invalid ~From~ email format: %s' % self.from_addr)

        if not NotifyBase.is_email(self.to_addr):
            raise TypeError('Invalid ~To~ email format: %s' % self.to_addr)

        # Now detect the SMTP Server
        self.smtp_host = kwargs.get('smtp_host', '')

        # Now detect secure mode
        self.secure_mode = kwargs.get('secure_mode', self.default_secure_mode)

        if self.secure_mode not in SECURE_MODES:
            raise TypeError(
                'Invalid secure mode specified: %s.' % self.secure_mode)

        # Apply any defaults based on certain known configurations
        self.NotifyEmailDefaults()

        return

    def NotifyEmailDefaults(self):
        """"""
        A function that prefills defaults based on the email
        it was provided.
        """"""

        if self.smtp_host:
            # SMTP Server was explicitly specified, therefore it is assumed
            # the caller knows what he's doing and is intentionally
            # over-riding any smarts to be applied
            return

        for i in range(len(WEBBASE_LOOKUP_TABLE)):  # pragma: no branch
            self.logger.debug('Scanning %s against %s' % (
                self.to_addr, WEBBASE_LOOKUP_TABLE[i][0]
            ))
            match = WEBBASE_LOOKUP_TABLE[i][1].match(self.from_addr)
            if match:
                self.logger.info(
                    'Applying %s Defaults' %
                    WEBBASE_LOOKUP_TABLE[i][0],
                )
                self.port = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('port', self.port)
                self.secure = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure', self.secure)
                self.secure_mode = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('secure_mode', self.secure_mode)
                self.smtp_host = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('smtp_host', self.smtp_host)

                if self.smtp_host is None:
                    # Detect Server if possible
                    self.smtp_host = re.split(r'[\s@]+', self.from_addr)[-1]

                # Adjust email login based on the defined
                # usertype
                login_type = WEBBASE_LOOKUP_TABLE[i][2]\
                    .get('login_type', [])

                if NotifyBase.is_email(self.user) and \
                   WebBaseLogin.EMAIL not in login_type:
                    # Email specified but login type
                    # not supported; switch it to user id
                    self.user = match.group('id')

                elif WebBaseLogin.USERID not in login_type:
                    # user specified but login type
                    # not supported; switch it to email
                    self.user = '%s@%s' % (self.user, self.host)

                break

    def notify(self, title, body, **kwargs):
        """"""
        Perform Email Notification
        """"""

        from_name = self.from_name
        if not from_name:
            from_name = self.app_desc

        self.logger.debug('Email From: %s <%s>' % (
            self.from_addr, from_name))
        self.logger.debug('Email To: %s' % (self.to_addr))
        self.logger.debug('Login ID: %s' % (self.user))
        self.logger.debug('Delivery: %s:%d' % (self.smtp_host, self.port))

        # Prepare Email Message
        if self.notify_format == NotifyFormat.HTML:
            email = MIMEText(body, 'html')

        else:
            email = MIMEText(body, 'plain')

        email['Subject'] = title
        email['From'] = '%s <%s>' % (from_name, self.from_addr)
        email['To'] = self.to_addr
        email['Date'] = datetime.utcnow()\
                                .strftime(""%a, %d %b %Y %H:%M:%S +0000"")
        email['X-Application'] = self.app_id

        # bind the socket variable to the current namespace
        socket = None
        try:
            self.logger.debug('Connecting to remote SMTP server...')
            socket_func = smtplib.SMTP
            if self.secure and self.secure_mode == SecureMailMode.SSL:
                self.logger.debug('Securing connection with SSL...')
                socket_func = smtplib.SMTP_SSL

            socket = socket_func(
                self.smtp_host,
                self.port,
                None,
                timeout=self.timeout,
            )

            if self.secure and self.secure_mode == SecureMailMode.STARTTLS:
                # Handle Secure Connections
                self.logger.debug('Securing connection with STARTTLS...')
                socket.starttls()

            if self.user and self.password:
                # Apply Login credetials
                self.logger.debug('Applying user credentials...')
                socket.login(self.user, self.password)

            # Send the email
            socket.sendmail(self.from_addr, self.to_addr, email.as_string())

            self.logger.info('Sent Email notification to ""%s"".' % (
                self.to_addr,
            ))

        except (SocketError, smtplib.SMTPException, RuntimeError) as e:
            self.logger.warning(
                'A Connection error occured sending Email '
                'notification to %s.' % self.smtp_host)
            self.logger.debug('Socket Exception: %s' % str(e))
            # Return; we're done
            return False

        finally:
            # Gracefully terminate the connection with the server
            if socket is not None:  # pragma: no branch
                socket.quit()

        return True

    @staticmethod
    def parse_url(url):
        """"""
        Parses the URL and returns enough arguments that can allow
        us to substantiate this object.

        """"""
        results = NotifyBase.parse_url(url)

        if not results:
            # We're done early as we couldn't load the results
            return results

        # Apply our settings now

        # Default Format is HTML
        results['notify_format'] = NotifyFormat.HTML
        results['secure_mode'] = NotifyEmail.default_secure_mode

        to_addr = ''
        from_addr = ''
        smtp_host = ''

        if 'format' in results['qsd'] and len(results['qsd']['format']):
            # Extract email format (Text/Html)
            format = NotifyBase.unquote(results['qsd']['format']).lower()
            if len(format) > 0 and format[0] == 't':
                results['notify_format'] = NotifyFormat.TEXT

        # Attempt to detect 'from' email address
        if 'from' in results['qsd'] and len(results['qsd']['from']):
            from_addr = NotifyBase.unquote(results['qsd']['from'])

        else:
            # get 'To' email address
            from_addr = '%s@%s' % (
                re.split(
                    r'[\s@]+', NotifyBase.unquote(results['user']))[0],
                results.get('host', '')
            )
            # Lets be clever and attempt to make the from
            # address an email based on the to address
            from_addr = '%s@%s' % (
                re.split(r'[\s@]+', from_addr)[0],
                re.split(r'[\s@]+', from_addr)[-1],
            )

        # Attempt to detect 'to' email address
        if 'to' in results['qsd'] and len(results['qsd']['to']):
            to_addr = NotifyBase.unquote(results['qsd']['to']).strip()

        if not to_addr:
            # Send to ourselves if not otherwise specified to do so
            to_addr = from_addr

        if 'name' in results['qsd'] and len(results['qsd']['name']):
            # Extract from name to associate with from address
            results['name'] = NotifyBase.unquote(results['qsd']['name'])

        if 'timeout' in results['qsd'] and len(results['qsd']['timeout']):
            # Extract the timeout to associate with smtp server
            results['timeout'] = results['qsd']['timeout']

        # Store SMTP Host if specified
        if 'smtp' in results['qsd'] and len(results['qsd']['smtp']):
            # Extract the smtp server
            smtp_host = NotifyBase.unquote(results['qsd']['smtp'])

        if 'mode' in results['qsd'] and len(results['qsd']['mode']):
            # Extract the secure mode to over-ride the default
            results['secure_mode'] = results['qsd']['mode'].lower()

        results['to'] = to_addr
        results['from'] = from_addr
        results['smtp_host'] = smtp_host

        return results
","@@ -352,11 +352,9 @@ class NotifyEmail(NotifyBase):
         # Prepare Email Message
         if self.notify_format == NotifyFormat.HTML:
             email = MIMEText(body, 'html')
-            email['Content-Type'] = 'text/html'
 
         else:
-            email = MIMEText(body, 'text')
-            email['Content-Type'] = 'text/plain'
+            email = MIMEText(body, 'plain')
 
         email['Subject'] = title
         email['From'] = '%s <%s>' % (from_name, self.from_addr)
",add mail subject and from attributes,0.16,0,-2
